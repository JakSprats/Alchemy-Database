/*
** This file has been pre-processed with DynASM.
** http://luajit.org/dynasm.html
** DynASM version 1.3.0, DynASM arm version 1.3.0
** DO NOT EDIT! The original file is in "buildvm_arm.dasc".
*/

#if DASM_VERSION != 10300
#error "Version mismatch between DynASM and included encoding engine"
#endif

# 1 "buildvm_arm.dasc"
//|// Low-level VM code for ARM CPUs.
//|// Bytecode interpreter, fast functions and helper functions.
//|// Copyright (C) 2005-2011 Mike Pall. See Copyright Notice in luajit.h
//|
//|.arch arm
//|.section code_op, code_sub
#define DASM_SECTION_CODE_OP	0
#define DASM_SECTION_CODE_SUB	1
#define DASM_MAXSECTION		2
# 7 "buildvm_arm.dasc"
//|
//|.actionlist build_actionlist
static const unsigned int build_actionlist[5407] = {
0x00010001,
0x00060014,
0xe3160000,
0x000a0000,
0x0a000000,
0x00050015,
0xe51c6004,
0xe3e01000,
0x000a0000,
0xe1a0900c,
0xe50a1004,
0xe24aa008,
0x00060016,
0xe28bb008,
0xe2160000,
0x000a0000,
0xe58db004,
0x0a000000,
0x00050017,
0x00060018,
0xe3c6c000,
0x000a0000,
0xe3500000,
0x000a0000,
0xe049c00c,
0x1a000000,
0x00050014,
0xe508c000,
0x000d8180,
0xe59d5014,
0xe3e03000,
0x000a0000,
0xe2499008,
0xe25b2008,
0xe1a05185,
0xe5073000,
0x000d8180,
0x0a000000,
0x00050002,
0x0006000b,
0xe2522008,
0xe0ca00d8,
0xe0c900f8,
0x1a000000,
0x0005000b,
0x0006000c,
0xe155000b,
0x1a000000,
0x00050006,
0x0006000d,
0xe5089000,
0x000d8180,
0x00060019,
0x00000000,
0xe59db010,
0xe3a00000,
0xe508b000,
0x000d8180,
0x0006001a,
0xe28dd01c,
0xe8bd8ff0,
0x00060010,
0xba000000,
0x00050007,
0xe5182000,
0x000d8180,
0xe3e01000,
0x000a0000,
0xe1590002,
0x2a000000,
0x00050008,
0xe5891004,
0xe28bb008,
0xe2899008,
0xea000000,
0x0005000c,
0x00060011,
0xe04b0005,
0xe3550000,
0x10499000,
0xea000000,
0x0005000d,
0x00060012,
0xe5089000,
0x000d8180,
0xe1a01005,
0xe1a00008,
0xeb000000,
0x00030000,
0xe5189000,
0x000d8180,
0xea000000,
0x0005000c,
0x0006001b,
0xe1a0d000,
0xe1a00001,
0x0006001c,
0xe59d800c,
0xe3e03000,
0x000a0000,
0xe5182000,
0x000d8180,
0xe5023000,
0x000d8180,
0xea000000,
0x0005001a,
0x0006001d,
0x00000000,
0xe3c0d000,
0x000a0000,
0x0006001e,
0xe59d800c,
0xe3a040ff,
0xe3a0b010,
0xe1a04184,
0xe5189000,
0x000d8180,
0xe5187000,
0x000d8180,
0xe3e00000,
0x000a0000,
0xe249a008,
0xe5196004,
0xe2877000,
0x000a0000,
0xe3e01000,
0x000a0000,
0xe5090004,
0xe5071000,
0x000d8180,
0xea000000,
0x00050016,
0x0006001f,
0xe3a01000,
0x000a0000,
0xea000000,
0x00050002,
0x00060020,
0xe089b00b,
0xe04aa009,
0xe1a00008,
0xe5089000,
0x000d8180,
0xe2866004,
0xe508b000,
0x000d8180,
0xe1a021aa,
0x0006000c,
0xe58d6008,
0xeb000000,
0x00030000,
0xe5189000,
0x000d8180,
0xe518b000,
0x000d8180,
0xe5192008,
0xe04bb009,
0xe5126000,
0x000d8180,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe08aa009,
0xe12fff1c,
0x00060021,
0xe92d4ff0,
0xe24dd01c,
0xe1a08000,
0xe5107000,
0x000d8180,
0x00000000,
0xe1a09001,
0xe2877000,
0x000a0000,
0xe58d800c,
0xe3a06000,
0x000a0000,
0xe58d2014,
0xe28d1000,
0x000a0000,
0xe5580000,
0x000d8180,
0xe58d2018,
0xe5081000,
0x000d8180,
0xe58d2010,
0xe3500000,
0xe58d8008,
0x0a000000,
0x00050003,
0xe1a0a009,
0xe5189000,
0x000d8180,
0xe5180000,
0x000d8180,
0xe3a040ff,
0xe5482000,
0x000d8180,
0xe040b009,
0xe5196004,
0xe1a04184,
0xe3e01000,
0x000a0000,
0xe28bb008,
0xe2160000,
0x000a0000,
0xe5071000,
0x000d8180,
0xe58db004,
0x0a000000,
0x00050017,
0xea000000,
0x00050018,
0x00060022,
0xe92d4ff0,
0xe24dd01c,
0xe3a06000,
0x000a0000,
0xe58d3018,
0xea000000,
0x00050001,
0x00060023,
0xe92d4ff0,
0xe24dd01c,
0xe3a06000,
0x000a0000,
0x0006000b,
0xe510b000,
0x000d8180,
0xe58d2014,
0xe1a08000,
0xe58d000c,
0xe1a09001,
0xe508d000,
0x000d8180,
0x00000000,
0xe5187000,
0x000d8180,
0xe58d0008,
0xe58db010,
0xe2877000,
0x000a0000,
0x0006000d,
0xe518c000,
0x000d8180,
0xe5180000,
0x000d8180,
0xe3a040ff,
0xe0866009,
0xe1a04184,
0xe046600c,
0xe3e01000,
0x000a0000,
0xe040b009,
0xe5071000,
0x000d8180,
0x00060024,
0xe14920d8,
0xe3730000,
0x000a0000,
0x1a000000,
0x00050025,
0x00060026,
0xe5096004,
0xe5126000,
0x000d8180,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe08aa009,
0xe12fff1c,
0x00060027,
0xe92d4ff0,
0xe24dd01c,
0xe1a08000,
0xe510a000,
0x000d8180,
0xe58d000c,
0xe518c000,
0x000d8180,
0xe58d0008,
0xe518b000,
0x000d8180,
0xe04aa00c,
0xe508d000,
0x000d8180,
0xe3a0c000,
0xe58da014,
0xe58dc018,
0xe58db010,
0xe12fff33,
0xe5187000,
0x000d8180,
0xe1b09000,
0xe3a06000,
0x000a0000,
0xe2877000,
0x000a0000,
0x1a000000,
0x0005000d,
0xea000000,
0x00050019,
0x00060015,
0x00000000,
0xe51c2008,
0xe5190010,
0xe1a03009,
0xe1a0900c,
0xe3500000,
0xe513600c,
0x0a000000,
0x00050001,
0xe5122000,
0x000d8180,
0xe3e0e000,
0x000a0000,
0xe08a100b,
0xe501e004,
0xe5125000,
0x000d8180,
0xe12fff10,
0x0006000b,
0xe5192008,
0xe2433010,
0xe043b009,
0xea000000,
0x00050028,
0x00060029,
0xe516e004,
0xe2431010,
0xe1ca20d0,
0xe5089000,
0x000d8180,
0xe004baae,
0xe004a2ae,
0xe089000b,
0xe0510000,
0x11c120f0,
0x11a02000,
0x1a000000,
0x0005002a,
0xe18920fa,
0xea000000,
0x0005002b,
0x0006002c,
0xe089100c,
0xea000000,
0x00050002,
0x0006002d,
0xe2471000,
0x000a0000,
0xe3e03000,
0x000a0000,
0xe581c000,
0xe5813004,
0x0006000c,
0xe3e03000,
0x000a0000,
0xe58db000,
0xe58d3004,
0xe1a0200d,
0xea000000,
0x00050001,
0x0006002e,
0xe004caae,
0xe58db000,
0xe3e03000,
0x000a0000,
0xe089100c,
0xe58d3004,
0xe1a0200d,
0xea000000,
0x00050001,
0x0006002f,
0x00000000,
0xe089100c,
0xe089200b,
0x0006000b,
0xe5089000,
0x000d8180,
0xe1a00008,
0xe58d6008,
0xeb000000,
0x00030001,
0x00000000,
0xe5189000,
0x000d8180,
0x00000000,
0xe3500000,
0x0a000000,
0x00050003,
0xe1c020d0,
0xe5d6c000,
0xe496e004,
0xe18920fa,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x0006000d,
0xe2690000,
0x000a0000,
0xe5189000,
0x000d8180,
0xe3a0b010,
0xe509600c,
0xe0806009,
0xe5192008,
0xea000000,
0x00050026,
0x00060030,
0xe089100c,
0xea000000,
0x00050002,
0x00060031,
0xe2471000,
0x000a0000,
0xe3e03000,
0x000a0000,
0xe581c000,
0xe5813004,
0x0006000c,
0xe3e03000,
0x000a0000,
0xe58db000,
0xe58d3004,
0xe1a0200d,
0xea000000,
0x00050001,
0x00060032,
0xe004caae,
0xe58db000,
0xe3e03000,
0x000a0000,
0xe089100c,
0xe58d3004,
0xe1a0200d,
0xea000000,
0x00050001,
0x00060033,
0xe089100c,
0xe089200b,
0x0006000b,
0xe5089000,
0x000d8180,
0xe1a00008,
0xe58d6008,
0xeb000000,
0x00030002,
0x00000000,
0xe5189000,
0x000d8180,
0x00000000,
0xe3500000,
0xe18920da,
0x0a000000,
0x00050003,
0xe5d6c000,
0xe1c020f0,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x0006000d,
0xe2690000,
0x000a0000,
0xe5189000,
0x000d8180,
0xe3a0b018,
0xe1c921f0,
0xe509600c,
0xe0806009,
0xe5192008,
0xea000000,
0x00050026,
0x00060034,
0xe1a00008,
0xe2466004,
0xe1a0100a,
0xe5089000,
0x000d8180,
0xe1a0200b,
0xe58d6008,
0xe20e30ff,
0xeb000000,
0x00030003,
0x0006000d,
0x00000000,
0xe5189000,
0x000d8180,
0x00000000,
0xe3500001,
0x8a000000,
0x00050035,
0x0006000e,
0xe1d6c0b2,
0xe2866004,
0xe086c10c,
0x224c6b80,
0x0006002b,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00060036,
0xe516e004,
0xe1ca00d0,
0xe00422ae,
0xe18900f2,
0xea000000,
0x0005002b,
0x00060037,
0xe59a1004,
0xe3e00000,
0x000a0000,
0xe1500001,
0xea000000,
0x0005000e,
0x00060038,
0xe59a1004,
0xe3710000,
0x000a0000,
0xea000000,
0x0005000e,
0x00060039,
0xe2466004,
0xe5089000,
0x000d8180,
0xe1a00008,
0xe58d6008,
0xeb000000,
0x00030004,
0xea000000,
0x0005000d,
0x0006003a,
0x00000000,
0xe2466004,
0xe5089000,
0x000d8180,
0xe1a00008,
0xe1a0100e,
0xe58d6008,
0xeb000000,
0x00030005,
0xea000000,
0x0005000d,
0x00000000,
0x0006003b,
0xe004caae,
0xe004b6ae,
0xe089200c,
0xe085300b,
0xea000000,
0x00050001,
0x0006003c,
0xe004caae,
0xe004b6ae,
0xe089300c,
0xe085200b,
0xea000000,
0x00050001,
0x0006003d,
0xe516e008,
0xe2466004,
0xe089200b,
0xe089300b,
0xea000000,
0x00050001,
0x0006003e,
0xe004caae,
0xe004b6ae,
0xe089200c,
0xe089300b,
0x0006000b,
0xe20ec0ff,
0xe089100a,
0xe5089000,
0x000d8180,
0xe1a00008,
0xe58d6008,
0xe58dc000,
0xeb000000,
0x00030006,
0x00000000,
0xe5189000,
0x000d8180,
0x00000000,
0xe3500000,
0x0a000000,
0x0005002b,
0x00060035,
0xe0401009,
0xe500600c,
0xe2816000,
0x000a0000,
0xe1a09000,
0xe3a0b010,
0xea000000,
0x00050024,
0x0006003f,
0xe089100b,
0xe5089000,
0x000d8180,
0xe1a00008,
0xe58d6008,
0xeb000000,
0x00030007,
0x00000000,
0xe5189000,
0x000d8180,
0x00000000,
0xea000000,
0x00050035,
0x00060025,
0xe1a00008,
0xe508c000,
0x000d8180,
0xe2491008,
0xe58d6008,
0xe089200b,
0x00000000,
0xe1a0a009,
0x00000000,
0xeb000000,
0x00030008,
0x00000000,
0xe1a0900a,
0x00000000,
0xe5192008,
0xe28bb008,
0xe5096004,
0xe5126000,
0x000d8180,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe08aa009,
0xe12fff1c,
0x00060040,
0xe1a00008,
0xe5089000,
0x000d8180,
0xe24a1008,
0xe58d6008,
0xe08a200b,
0xeb000000,
0x00030008,
0x00000000,
0xe5189000,
0x000d8180,
0x00000000,
0xe51a2008,
0xe5196004,
0xe28bb008,
0xea000000,
0x00050041,
0x00060042,
0xe1a00008,
0xe5089000,
0x000d8180,
0xe1a0100a,
0xe58d6008,
0xeb000000,
0x00030009,
0x00000000,
0xe5189000,
0x000d8180,
0x00000000,
0xe556c004,
0x00000000,
0xe516e004,
0x00000000,
0xe35c0000,
0x000a0000,
0x00000000,
0xe004a2ae,
0xe1a0b82e,
0x00000000,
0x0a000000,
0x00070000,
0x00000000,
0xea000000,
0x00070000,
0x00060043,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050044,
0xe3710000,
0x000a0000,
0x8a000000,
0x00050044,
0xe5196004,
0xe14900f8,
0xe1a0c009,
0xe25ba008,
0xe28bb008,
0x0a000000,
0x00050045,
0x0006000b,
0xe1cc00d8,
0xe25aa008,
0xe0cc00f8,
0x1a000000,
0x0005000b,
0xea000000,
0x00050045,
0x00060046,
0xe5991004,
0xe35b0008,
0x3a000000,
0x00050044,
0xe3710000,
0x000a0000,
0x33e01000,
0x000a0000,
0xe2613000,
0x000a0000,
0xe1a03183,
0xe18200d3,
0xea000000,
0x00050047,
0x00060048,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050044,
0xe3710000,
0x000a0000,
0x13710000,
0x000a0000,
0x1a000000,
0x00050006,
0x0006000b,
0xe510c000,
0x000d8180,
0x0006000c,
0x00000000,
0xe3e01000,
0x000a0000,
0xe517b000,
0x000d8180,
0xe35c0000,
0x0a000000,
0x00050047,
0xe51c2000,
0x000d8180,
0xe51b3000,
0x000d8180,
0xe51ce000,
0x000d8180,
0xe0022003,
0xe0822082,
0xe08ee182,
0x0006000d,
0xe14e20d0,
0x000c8100,
0xe14e00d0,
0x000c8100,
0xe51ee000,
0x000d8180,
0xe152000b,
0x03730000,
0x000a0000,
0x0a000000,
0x00050005,
0xe35e0000,
0x1a000000,
0x0005000d,
0x0006000e,
0xe1a0000c,
0xe3e01000,
0x000a0000,
0xea000000,
0x00050047,
0x0006000f,
0xe3710000,
0x000a0000,
0x1a000000,
0x00050047,
0xea000000,
0x0005000e,
0x00060010,
0xe3710000,
0x000a0000,
0x00000000,
0x21e01001,
0x33a01000,
0x000a0000,
0xe0873101,
0xe513c000,
0x000d8180,
0xea000000,
0x0005000c,
0x00060049,
0xe1c900d0,
0xe1c920d8,
0xe35b0010,
0x3a000000,
0x00050044,
0xe3710000,
0x000a0000,
0x0510c000,
0x000d8180,
0x03730000,
0x000a0000,
0x05503000,
0x000d8180,
0x035c0000,
0x1a000000,
0x00050044,
0xe3130000,
0x000a0000,
0xe5002000,
0x000d8180,
0x0a000000,
0x00050047,
0xe5172000,
0x000d8180,
0xe3c33000,
0x000a0000,
0xe5070000,
0x000d8180,
0xe5403000,
0x000d8180,
0xe5002000,
0x000d8180,
0xea000000,
0x00050047,
0x0006004a,
0xe1c920d0,
0xe35b0010,
0x3a000000,
0x00050044,
0xe1a01002,
0xe3730000,
0x000a0000,
0x00000000,
0x1a000000,
0x00050044,
0xe1a00008,
0xe2892008,
0x00000000,
0xe1a0a009,
0x00000000,
0xeb000000,
0x0003000a,
0x00000000,
0xe1a0900a,
0x00000000,
0xe1c000d0,
0xea000000,
0x00050047,
0x0006004b,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050044,
0xe3710000,
0x000a0000,
0x9a000000,
0x00050047,
0xea000000,
0x00050044,
0x0006004c,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050044,
0xe3710000,
0x000a0000,
0x0a000000,
0x00050047,
0xe5173000,
0x000d8180,
0xe5089000,
0x000d8180,
0xe3710000,
0x000a0000,
0x93530000,
0xe58d6008,
0x8a000000,
0x00050044,
0xe5170000,
0x000d8180,
0xe5171000,
0x000d8180,
0xe1500001,
0xab000000,
0x0005004d,
0xe1a00008,
0xe1a01009,
0xeb000000,
0x0003000b,
0xe5189000,
0x000d8180,
0xe3e01000,
0x000a0000,
0xea000000,
0x00050047,
0x0006004e,
0x00000000,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050044,
0xe3e03000,
0x000a0000,
0xe3710000,
0x000a0000,
0x1a000000,
0x00050044,
0xe18920fb,
0xe5196004,
0xe1a01000,
0xe5089000,
0x000d8180,
0xe1a00008,
0xe5089000,
0x000d8180,
0xe2892008,
0xe58d6008,
0xeb000000,
0x0003000c,
0x00000000,
0xe5189000,
0x000d8180,
0x00000000,
0xe3500000,
0x03e01000,
0x000a0000,
0x0a000000,
0x00050047,
0xe1c900d8,
0xe1c921d0,
0xe3a0b000,
0x000a0000,
0xe14900f8,
0xe1c920f0,
0xea000000,
0x00050045,
0x0006004f,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050044,
0xe3710000,
0x000a0000,
0x1a000000,
0x00050044,
0x00000000,
0xe510c000,
0x000d8180,
0x00000000,
0xe14220d0,
0x000c8100,
0xe5196004,
0x00000000,
0xe35c0000,
0x1a000000,
0x00050044,
0x00000000,
0xe3e01000,
0x000a0000,
0xe3a0b000,
0x000a0000,
0xe14920f8,
0xe589100c,
0xea000000,
0x00050045,
0x00060050,
0xe1c900d0,
0xe1c920d8,
0xe35b0010,
0x3a000000,
0x00050044,
0xe3710000,
0x000a0000,
0x03730000,
0x000a0000,
0x1a000000,
0x00050044,
0xe510c000,
0x000d8180,
0xe510b000,
0x000d8180,
0xe2822001,
0xe5196004,
0xe152000c,
0xe08bb182,
0xe14920f8,
0x31cb00d0,
0xe3a0b000,
0x000a0000,
0x2a000000,
0x00050002,
0x0006000b,
0xe3710000,
0x000a0000,
0x13a0b000,
0x000a0000,
0x11c900f0,
0xea000000,
0x00050045,
0x0006000c,
0xe510c000,
0x000d8180,
0xe1a01002,
0xe35c0000,
0x0a000000,
0x00050045,
0x00000000,
0xe1a0a009,
0x00000000,
0xeb000000,
0x0003000d,
0x00000000,
0xe1a0900a,
0x00000000,
0xe3500000,
0x0a000000,
0x00050045,
0xe1c000d0,
0xea000000,
0x0005000b,
0x00060051,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050044,
0xe3710000,
0x000a0000,
0x1a000000,
0x00050044,
0x00000000,
0xe510c000,
0x000d8180,
0x00000000,
0xe14220d0,
0x000c8100,
0xe5196004,
0x00000000,
0xe35c0000,
0x1a000000,
0x00050044,
0x00000000,
0xe3a00000,
0xe3e01000,
0x000a0000,
0xe3a0b000,
0x000a0000,
0xe14920f8,
0xe1c900f8,
0xea000000,
0x00050045,
0x00060052,
0xe557a000,
0x000d8180,
0xe35b0008,
0x3a000000,
0x00050044,
0xe31a0000,
0x000a0000,
0xe1a0c009,
0xe2899008,
0x03a06000,
0x000a0000,
0x13a06000,
0x000a0000,
0xe24bb008,
0xea000000,
0x00050024,
0x00060053,
0xe1c900d0,
0xe1c920d8,
0xe35b0010,
0x3a000000,
0x00050044,
0xe557a000,
0x000d8180,
0xe3730000,
0x000a0000,
0x1a000000,
0x00050044,
0xe1a0c009,
0xe1c900f8,
0xe1c920f0,
0xe31a0000,
0x000a0000,
0xe2899010,
0x03a06000,
0x000a0000,
0x13a06000,
0x000a0000,
0xe24bb010,
0xea000000,
0x00050024,
0x00060054,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050044,
0xe3710000,
0x000a0000,
0x00000000,
0x1a000000,
0x00050044,
0xe5196004,
0xe5089000,
0x000d8180,
0xe5101000,
0x000d8180,
0xe550a000,
0x000d8180,
0xe510c000,
0x000d8180,
0xe081200b,
0xe081300a,
0xe58d6008,
0xe153000c,
0x0a000000,
0x00050044,
0xe5103000,
0x000d8180,
0xe510c000,
0x000d8180,
0xe35a0000,
0x000a0000,
0x91520003,
0x935c0000,
0x8a000000,
0x00050044,
0x0006000b,
0xe2422008,
0xe2899008,
0xe24bb008,
0xe5002000,
0x000d8180,
0xe5089000,
0x000d8180,
0x0006000c,
0xe18920dc,
0xe15c000b,
0x118120fc,
0xe28cc008,
0x1a000000,
0x0005000c,
0xe3a02000,
0xe1a0a000,
0xe3a03000,
0xeb000000,
0x00050021,
0x0006000e,
0xe51a2000,
0x000d8180,
0xe3e01000,
0x000a0000,
0xe51a3000,
0x000d8180,
0xe5071000,
0x000d8180,
0xe3500000,
0x000a0000,
0x00000000,
0xe5189000,
0x000d8180,
0x8a000000,
0x00050008,
0xe053b002,
0xe5180000,
0x000d8180,
0xe089100b,
0x0a000000,
0x00050006,
0xe1510000,
0xe3a0c000,
0x8a000000,
0x00050009,
0xe24b3008,
0xe50a2000,
0x000d8180,
0x0006000f,
0xe18200dc,
0xe15c0003,
0xe18900fc,
0xe28cc008,
0x1a000000,
0x0005000f,
0x00060010,
0xe3e02000,
0x000a0000,
0xe28bb010,
0x00060011,
0xe5092004,
0xe249a008,
0xe2160000,
0x000a0000,
0xe58d6008,
0xe58db004,
0x0a000000,
0x00050017,
0xea000000,
0x00050018,
0x00060012,
0xe16300d8,
0xe3e02000,
0x000a0000,
0xe3a0b000,
0x000a0000,
0xe50a3000,
0x000d8180,
0xe1c900f0,
0xea000000,
0x00050011,
0x00060013,
0xe1a00008,
0xe1a011ab,
0xeb000000,
0x00030000,
0xe3a00000,
0xea000000,
0x0005000e,
0x00060055,
0x00000000,
0xe5120000,
0x000d8180,
0xe5196004,
0xe5089000,
0x000d8180,
0xe5101000,
0x000d8180,
0xe550a000,
0x000d8180,
0xe510c000,
0x000d8180,
0xe081200b,
0xe081300a,
0xe58d6008,
0xe153000c,
0x0a000000,
0x00050044,
0xe5103000,
0x000d8180,
0xe510c000,
0x000d8180,
0xe35a0000,
0x000a0000,
0x91520003,
0x935c0000,
0x8a000000,
0x00050044,
0x0006000b,
0xe5002000,
0x000d8180,
0xe5089000,
0x000d8180,
0x0006000c,
0xe18920dc,
0xe15c000b,
0x118120fc,
0xe28cc008,
0x1a000000,
0x0005000c,
0xe3a02000,
0xe1a0a000,
0xe3a03000,
0xeb000000,
0x00050021,
0x0006000e,
0xe51a2000,
0x000d8180,
0xe3e01000,
0x000a0000,
0xe51a3000,
0x000d8180,
0xe5071000,
0x000d8180,
0xe3500000,
0x000a0000,
0x00000000,
0xe5189000,
0x000d8180,
0x8a000000,
0x00050008,
0xe053b002,
0xe5180000,
0x000d8180,
0xe089100b,
0x0a000000,
0x00050006,
0xe1510000,
0xe3a0c000,
0x8a000000,
0x00050009,
0xe24b3008,
0xe50a2000,
0x000d8180,
0x0006000f,
0xe18200dc,
0xe15c0003,
0xe18900fc,
0xe28cc008,
0x1a000000,
0x0005000f,
0x00060010,
0xe1a0a009,
0xe28bb008,
0xe2160000,
0x000a0000,
0xe58d6008,
0xe58db004,
0x0a000000,
0x00050017,
0xea000000,
0x00050018,
0x00060012,
0xe1a00008,
0xe1a0100a,
0xeb000000,
0x0003000e,
0x00060013,
0xe1a00008,
0xe1a011ab,
0xeb000000,
0x00030000,
0xe3a00000,
0xea000000,
0x0005000e,
0x00060056,
0xe5180000,
0x000d8180,
0xe089100b,
0xe5089000,
0x000d8180,
0xe3100000,
0x000a0000,
0xe5081000,
0x000d8180,
0x00000000,
0xe3a00000,
0x000a0000,
0xe3a02000,
0x0a000000,
0x00050044,
0xe5082000,
0x000d8180,
0xe5480000,
0x000d8180,
0xea000000,
0x0005001a,
0x00060057,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050044,
0xe3710000,
0x000a0000,
0x0a000000,
0x00050047,
0x8a000000,
0x00050044,
0xe1a02081,
0xe292c980,
0x5a000000,
0x00050002,
0xe3e03ff8,
0xe053cacc,
0xe1a03581,
0xe1a02580,
0xe3833480,
0xe26ce020,
0xe1833aa0,
0x9a000000,
0x00050003,
0xe1822e13,
0xe1a00c33,
0xe1120fc1,
0x12800001,
0xe3510000,
0xb2600000,
0x0006000b,
0xe3e01000,
0x000a0000,
0xea000000,
0x00050047,
0x0006000c,
0xe1822000,
0xe1120fc1,
0x03a00000,
0x13e00000,
0xe3e01000,
0x000a0000,
0xea000000,
0x00050047,
0x0006000d,
0x03530480,
0x03520000,
0x1a000000,
0x00050004,
0xe3510000,
0x43a00480,
0x4a000000,
0x0005000b,
0x0006000e,
0x00000000,
0xe1a0a009,
0x00000000,
0xeb000000,
0x0003000f,
0x00000000,
0xe1a0900a,
0x00000000,
0xea000000,
0x00050047,
0x00060058,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050044,
0xe3710000,
0x000a0000,
0x0a000000,
0x00050047,
0x8a000000,
0x00050044,
0xe1a02081,
0xe292c980,
0x5a000000,
0x00050002,
0xe3e03ff8,
0xe053cacc,
0xe1a03581,
0xe1a02580,
0xe3833480,
0xe26ce020,
0xe1833aa0,
0x9a000000,
0x00050003,
0xe1822e13,
0xe1a00c33,
0xe1d22fc1,
0x12900001,
0x614f00d0,
0x00051809,
0x6a000000,
0x00050047,
0xe3510000,
0xb2600000,
0x0006000b,
0xe3e01000,
0x000a0000,
0xea000000,
0x00050047,
0x0006000c,
0xe1822000,
0xe1d22fc1,
0x03a00000,
0x13a00001,
0xe3e01000,
0x000a0000,
0xea000000,
0x00050047,
0x0006000d,
0x03530480,
0x1a000000,
0x00050004,
0xe3510000,
0x43a00480,
0x4a000000,
0x0005000b,
0x0006000e,
0x00000000,
0xe1a0a009,
0x00000000,
0xeb000000,
0x00030010,
0x00000000,
0xe1a0900a,
0x00000000,
0xea000000,
0x00050047,
0x00040007,
0x00060013,
0x00020000,
0x00000000,
0x41e00000,
0x00060059,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050044,
0xe3710000,
0x000a0000,
0x8a000000,
0x00050044,
0x13c11480,
0x1a000000,
0x00050047,
0xe3500000,
0xb2700000,
0x614f00d0,
0x00051813,
0x00060047,
0xe5196004,
0xe14900f8,
0x0006005a,
0xe3a0b000,
0x000a0000,
0x00060045,
0xe2160000,
0x000a0000,
0x0516e004,
0xe58db004,
0xe249a008,
0x1a000000,
0x00050018,
0xe004caae,
0x0006000f,
0xe15c000b,
0x8a000000,
0x00050006,
0xe00402ae,
0xe5d6c000,
0xe496e004,
0xe04a9000,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00060010,
0xe08a100b,
0xe3e00000,
0x000a0000,
0xe28bb008,
0xe5010004,
0xea000000,
0x0005000f,
0x0006005b,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050044,
0x00000000,
0xe3710000,
0x000a0000,
0x2a000000,
0x00050044,
0x00000000,
0xe1a0a009,
0x00000000,
0xeb000000,
0x00030011,
0x00000000,
0xe1a0900a,
0x00000000,
0xea000000,
0x00050047,
0x0006005c,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050044,
0xe3710000,
0x000a0000,
0x2a000000,
0x00050044,
0x00000000,
0xe1a0a009,
0x00000000,
0xeb000000,
0x00030012,
0x00000000,
0xe1a0900a,
0x00000000,
0xea000000,
0x00050047,
0x0006005d,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050044,
0xe3710000,
0x000a0000,
0x2a000000,
0x00050044,
0x00000000,
0xe1a0a009,
0x00000000,
0xeb000000,
0x00030013,
0x00000000,
0xe1a0900a,
0x00000000,
0xea000000,
0x00050047,
0x0006005e,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050044,
0xe3710000,
0x000a0000,
0x2a000000,
0x00050044,
0x00000000,
0xe1a0a009,
0x00000000,
0xeb000000,
0x00030014,
0x00000000,
0xe1a0900a,
0x00000000,
0xea000000,
0x00050047,
0x0006005f,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050044,
0xe3710000,
0x000a0000,
0x2a000000,
0x00050044,
0x00000000,
0xe1a0a009,
0x00000000,
0xeb000000,
0x00030015,
0x00000000,
0xe1a0900a,
0x00000000,
0xea000000,
0x00050047,
0x00060060,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050044,
0xe3710000,
0x000a0000,
0x2a000000,
0x00050044,
0x00000000,
0xe1a0a009,
0x00000000,
0xeb000000,
0x00030016,
0x00000000,
0xe1a0900a,
0x00000000,
0xea000000,
0x00050047,
0x00060061,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050044,
0xe3710000,
0x000a0000,
0x2a000000,
0x00050044,
0x00000000,
0xe1a0a009,
0x00000000,
0xeb000000,
0x00030017,
0x00000000,
0xe1a0900a,
0x00000000,
0xea000000,
0x00050047,
0x00060062,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050044,
0xe3710000,
0x000a0000,
0x2a000000,
0x00050044,
0x00000000,
0xe1a0a009,
0x00000000,
0xeb000000,
0x00030018,
0x00000000,
0xe1a0900a,
0x00000000,
0xea000000,
0x00050047,
0x00060063,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050044,
0xe3710000,
0x000a0000,
0x2a000000,
0x00050044,
0x00000000,
0xe1a0a009,
0x00000000,
0xeb000000,
0x00030019,
0x00000000,
0xe1a0900a,
0x00000000,
0xea000000,
0x00050047,
0x00060064,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050044,
0xe3710000,
0x000a0000,
0x2a000000,
0x00050044,
0x00000000,
0xe1a0a009,
0x00000000,
0xeb000000,
0x0003001a,
0x00000000,
0xe1a0900a,
0x00000000,
0xea000000,
0x00050047,
0x00060065,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050044,
0xe3710000,
0x000a0000,
0x2a000000,
0x00050044,
0x00000000,
0xe1a0a009,
0x00000000,
0xeb000000,
0x0003001b,
0x00000000,
0xe1a0900a,
0x00000000,
0xea000000,
0x00050047,
0x00060066,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050044,
0xe3710000,
0x000a0000,
0x2a000000,
0x00050044,
0x00000000,
0xe1a0a009,
0x00000000,
0xeb000000,
0x0003001c,
0x00000000,
0xe1a0900a,
0x00000000,
0xea000000,
0x00050047,
0x00060067,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050044,
0xe3710000,
0x000a0000,
0x2a000000,
0x00050044,
0x00000000,
0xe1a0a009,
0x00000000,
0xeb000000,
0x0003001d,
0x00000000,
0xe1a0900a,
0x00000000,
0xea000000,
0x00050047,
0x00060068,
0xe1c900d0,
0xe1c920d8,
0xe35b0010,
0x3a000000,
0x00050044,
0xe3710000,
0x000a0000,
0x33730000,
0x000a0000,
0x2a000000,
0x00050044,
0x00000000,
0xe1a0a009,
0x00000000,
0xeb000000,
0x0003001e,
0x00000000,
0xe1a0900a,
0x00000000,
0xea000000,
0x00050047,
0x00060069,
0xe1c900d0,
0xe1c920d8,
0xe35b0010,
0x3a000000,
0x00050044,
0xe3710000,
0x000a0000,
0x33730000,
0x000a0000,
0x2a000000,
0x00050044,
0x00000000,
0xe1a0a009,
0x00000000,
0xeb000000,
0x0003001f,
0x00000000,
0xe1a0900a,
0x00000000,
0xea000000,
0x00050047,
0x0006006a,
0xe1c900d0,
0xe1c920d8,
0xe35b0010,
0x3a000000,
0x00050044,
0xe3710000,
0x000a0000,
0x33730000,
0x000a0000,
0x2a000000,
0x00050044,
0x00000000,
0xe1a0a009,
0x00000000,
0xeb000000,
0x00030020,
0x00000000,
0xe1a0900a,
0x00000000,
0xea000000,
0x00050047,
0x0006006b,
0x0006006c,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050044,
0xe3710000,
0x000a0000,
0x2a000000,
0x00050044,
0xe14220d0,
0x000c8100,
0xeb000000,
0x00030021,
0xea000000,
0x00050047,
0x0006006d,
0xe1c900d0,
0xe1c920d8,
0xe35b0010,
0x3a000000,
0x00050044,
0xe3710000,
0x000a0000,
0x2a000000,
0x00050044,
0xe3730000,
0x000a0000,
0x1a000000,
0x00050044,
0x00000000,
0xe1a0a009,
0x00000000,
0xeb000000,
0x00030022,
0x00000000,
0xe1a0900a,
0x00000000,
0xea000000,
0x00050047,
0x0006006e,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050044,
0xe3710000,
0x000a0000,
0x2a000000,
0x00050044,
0xe1a0200d,
0x00000000,
0xe1a0a009,
0x00000000,
0xeb000000,
0x00030023,
0x00000000,
0xe1a0900a,
0x00000000,
0xe59d2000,
0xe3e03000,
0x000a0000,
0xe5196004,
0xe14900f8,
0xe3a0b000,
0x000a0000,
0xe1c920f0,
0xea000000,
0x00050045,
0x0006006f,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050044,
0xe3710000,
0x000a0000,
0x2a000000,
0x00050044,
0xe2492008,
0xe5196004,
0x00000000,
0xe1a0a009,
0x00000000,
0xeb000000,
0x00030024,
0x00000000,
0xe1a0900a,
0x00000000,
0xe3a0b000,
0x000a0000,
0xe1c900f0,
0xea000000,
0x00050045,
0x00060070,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050044,
0xe3710000,
0x000a0000,
0xe3a0a008,
0x1a000000,
0x00050004,
0x0006000b,
0xe18920da,
0xe15a000b,
0x2a000000,
0x00050047,
0xe3730000,
0x000a0000,
0x1a000000,
0x00050003,
0xe1500002,
0xe28aa008,
0xc1a00002,
0xea000000,
0x0005000b,
0x0006000d,
0x8a000000,
0x00050044,
0xeb000000,
0x00030025,
0xe18920da,
0xea000000,
0x00050006,
0x0006000e,
0x8a000000,
0x00050044,
0x0006000f,
0xe18920da,
0xe15a000b,
0x2a000000,
0x00050047,
0xe3730000,
0x000a0000,
0x2a000000,
0x00050007,
0x00060010,
0x00000000,
0xeb000000,
0x00030026,
0xe28aa008,
0x81a00002,
0x81a01003,
0xea000000,
0x0005000f,
0x00060011,
0x8a000000,
0x00050044,
0xe1cd00f0,
0xe1a00002,
0xeb000000,
0x00030025,
0xe1cd20d0,
0xea000000,
0x00050010,
0x00060071,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050044,
0xe3710000,
0x000a0000,
0xe3a0a008,
0x1a000000,
0x00050004,
0x0006000b,
0xe18920da,
0xe15a000b,
0x2a000000,
0x00050047,
0xe3730000,
0x000a0000,
0x1a000000,
0x00050003,
0xe1500002,
0xe28aa008,
0xb1a00002,
0xea000000,
0x0005000b,
0x0006000d,
0x8a000000,
0x00050044,
0xeb000000,
0x00030025,
0xe18920da,
0xea000000,
0x00050006,
0x0006000e,
0x8a000000,
0x00050044,
0x0006000f,
0x00000000,
0xe18920da,
0xe15a000b,
0x2a000000,
0x00050047,
0xe3730000,
0x000a0000,
0x2a000000,
0x00050007,
0x00060010,
0xeb000000,
0x00030026,
0xe28aa008,
0x31a00002,
0x31a01003,
0xea000000,
0x0005000f,
0x00060011,
0x8a000000,
0x00050044,
0xe1cd00f0,
0xe1a00002,
0xeb000000,
0x00030025,
0xe1cd20d0,
0xea000000,
0x00050010,
0x00060072,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050044,
0xe3710000,
0x000a0000,
0x1a000000,
0x00050044,
0xe5100000,
0x000d8180,
0xe3e01000,
0x000a0000,
0xea000000,
0x00050047,
0x00060073,
0xe1c900d0,
0xe5196004,
0xe35b0008,
0x03710000,
0x000a0000,
0x1a000000,
0x00050044,
0xe5102000,
0x000d8180,
0xe5500000,
0x000d8180,
0x00000000,
0xe3e01000,
0x000a0000,
0xe3520000,
0x03a0b000,
0x000a0000,
0x13a0b000,
0x000a0000,
0xe14900f8,
0xea000000,
0x00050045,
0x00060074,
0xe5170000,
0x000d8180,
0xe5171000,
0x000d8180,
0xe1500001,
0xab000000,
0x0005004d,
0xe1c900d0,
0xe5196004,
0xe35b0008,
0x03710000,
0x000a0000,
0x03d030ff,
0xe3a02001,
0x1a000000,
0x00050044,
0xe58d0000,
0xe1a0100d,
0x00060075,
0xe5089000,
0x000d8180,
0xe1a00008,
0xe58d6008,
0xeb000000,
0x00030027,
0xe5189000,
0x000d8180,
0xe3e01000,
0x000a0000,
0xea000000,
0x00050047,
0x00060076,
0xe5170000,
0x000d8180,
0xe5171000,
0x000d8180,
0xe1500001,
0xab000000,
0x0005004d,
0xe1c900d0,
0xe1c921d0,
0xe35b0010,
0xe3e0c000,
0x0a000000,
0x00050001,
0x3a000000,
0x00050044,
0x00000000,
0xe3730000,
0x000a0000,
0xe1a0c002,
0x1a000000,
0x00050044,
0x0006000b,
0xe5992008,
0xe3710000,
0x000a0000,
0x05101000,
0x000d8180,
0x03730000,
0x000a0000,
0x1a000000,
0x00050044,
0xe2813001,
0xe3520000,
0xb0822003,
0xe3520001,
0xb3a02001,
0xe35c0000,
0xb08cc003,
0xe1cccfcc,
0xe15c0001,
0xe2800000,
0x000a0000,
0xc1a0c001,
0xe0801002,
0xe05c2002,
0xe2822001,
0xaa000000,
0x00050075,
0x00060077,
0xe2470000,
0x000a0000,
0xe3e01000,
0x000a0000,
0xea000000,
0x00050047,
0x00060078,
0xe5170000,
0x000d8180,
0xe5171000,
0x000d8180,
0xe1500001,
0xab000000,
0x0005004d,
0xe1c900d0,
0xe1c920d8,
0xe35b0010,
0x3a000000,
0x00050044,
0xe3710000,
0x000a0000,
0x03730000,
0x000a0000,
0x1a000000,
0x00050044,
0xe2523001,
0xe5101000,
0x000d8180,
0x00000000,
0xba000000,
0x00050077,
0xe3510001,
0x3a000000,
0x00050077,
0x1a000000,
0x00050044,
0xe517c000,
0x000d8180,
0xe5171000,
0x000d8180,
0xe5100000,
0x000d8180,
0xe15c0002,
0x3a000000,
0x00050044,
0x0006000b,
0xe7c10003,
0xe2533001,
0xaa000000,
0x0005000b,
0xea000000,
0x00050075,
0x00060079,
0xe5170000,
0x000d8180,
0xe5171000,
0x000d8180,
0xe1500001,
0xab000000,
0x0005004d,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050044,
0xe3710000,
0x000a0000,
0x1a000000,
0x00050044,
0xe5102000,
0x000d8180,
0xe517c000,
0x000d8180,
0xe5171000,
0x000d8180,
0xe1a03002,
0xe2800000,
0x000a0000,
0xe15c0002,
0x3a000000,
0x00050044,
0x0006000b,
0x00000000,
0xe4d0c001,
0xe2533001,
0xba000000,
0x00050075,
0xe7c1c003,
0xea000000,
0x0005000b,
0x0006007a,
0xe5170000,
0x000d8180,
0xe5171000,
0x000d8180,
0xe1500001,
0xab000000,
0x0005004d,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050044,
0xe3710000,
0x000a0000,
0x1a000000,
0x00050044,
0xe5102000,
0x000d8180,
0xe517c000,
0x000d8180,
0xe5171000,
0x000d8180,
0xe3a03000,
0xe2800000,
0x000a0000,
0xe15c0002,
0x3a000000,
0x00050044,
0x0006000b,
0xe7d0c003,
0xe1530002,
0x2a000000,
0x00050075,
0xe24cb041,
0xe35b001a,
0x322cc020,
0xe7c1c003,
0xe2833001,
0xea000000,
0x0005000b,
0x0006007b,
0xe5170000,
0x000d8180,
0xe5171000,
0x000d8180,
0xe1500001,
0xab000000,
0x0005004d,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050044,
0x00000000,
0xe3710000,
0x000a0000,
0x1a000000,
0x00050044,
0xe5102000,
0x000d8180,
0xe517c000,
0x000d8180,
0xe5171000,
0x000d8180,
0xe3a03000,
0xe2800000,
0x000a0000,
0xe15c0002,
0x3a000000,
0x00050044,
0x0006000b,
0xe7d0c003,
0xe1530002,
0x2a000000,
0x00050075,
0xe24cb061,
0xe35b001a,
0x322cc020,
0xe7c1c003,
0xe2833001,
0xea000000,
0x0005000b,
0x0006007c,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050044,
0xe3710000,
0x000a0000,
0x1a000000,
0x00050044,
0x00000000,
0xe1a0a009,
0x00000000,
0xeb000000,
0x00030028,
0x00000000,
0xe1a0900a,
0x00000000,
0xe3e01000,
0x000a0000,
0xea000000,
0x00050047,
0x0006007d,
0x8a000000,
0x00050044,
0x0006007e,
0xe1a0c081,
0xe29cc980,
0x53a00000,
0x512fff1e,
0xe3e03ff8,
0xe053cacc,
0x4a000000,
0x00050001,
0xe1a03581,
0xe3833480,
0xe1833aa0,
0xe3510000,
0xe1a00c33,
0xb2600000,
0xe12fff1e,
0x0006000b,
0xe28cc015,
0xe1a03c30,
0xe26cc014,
0xe1a00601,
0xe3510000,
0xe1830c10,
0xb2600000,
0xe12fff1e,
0x0006007f,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050044,
0xe3710000,
0x000a0000,
0x1b000000,
0x0005007d,
0xe3e01000,
0x000a0000,
0xea000000,
0x00050047,
0x00060080,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050044,
0xe3710000,
0x000a0000,
0x1b000000,
0x0005007d,
0xe1a02000,
0xe3a0a008,
0x0006000b,
0xe18900da,
0xe15a000b,
0xe28aa008,
0xaa000000,
0x00050002,
0xe3710000,
0x000a0000,
0x1b000000,
0x0005007d,
0xe0022000,
0xea000000,
0x0005000b,
0x00060081,
0x00000000,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050044,
0xe3710000,
0x000a0000,
0x1b000000,
0x0005007d,
0xe1a02000,
0xe3a0a008,
0x0006000b,
0xe18900da,
0xe15a000b,
0xe28aa008,
0xaa000000,
0x00050002,
0xe3710000,
0x000a0000,
0x1b000000,
0x0005007d,
0xe1822000,
0xea000000,
0x0005000b,
0x00060082,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050044,
0xe3710000,
0x000a0000,
0x1b000000,
0x0005007d,
0xe1a02000,
0xe3a0a008,
0x0006000b,
0xe18900da,
0xe15a000b,
0xe28aa008,
0xaa000000,
0x00050002,
0xe3710000,
0x000a0000,
0x1b000000,
0x0005007d,
0xe0222000,
0xea000000,
0x0005000b,
0x0006000c,
0xe3e03000,
0x000a0000,
0xe5196004,
0xe14920f8,
0xea000000,
0x0005005a,
0x00060083,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050044,
0x00000000,
0xe3710000,
0x000a0000,
0x1b000000,
0x0005007d,
0xe0202860,
0xe3c228ff,
0xe1a00460,
0xe3e01000,
0x000a0000,
0xe0200422,
0xea000000,
0x00050047,
0x00060084,
0xe1c900d0,
0xe35b0008,
0x3a000000,
0x00050044,
0xe3710000,
0x000a0000,
0x1b000000,
0x0005007d,
0xe1e00000,
0xe3e01000,
0x000a0000,
0xea000000,
0x00050047,
0x00060085,
0xe1c900d8,
0xe35b0010,
0x3a000000,
0x00050044,
0xe3710000,
0x000a0000,
0x1b000000,
0x0005007d,
0xe200a01f,
0xe1c900d0,
0xe3710000,
0x000a0000,
0x1b000000,
0x0005007d,
0xe1a00a10,
0xe3e01000,
0x000a0000,
0xea000000,
0x00050047,
0x00060086,
0xe1c900d8,
0xe35b0010,
0x3a000000,
0x00050044,
0xe3710000,
0x000a0000,
0x1b000000,
0x0005007d,
0x00000000,
0xe200a01f,
0xe1c900d0,
0xe3710000,
0x000a0000,
0x1b000000,
0x0005007d,
0xe1a00a30,
0xe3e01000,
0x000a0000,
0xea000000,
0x00050047,
0x00060087,
0xe1c900d8,
0xe35b0010,
0x3a000000,
0x00050044,
0xe3710000,
0x000a0000,
0x1b000000,
0x0005007d,
0xe200a01f,
0xe1c900d0,
0xe3710000,
0x000a0000,
0x1b000000,
0x0005007d,
0xe1a00a50,
0xe3e01000,
0x000a0000,
0xea000000,
0x00050047,
0x00060088,
0xe1c900d8,
0xe35b0010,
0x3a000000,
0x00050044,
0xe3710000,
0x000a0000,
0x1b000000,
0x0005007d,
0xe260a000,
0xe1c900d0,
0xe3710000,
0x000a0000,
0x1b000000,
0x0005007d,
0xe1a00a70,
0xe3e01000,
0x000a0000,
0xea000000,
0x00050047,
0x00060089,
0xe1c900d8,
0xe35b0010,
0x3a000000,
0x00050044,
0x00000000,
0xe3710000,
0x000a0000,
0x1b000000,
0x0005007d,
0xe200a01f,
0xe1c900d0,
0xe3710000,
0x000a0000,
0x1b000000,
0x0005007d,
0xe1a00a70,
0xe3e01000,
0x000a0000,
0xea000000,
0x00050047,
0x00060044,
0xe5192008,
0xe5181000,
0x000d8180,
0xe089000b,
0xe5196004,
0xe5080000,
0x000d8180,
0xe5122000,
0x000d8180,
0xe5089000,
0x000d8180,
0xe2800000,
0x000a0000,
0xe58d6008,
0xe1500001,
0xe1a00008,
0x8a000000,
0x00050005,
0xe12fff32,
0xe5189000,
0x000d8180,
0xe3500000,
0xe1a0b180,
0xe249a008,
0xca000000,
0x00050045,
0x0006000b,
0xe5180000,
0x000d8180,
0xe5192008,
0xe040b009,
0x1a000000,
0x00050028,
0xe5126000,
0x000d8180,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe08aa009,
0xe12fff1c,
0x00060028,
0xe2160000,
0x000a0000,
0xe3c61000,
0x000a0000,
0x00000000,
0x0516e004,
0x00020000,
0x000412ae,
0xe049c001,
0xea000000,
0x00050024,
0x0006000f,
0xe3a01000,
0x000a0000,
0xeb000000,
0x00030000,
0xe5189000,
0x000d8180,
0xe1500000,
0xea000000,
0x0005000b,
0x0006004d,
0xe1a0a00e,
0xe5089000,
0x000d8180,
0xe089100b,
0xe58d6008,
0xe5081000,
0x000d8180,
0xe1a00008,
0xeb000000,
0x00030029,
0xe5189000,
0x000d8180,
0xe1a0e00a,
0xe5192008,
0xe12fff1e,
0x0006008a,
0x00000000,
0xe7f001f0,
0x00000000,
0x0006008b,
0xe5570000,
0x000d8180,
0xe3100000,
0x000a0000,
0x0a000000,
0x00050001,
0x0006000f,
0xe20ec0ff,
0xe087c10c,
0xe51cf000,
0x000d8180,
0x0006008c,
0xe5570000,
0x000d8180,
0xe5171000,
0x000d8180,
0xe3100000,
0x000a0000,
0x1a000000,
0x0005000f,
0xe3100000,
0x000a0000,
0x0a000000,
0x0005000f,
0xe2511001,
0xe5071000,
0x000d8180,
0x0a000000,
0x00050001,
0xe3100000,
0x000a0000,
0x0a000000,
0x0005000f,
0x0006000b,
0xe1a00008,
0xe5089000,
0x000d8180,
0xe1a01006,
0xeb000000,
0x0003002a,
0x0006000d,
0xe5189000,
0x000d8180,
0x0006000e,
0x00000000,
0xe556c004,
0xe516e004,
0xe087c10c,
0xe51cc000,
0x000d8180,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x0006008d,
0xe5130018,
0xe2866004,
0xe58d0004,
0xea000000,
0x0005000e,
0x0006008e,
0x00000000,
0xe7f001f0,
0x00000000,
0x0006008f,
0xe1a01006,
0x00000000,
0xea000000,
0x00050001,
0x00000000,
0x00060090,
0x00000000,
0xe3861001,
0x0006000b,
0x00000000,
0xe089300b,
0xe58d6008,
0xe1a00008,
0xe5089000,
0x000d8180,
0xe04aa009,
0xe5083000,
0x000d8180,
0xeb000000,
0x0003002b,
0xe5189000,
0x000d8180,
0xe5183000,
0x000d8180,
0xe3a01000,
0xe089a00a,
0xe043b009,
0xe58d1008,
0xe5192008,
0xe12fff10,
0x00060091,
0x00000000,
0xe7f001f0,
0x00000000,
0x00060092,
0x00000000,
0xe7f001f0,
0x00000000,
0x00060093,
0xe7f001f0,
0x00060094,
0xe7f001f0,
0x00000000,
0x00060095,
0xe7f001f0,
0x00000000,
0x00060095,
0x00000000,
0x00060096,
0xe92d401f,
0xeb000000,
0x0003002c,
0xeb000000,
0x0003000f,
0xe1cd20d8,
0xeb000000,
0x00030021,
0xe1cd20d0,
0xe2211480,
0xeb000000,
0x0003002d,
0xe28dd014,
0xe8bd8000,
0x00060097,
0xe210c480,
0x42600000,
0xe02cc0c1,
0xe3510000,
0x42611000,
0xe2513001,
0x11500001,
0x03a00000,
0x81110003,
0x00020000,
0x00000003,
0x9a000000,
0x00050001,
0xe16f2f10,
0xe16f3f11,
0xe0433002,
0xe273201f,
0x108ff182,
0xe1a00000,
0x00000000,
0xe1500001,
0x000900a7,
0x20400001,
0x000900a7,
0x00000000,
0x0006000b,
0xe3500000,
0x135c0000,
0x40400001,
0xe030108c,
0x42600000,
0xe12fff1e,
0x00060098,
0x00000000,
0xe7f001f0,
0x00000000,
0x00060099,
0x00000000,
0xe7f001f0,
0x00000000,
0x0006009a,
0xe59dc000,
0xe35c0001,
0x3a000000,
0x0003002d,
0x0a000000,
0x0003002e,
0xe35c0003,
0x3a000000,
0x00030021,
0x0a000000,
0x0003002c,
0xe35c0005,
0x3a000000,
0x00050096,
0x0a000000,
0x0003001e,
0xe35c0007,
0x32211480,
0x03c11480,
0x912fff1e,
0xe7f001f0,
0x0006009b,
0x00000000,
0xe92d4830,
0xe1a04000,
0xe5100000,
0x000d8180,
0xe5541000,
0x000d8180,
0xe2842000,
0x000a0000,
0xe1a0b00d,
0xe04dd000,
0xe2511001,
0xe514c000,
0x000d8180,
0x4a000000,
0x00050002,
0x0006000b,
0xe7923101,
0xe78d3101,
0xe2511001,
0x5a000000,
0x0005000b,
0x0006000c,
0xe5140000,
0x000d8180,
0xe5141000,
0x000d8180,
0xe5142000,
0x000d8180,
0xe5143000,
0x000d8180,
0xe12fff3c,
0xe1a0d00b,
0xe5040000,
0x000d8180,
0xe5041000,
0x000d8180,
0xe8bd8830,
0x00000000,
0x00080000,
0x00000000,
0xe1a0b18b,
0xe1aa00d9,
0xe1d6c0b2,
0xe1ab20d9,
0xe2866004,
0xe086c10c,
0xe3710000,
0x000a0000,
0x1a000000,
0x00050003,
0xe3730000,
0x000a0000,
0x1a000000,
0x00050004,
0xe1500002,
0x00000000,
0xb24c6b80,
0x00000000,
0xa24c6b80,
0x00000000,
0xd24c6b80,
0x00000000,
0xc24c6b80,
0x00000000,
0x0006000b,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x0006000d,
0x8a000000,
0x00050034,
0xe3730000,
0x000a0000,
0x31a0a00c,
0x3a000000,
0x00050005,
0xe1a00002,
0xe1a0b00a,
0xe1a0a00c,
0xeb000000,
0x00030025,
0xe1a02000,
0xe1a03001,
0xe1cb00d0,
0xea000000,
0x00050005,
0x0006000e,
0x8a000000,
0x00050034,
0xe1a0a00c,
0xeb000000,
0x00030025,
0xe1cb20d0,
0x0006000f,
0xeb000000,
0x00030026,
0x00000000,
0x324a6b80,
0x00000000,
0x224a6b80,
0x00000000,
0x924a6b80,
0x00000000,
0x824a6b80,
0x00000000,
0xea000000,
0x0005000b,
0x00000000,
0xe1a0b18b,
0xe1aa00d9,
0xe1d6c0b2,
0xe1ab20d9,
0xe2866004,
0xe086c10c,
0xe3710000,
0x000a0000,
0x93730000,
0x000a0000,
0x00000000,
0x9a000000,
0x0005009c,
0x00000000,
0x9a000000,
0x0005009d,
0x00000000,
0xe3710000,
0x000a0000,
0x13730000,
0x000a0000,
0x0a000000,
0x0005003a,
0x00000000,
0xe1510003,
0x1a000000,
0x00050002,
0xe3710000,
0x000a0000,
0x2a000000,
0x00050001,
0xe1500002,
0x00000000,
0x1a000000,
0x00050003,
0x0006000b,
0xe24c6b80,
0x0006000c,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x0006000d,
0xe3710000,
0x000a0000,
0x8a000000,
0x0005000c,
0x00000000,
0x0a000000,
0x00050001,
0xe3710000,
0x000a0000,
0x8a000000,
0x00050002,
0x00000000,
0xe510a000,
0x000d8180,
0xe35a0000,
0x00000000,
0x0a000000,
0x0005000c,
0x00000000,
0x0a000000,
0x00050002,
0x00000000,
0xe55aa000,
0x000d8180,
0xe3a03000,
0x000a0000,
0xe1a01000,
0xe31a0000,
0x000a0000,
0x0a000000,
0x00050039,
0x00000000,
0x0006000c,
0xe24c6b80,
0x0006000b,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0xe1e0b00b,
0xe18900da,
0xe1d6c0b2,
0xe795210b,
0xe2866004,
0xe086c10c,
0xe3710000,
0x000a0000,
0x00000000,
0x1a000000,
0x00050007,
0xe1500002,
0x00000000,
0x01500002,
0x00000000,
0x024c6b80,
0x0006000b,
0x00000000,
0x0006000b,
0x124c6b80,
0x00000000,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0x00060011,
0xe3710000,
0x000a0000,
0x1a000000,
0x0005000b,
0xea000000,
0x0005003a,
0x00000000,
0xe1a0b18b,
0xe1aa00d9,
0xe1d6c0b2,
0xe1ab20d5,
0xe2866004,
0xe086c10c,
0x00000000,
0x0006009c,
0x00000000,
0x0006009d,
0x00000000,
0xe3710000,
0x000a0000,
0x1a000000,
0x00050003,
0xe3730000,
0x000a0000,
0x1a000000,
0x00050004,
0xe1500002,
0x00000000,
0x024c6b80,
0x0006000b,
0x00000000,
0x0006000b,
0x124c6b80,
0x00000000,
0x0006000c,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x0006000d,
0x00000000,
0x8a000000,
0x00050007,
0x00000000,
0x824c6b80,
0x00000000,
0x8a000000,
0x0005000c,
0x00000000,
0xe3730000,
0x000a0000,
0x31a0a00c,
0x3a000000,
0x00050005,
0xe1a00002,
0xe1a0b00a,
0x0006000e,
0xe1a0a00c,
0xeb000000,
0x00030025,
0xe1cb20d0,
0x0006000f,
0xeb000000,
0x0003002f,
0x00000000,
0x024a6b80,
0x00000000,
0x124a6b80,
0x00000000,
0xea000000,
0x0005000c,
0x00000000,
0x00060011,
0xe3710000,
0x000a0000,
0x1a000000,
0x0005000b,
0xea000000,
0x0005003a,
0x00000000,
0xe18900da,
0xe1d6c0b2,
0xe2866004,
0xe1e0b00b,
0xe086c10c,
0x00000000,
0xe3710000,
0x000a0000,
0x0a000000,
0x0005003a,
0x00000000,
0xe151000b,
0x00000000,
0x024c6b80,
0x00000000,
0x124c6b80,
0x00000000,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0xe089b18b,
0xe1d6c0b2,
0xe1cb00d0,
0xe2866004,
0xe086c10c,
0xe3710000,
0x000a0000,
0x00000000,
0x924c6b80,
0x00000000,
0x918900fa,
0x00000000,
0x824c6b80,
0x00000000,
0x818900fa,
0x00000000,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0xe1a0b18b,
0xe5d6c000,
0xe18900db,
0xe496e004,
0xe18900fa,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0xe089b18b,
0xe5d6c000,
0xe59b0004,
0xe089a00a,
0xe496e004,
0xe3700000,
0x000a0000,
0x93e01000,
0x000a0000,
0x83e01000,
0x000a0000,
0xe58a1004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0xe1a0b18b,
0xe18900db,
0xe5d6c000,
0xe496e004,
0xe3710000,
0x000a0000,
0x8a000000,
0x0005003d,
0x12211480,
0x1a000000,
0x00050005,
0x02700000,
0x614f00d0,
0x00051809,
0x0006000f,
0xe18900fa,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00040007,
0x00060013,
0x00020000,
0x00000000,
0x41e00000,
0x00000000,
0xe1a0b18b,
0xe18900db,
0xe3710000,
0x000a0000,
0x1a000000,
0x00050002,
0xe5100000,
0x000d8180,
0x0006000b,
0xe3e01000,
0x000a0000,
0xe5d6c000,
0xe496e004,
0xe18900fa,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x0006000c,
0xe3710000,
0x000a0000,
0x1a000000,
0x0005003f,
0x00000000,
0xe1a0b009,
0x00000000,
0xeb000000,
0x00030028,
0x00000000,
0xe1a0900b,
0x00000000,
0xea000000,
0x0005000b,
0x00000000,
0xe004caae,
0xe004b6ae,
0x00000000,
0xe18900dc,
0xe18520db,
0x00000000,
0xe18920dc,
0xe18500db,
0x00000000,
0xe18900dc,
0xe18920db,
0x00000000,
0xe5d6c000,
0x00000000,
0xe3730000,
0x000a0000,
0x03710000,
0x000a0000,
0x00000000,
0xe3710000,
0x000a0000,
0x03730000,
0x000a0000,
0x00000000,
0x1a000000,
0x00050005,
0xe0900002,
0x00000000,
0x6a000000,
0x0005003b,
0x00000000,
0x6a000000,
0x0005003c,
0x00000000,
0x6a000000,
0x0005003e,
0x00000000,
0x0006000e,
0xe496e004,
0xe18900fa,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x0006000f,
0x00000000,
0xe3730000,
0x000a0000,
0x33710000,
0x000a0000,
0x00000000,
0xe3710000,
0x000a0000,
0x33730000,
0x000a0000,
0x00000000,
0x2a000000,
0x0005003b,
0x00000000,
0xe3730000,
0x000a0000,
0x33710000,
0x000a0000,
0x00000000,
0xe3710000,
0x000a0000,
0x33730000,
0x000a0000,
0x00000000,
0x2a000000,
0x0005003c,
0x00000000,
0xe3730000,
0x000a0000,
0x33710000,
0x000a0000,
0x00000000,
0xe3710000,
0x000a0000,
0x33730000,
0x000a0000,
0x00000000,
0x2a000000,
0x0005003e,
0x00000000,
0xeb000000,
0x0003002d,
0xe5d6c000,
0xea000000,
0x0005000e,
0x00000000,
0xe004caae,
0xe004b6ae,
0x00000000,
0xe18900dc,
0xe18520db,
0x00000000,
0xe18920dc,
0xe18500db,
0x00000000,
0xe18900dc,
0xe18920db,
0x00000000,
0xe5d6c000,
0x00000000,
0xe3730000,
0x000a0000,
0x03710000,
0x000a0000,
0x00000000,
0xe3710000,
0x000a0000,
0x03730000,
0x000a0000,
0x00000000,
0x1a000000,
0x00050005,
0xe0500002,
0x00000000,
0x6a000000,
0x0005003b,
0x00000000,
0x6a000000,
0x0005003c,
0x00000000,
0x6a000000,
0x0005003e,
0x00000000,
0x0006000e,
0xe496e004,
0xe18900fa,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x0006000f,
0x00000000,
0xe3730000,
0x000a0000,
0x33710000,
0x000a0000,
0x00000000,
0xe3710000,
0x000a0000,
0x33730000,
0x000a0000,
0x00000000,
0x2a000000,
0x0005003b,
0x00000000,
0xe3730000,
0x000a0000,
0x33710000,
0x000a0000,
0x00000000,
0xe3710000,
0x000a0000,
0x33730000,
0x000a0000,
0x00000000,
0x2a000000,
0x0005003c,
0x00000000,
0xe3730000,
0x000a0000,
0x33710000,
0x000a0000,
0x00000000,
0xe3710000,
0x000a0000,
0x33730000,
0x000a0000,
0x00000000,
0x2a000000,
0x0005003e,
0x00000000,
0xeb000000,
0x0003002e,
0xe5d6c000,
0xea000000,
0x0005000e,
0x00000000,
0xe004caae,
0xe004b6ae,
0x00000000,
0xe18900dc,
0xe18520db,
0x00000000,
0xe18920dc,
0xe18500db,
0x00000000,
0xe18900dc,
0xe18920db,
0x00000000,
0xe5d6c000,
0x00000000,
0xe3730000,
0x000a0000,
0x03710000,
0x000a0000,
0x00000000,
0xe3710000,
0x000a0000,
0x03730000,
0x000a0000,
0x00000000,
0x1a000000,
0x00050005,
0xe0cb0092,
0xe15b0fc0,
0x00000000,
0x1a000000,
0x0005003b,
0x00000000,
0x1a000000,
0x0005003c,
0x00000000,
0x1a000000,
0x0005003e,
0x00000000,
0x0006000e,
0xe496e004,
0xe18900fa,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x0006000f,
0x00000000,
0xe3730000,
0x000a0000,
0x33710000,
0x000a0000,
0x00000000,
0xe3710000,
0x000a0000,
0x33730000,
0x000a0000,
0x00000000,
0x2a000000,
0x0005003b,
0x00000000,
0xe3730000,
0x000a0000,
0x33710000,
0x000a0000,
0x00000000,
0xe3710000,
0x000a0000,
0x33730000,
0x000a0000,
0x00000000,
0x2a000000,
0x0005003c,
0x00000000,
0xe3730000,
0x000a0000,
0x33710000,
0x000a0000,
0x00000000,
0xe3710000,
0x000a0000,
0x33730000,
0x000a0000,
0x00000000,
0x2a000000,
0x0005003e,
0x00000000,
0xeb000000,
0x00030021,
0xe5d6c000,
0xea000000,
0x0005000e,
0x00000000,
0xe004caae,
0xe004b6ae,
0x00000000,
0xe18900dc,
0xe18520db,
0x00000000,
0xe18920dc,
0xe18500db,
0x00000000,
0xe18900dc,
0xe18920db,
0x00000000,
0xe3730000,
0x000a0000,
0x33710000,
0x000a0000,
0x00000000,
0xe3710000,
0x000a0000,
0x33730000,
0x000a0000,
0x00000000,
0x2a000000,
0x0005003b,
0x00000000,
0xe3730000,
0x000a0000,
0x33710000,
0x000a0000,
0x00000000,
0xe3710000,
0x000a0000,
0x33730000,
0x000a0000,
0x00000000,
0x2a000000,
0x0005003c,
0x00000000,
0xe3730000,
0x000a0000,
0x33710000,
0x000a0000,
0x00000000,
0xe3710000,
0x000a0000,
0x33730000,
0x000a0000,
0x00000000,
0x2a000000,
0x0005003e,
0x00000000,
0xeb000000,
0x0003002c,
0xe5d6c000,
0xe496e004,
0xe18900fa,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0xe004caae,
0xe004b6ae,
0x00000000,
0xe18900dc,
0xe18520db,
0x00000000,
0xe18920dc,
0xe18500db,
0x00000000,
0xe18900dc,
0xe18920db,
0x00000000,
0xe3730000,
0x000a0000,
0x03710000,
0x000a0000,
0x00000000,
0xe3710000,
0x000a0000,
0x03730000,
0x000a0000,
0x00000000,
0x1a000000,
0x00050005,
0xe1b01002,
0x00000000,
0x0a000000,
0x0005003b,
0x00000000,
0x0a000000,
0x0005003c,
0x00000000,
0x0a000000,
0x0005003e,
0x00000000,
0xeb000000,
0x00050097,
0xe3e01000,
0x000a0000,
0x0006000e,
0xe5d6c000,
0xe496e004,
0xe18900fa,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x0006000f,
0x00000000,
0xe3730000,
0x000a0000,
0x33710000,
0x000a0000,
0x00000000,
0xe3710000,
0x000a0000,
0x33730000,
0x000a0000,
0x00000000,
0x2a000000,
0x0005003b,
0x00000000,
0xe3730000,
0x000a0000,
0x33710000,
0x000a0000,
0x00000000,
0xe3710000,
0x000a0000,
0x33730000,
0x000a0000,
0x00000000,
0x2a000000,
0x0005003c,
0x00000000,
0xe3730000,
0x000a0000,
0x33710000,
0x000a0000,
0x00000000,
0xe3710000,
0x000a0000,
0x33730000,
0x000a0000,
0x00000000,
0x2a000000,
0x0005003e,
0x00000000,
0xe1a0b009,
0x00000000,
0xeb000000,
0x00050096,
0x00000000,
0xe1a0900b,
0x00000000,
0xea000000,
0x0005000e,
0x00000000,
0xe004caae,
0xe004b6ae,
0x00000000,
0xe18900dc,
0xe18520db,
0x00000000,
0xe18920dc,
0xe18500db,
0x00000000,
0xe18900dc,
0xe18920db,
0x00000000,
0xe3730000,
0x000a0000,
0x33710000,
0x000a0000,
0x00000000,
0xe3710000,
0x000a0000,
0x33730000,
0x000a0000,
0x00000000,
0x2a000000,
0x0005003b,
0x00000000,
0xe3730000,
0x000a0000,
0x33710000,
0x000a0000,
0x00000000,
0xe3710000,
0x000a0000,
0x33730000,
0x000a0000,
0x00000000,
0x2a000000,
0x0005003c,
0x00000000,
0xe3730000,
0x000a0000,
0x33710000,
0x000a0000,
0x00000000,
0xe3710000,
0x000a0000,
0x33730000,
0x000a0000,
0x00000000,
0x2a000000,
0x0005003e,
0x00000000,
0xe1a0b009,
0x00000000,
0xeb000000,
0x0003001e,
0x00000000,
0xe1a0900b,
0x00000000,
0xe5d6c000,
0xe496e004,
0xe18900fa,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0xe004baae,
0xe004c6ae,
0xe04c200b,
0xe5089000,
0x000d8180,
0xe089100c,
0x0006002a,
0xe1a00008,
0xe58d6008,
0xe1a021a2,
0xeb000000,
0x00030030,
0xe5189000,
0x000d8180,
0xe3500000,
0x1a000000,
0x00050035,
0xe18920db,
0xe5d6c000,
0xe496e004,
0xe18920fa,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0xe1e0b00b,
0xe5d6c000,
0xe795010b,
0xe3e01000,
0x000a0000,
0xe496e004,
0xe18900fa,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0xe1e0b00b,
0xe5d6c000,
0xe795010b,
0xe3e01000,
0x000a0000,
0xe496e004,
0xe18900fa,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0xe1a0084e,
0xe3e01000,
0x000a0000,
0xe5d6c000,
0xe496e004,
0xe18900fa,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0xe1a0b18b,
0xe5d6c000,
0xe18500db,
0xe496e004,
0xe18900fa,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0xe089a00a,
0xe1e0b00b,
0xe5d6c000,
0xe496e004,
0xe58ab004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0xe089a00a,
0xe089b18b,
0xe3e00000,
0x000a0000,
0xe58a0004,
0xe28aa008,
0x0006000b,
0xe58a0004,
0xe15a000b,
0xe28aa008,
0xba000000,
0x0005000b,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0xe5191008,
0xe1a0b10b,
0xe28bb000,
0x000a0000,
0xe791100b,
0xe5111000,
0x000d8180,
0xe1c120d0,
0xe5d6c000,
0xe496e004,
0xe18920fa,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0xe5191008,
0xe1a0a0aa,
0xe28aa000,
0x000a0000,
0xe1a0b18b,
0xe791100a,
0xe18920db,
0xe551c000,
0x000d8180,
0xe551b000,
0x000d8180,
0xe5111000,
0x000d8180,
0xe31c0000,
0x000a0000,
0xe283c000,
0x000a0000,
0x135b0000,
0xe1c120f0,
0x1a000000,
0x00050002,
0x0006000b,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x0006000c,
0xe37c0000,
0x000a0000,
0x8552b000,
0x000d8180,
0x9a000000,
0x0005000b,
0xe2470000,
0x000a0000,
0xe31b0000,
0x000a0000,
0x00000000,
0x0a000000,
0x0005000b,
0xe1a0b009,
0xeb000000,
0x00030031,
0xe1a0900b,
0x00000000,
0x1b000000,
0x00030031,
0x00000000,
0xea000000,
0x0005000b,
0x00000000,
0xe5191008,
0xe1a0a0aa,
0xe28aa000,
0x000a0000,
0xe1e0b00b,
0xe791100a,
0xe795210b,
0xe3e03000,
0x000a0000,
0xe551c000,
0x000d8180,
0xe5111000,
0x000d8180,
0xe551b000,
0x000d8180,
0xe31c0000,
0x000a0000,
0xe552c000,
0x000d8180,
0xe1c120f0,
0x1a000000,
0x00050002,
0x0006000b,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x0006000c,
0xe31c0000,
0x000a0000,
0x135b0000,
0xe2470000,
0x000a0000,
0x00000000,
0x0a000000,
0x0005000b,
0xe1a0b009,
0xeb000000,
0x00030031,
0xe1a0900b,
0x00000000,
0x1b000000,
0x00030031,
0x00000000,
0xea000000,
0x0005000b,
0x00000000,
0xe5191008,
0xe1a0a0aa,
0xe28aa000,
0x000a0000,
0xe1a0b18b,
0xe791100a,
0xe18520db,
0xe5111000,
0x000d8180,
0xe5d6c000,
0xe496e004,
0xe1c120f0,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0xe5191008,
0xe1a0a0aa,
0xe28aa000,
0x000a0000,
0xe791100a,
0xe1e0b00b,
0xe5111000,
0x000d8180,
0xe5d6c000,
0xe496e004,
0xe581b004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0xe5182000,
0x000d8180,
0xe086b10b,
0xe5089000,
0x000d8180,
0xe3520000,
0xe24b6b80,
0x0a000000,
0x00050001,
0xe1a00008,
0xe089100a,
0xeb000000,
0x00030032,
0xe5189000,
0x000d8180,
0x0006000b,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0xe1e0b00b,
0xe5089000,
0x000d8180,
0xe795110b,
0xe58d6008,
0xe5192008,
0xe1a00008,
0xeb000000,
0x00030033,
0xe5189000,
0x000d8180,
0xe3e01000,
0x000a0000,
0xe5d6c000,
0xe496e004,
0xe18900fa,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0xe1e0b00b,
0x00000000,
0xe5172000,
0x000d8180,
0xe5173000,
0x000d8180,
0xe5089000,
0x000d8180,
0xe58d6008,
0xe1520003,
0xe1a00008,
0x2a000000,
0x00050005,
0x0006000b,
0x00000000,
0xe1a01a8b,
0xe1a025ab,
0xe1a0bac1,
0xe1a01aa1,
0xe37b0001,
0x02811002,
0xeb000000,
0x00030034,
0x00000000,
0xe795110b,
0xeb000000,
0x00030035,
0x00000000,
0xe5189000,
0x000d8180,
0xe3e01000,
0x000a0000,
0xe5d6c000,
0xe496e004,
0xe18900fa,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x0006000f,
0xeb000000,
0x00030036,
0xe1a00008,
0xea000000,
0x0005000b,
0x00000000,
0xe5191008,
0xe1e0b00b,
0xe5110000,
0x000d8180,
0xe795b10b,
0x00000000,
0xea000000,
0x0005009e,
0x00000000,
0xea000000,
0x0005009f,
0x00000000,
0xe004caae,
0xe004b6ae,
0xe18900dc,
0xe18920db,
0xe3710000,
0x000a0000,
0x1a000000,
0x0005002f,
0xe3730000,
0x000a0000,
0x05103000,
0x000d8180,
0x05101000,
0x000d8180,
0x1a000000,
0x00050009,
0xe0833182,
0xe1520001,
0x31c320d0,
0x2a000000,
0x0005002f,
0xe5d6c000,
0xe3730000,
0x000a0000,
0x0a000000,
0x00050005,
0x0006000b,
0xe496e004,
0xe18920fa,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x0006000f,
0xe5101000,
0x000d8180,
0xe3510000,
0x0a000000,
0x0005000b,
0xe5511000,
0x000d8180,
0xe3110000,
0x000a0000,
0x1a000000,
0x0005000b,
0xe004caae,
0xea000000,
0x0005002f,
0x00060013,
0xe3730000,
0x000a0000,
0x01a0b002,
0x0a000000,
0x0005009e,
0xea000000,
0x0005002f,
0x00000000,
0xe004caae,
0xe20bb0ff,
0xe18900dc,
0xe1e0b00b,
0xe795b10b,
0xe3710000,
0x000a0000,
0x1a000000,
0x0005002c,
0x0006009e,
0xe5102000,
0x000d8180,
0xe51b3000,
0x000d8180,
0xe510e000,
0x000d8180,
0xe1a0c000,
0xe0022003,
0xe0822082,
0xe08ee182,
0x0006000b,
0xe14e00d0,
0x000c8100,
0xe14e20d0,
0x000c8100,
0xe51ee000,
0x000d8180,
0xe150000b,
0x03710000,
0x000a0000,
0x1a000000,
0x00050004,
0xe3730000,
0x000a0000,
0x0a000000,
0x00050005,
0x0006000d,
0xe5d6c000,
0xe496e004,
0xe18920fa,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x0006000e,
0xe35e0000,
0x1a000000,
0x0005000b,
0x0006000f,
0xe51c0000,
0x000d8180,
0xe3a02000,
0xe3e03000,
0x000a0000,
0xe3500000,
0x0a000000,
0x0005000d,
0xe5501000,
0x000d8180,
0x00000000,
0xe3110000,
0x000a0000,
0x1a000000,
0x0005000d,
0xea000000,
0x0005002d,
0x00000000,
0xe004caae,
0xe20bb0ff,
0xe18900dc,
0xe3710000,
0x000a0000,
0x1a000000,
0x0005002e,
0xe5102000,
0x000d8180,
0xe5103000,
0x000d8180,
0xe1a0118b,
0xe15b0002,
0x318320d1,
0x2a000000,
0x0005002e,
0xe5d6c000,
0xe3730000,
0x000a0000,
0x0a000000,
0x00050005,
0x0006000b,
0xe496e004,
0xe18920fa,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x0006000f,
0xe5101000,
0x000d8180,
0xe3510000,
0x0a000000,
0x0005000b,
0xe5511000,
0x000d8180,
0xe3110000,
0x000a0000,
0x1a000000,
0x0005000b,
0xea000000,
0x0005002e,
0x00000000,
0xe004caae,
0xe004b6ae,
0xe18900dc,
0xe18920db,
0xe3710000,
0x000a0000,
0x1a000000,
0x00050033,
0xe3730000,
0x000a0000,
0x05101000,
0x000d8180,
0x05103000,
0x000d8180,
0x1a000000,
0x00050009,
0xe0811182,
0xe1520003,
0x3591e004,
0x2a000000,
0x00050033,
0xe5d6c000,
0xe37e0000,
0x000a0000,
0xe550e000,
0x000d8180,
0xe18920da,
0x0a000000,
0x00050005,
0x0006000b,
0xe31e0000,
0x000a0000,
0xe1c120f0,
0x1a000000,
0x00050007,
0x0006000c,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x0006000f,
0xe510a000,
0x000d8180,
0xe35a0000,
0x0a000000,
0x0005000b,
0xe55aa000,
0x000d8180,
0xe31a0000,
0x000a0000,
0x1a000000,
0x0005000b,
0xe516e004,
0xe004caae,
0xe004a2ae,
0xea000000,
0x00050033,
0x00060011,
0x00000000,
0xe5172000,
0x000d8180,
0xe3cee000,
0x000a0000,
0xe5070000,
0x000d8180,
0xe540e000,
0x000d8180,
0xe5002000,
0x000d8180,
0xea000000,
0x0005000c,
0x00060013,
0xe3730000,
0x000a0000,
0x01a0b002,
0x0a000000,
0x0005009f,
0xea000000,
0x00050033,
0x00000000,
0xe004caae,
0xe20bb0ff,
0xe18900dc,
0xe1e0b00b,
0xe795b10b,
0xe3710000,
0x000a0000,
0x1a000000,
0x00050030,
0x0006009f,
0xe5102000,
0x000d8180,
0xe51b3000,
0x000d8180,
0xe510e000,
0x000d8180,
0xe1a0c000,
0xe0022003,
0xe0822082,
0xe3a03000,
0xe08ee182,
0xe54c3000,
0x000d8180,
0x0006000b,
0xe14e00d0,
0x000c8100,
0xe51e3000,
0x000d8180,
0xe51e2000,
0x000d8180,
0xe150000b,
0x03710000,
0x000a0000,
0x1a000000,
0x00050005,
0xe55c1000,
0x000d8180,
0xe3730000,
0x000a0000,
0xe18920da,
0x0a000000,
0x00050004,
0x0006000c,
0xe3110000,
0x000a0000,
0xe14e20f0,
0x000c8100,
0x1a000000,
0x00050007,
0x0006000d,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x0006000e,
0x00000000,
0xe51c0000,
0x000d8180,
0xe3500000,
0x0a000000,
0x0005000c,
0xe5500000,
0x000d8180,
0xe3100000,
0x000a0000,
0x1a000000,
0x0005000c,
0xea000000,
0x00050031,
0x0006000f,
0xe1b0e002,
0x1a000000,
0x0005000b,
0xe51c0000,
0x000d8180,
0xe1a0200d,
0xe58d6008,
0xe3500000,
0xe5089000,
0x000d8180,
0x15501000,
0x000d8180,
0xe1a00008,
0x0a000000,
0x00050006,
0xe3110000,
0x000a0000,
0x0a000000,
0x00050031,
0x00060010,
0xe3e03000,
0x000a0000,
0xe58db000,
0xe1a0100c,
0xe58d3004,
0xeb000000,
0x00030037,
0xe5189000,
0x000d8180,
0xe18920da,
0xe1c020f0,
0xea000000,
0x0005000d,
0x00060011,
0xe5172000,
0x000d8180,
0xe3c11000,
0x000a0000,
0x00000000,
0xe507c000,
0x000d8180,
0xe54c1000,
0x000d8180,
0xe50c2000,
0x000d8180,
0xea000000,
0x0005000d,
0x00000000,
0xe004caae,
0xe20bb0ff,
0xe18900dc,
0xe3710000,
0x000a0000,
0x1a000000,
0x00050032,
0xe5102000,
0x000d8180,
0xe510c000,
0x000d8180,
0xe1a0118b,
0xe15b0002,
0x31a120dc,
0x2a000000,
0x00050032,
0xe5d6c000,
0xe3730000,
0x000a0000,
0xe550e000,
0x000d8180,
0xe18920da,
0x0a000000,
0x00050005,
0x0006000b,
0xe31e0000,
0x000a0000,
0xe1c120f0,
0x1a000000,
0x00050007,
0x0006000c,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x0006000f,
0xe510a000,
0x000d8180,
0xe35a0000,
0x0a000000,
0x0005000b,
0xe55aa000,
0x000d8180,
0xe31a0000,
0x000a0000,
0x1a000000,
0x0005000b,
0xe516e004,
0xea000000,
0x00050032,
0x00060011,
0xe5172000,
0x000d8180,
0xe3cee000,
0x000a0000,
0x00000000,
0xe5070000,
0x000d8180,
0xe540e000,
0x000d8180,
0xe5002000,
0x000d8180,
0xea000000,
0x0005000c,
0x00000000,
0xe089a00a,
0x0006000b,
0xe59dc004,
0xe51a1008,
0xe795018b,
0xe25cc008,
0xe5113000,
0x000d8180,
0x0a000000,
0x00050004,
0xe08021ac,
0xe1520003,
0xe5113000,
0x000d8180,
0xe08ac00c,
0x8a000000,
0x00050005,
0xe083e180,
0xe5510000,
0x000d8180,
0x0006000d,
0xe0ca20d8,
0xe0ce20f8,
0xe15a000c,
0x3a000000,
0x0005000d,
0xe3100000,
0x000a0000,
0x1a000000,
0x00050007,
0x0006000e,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x0006000f,
0xe5089000,
0x000d8180,
0xe1a00008,
0xe58d6008,
0xeb000000,
0x00030038,
0x00000000,
0xe5189000,
0x000d8180,
0x00000000,
0xea000000,
0x0005000b,
0x00060011,
0xe5171000,
0x000d8180,
0xe3c00000,
0x000a0000,
0xe507c000,
0x000d8180,
0xe54c0000,
0x000d8180,
0xe50c1000,
0x000d8180,
0xea000000,
0x0005000e,
0x00000000,
0xe59d0004,
0xe004b6ae,
0xe08bb000,
0xea000000,
0x000500a0,
0x00000000,
0xe004b6ae,
0x000600a0,
0xe1a0c009,
0xe1a920da,
0xe24bb008,
0xe2899008,
0xe3730000,
0x000a0000,
0x1a000000,
0x00050025,
0xe5096004,
0xe5126000,
0x000d8180,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe08aa009,
0xe12fff1c,
0x00000000,
0xe59d0004,
0xe080b18b,
0xea000000,
0x000500a1,
0x00000000,
0xe1a0b18b,
0x000600a1,
0xe1aa20d9,
0xe24bb008,
0xe28aa008,
0xe3730000,
0x000a0000,
0x1a000000,
0x00050040,
0xe5196004,
0x00060041,
0xe3a0c000,
0xe5523000,
0x000d8180,
0xe3160000,
0x000a0000,
0x1a000000,
0x00050007,
0x0006000b,
0xe5092008,
0xe35b0000,
0x0a000000,
0x00050003,
0x0006000c,
0xe18a00dc,
0xe28ce008,
0xe15e000b,
0xe18900fc,
0xe1a0c00e,
0x1a000000,
0x0005000c,
0x0006000d,
0xe3530001,
0x8a000000,
0x00050005,
0x0006000e,
0xe5126000,
0x000d8180,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe08aa009,
0xe12fff1c,
0x0006000f,
0xe516e004,
0xe004a2ae,
0xe049000a,
0xe5100010,
0xe5100000,
0x000d8180,
0xe5105000,
0x000d8180,
0xea000000,
0x0005000e,
0x00060011,
0xe2266000,
0x000a0000,
0xe3160000,
0x000a0000,
0x00000000,
0x13a03000,
0x1a000000,
0x0005000b,
0xe0499006,
0xe5196004,
0xe3160000,
0x000a0000,
0x13a03000,
0xea000000,
0x0005000b,
0x00000000,
0xe089a00a,
0xe1a0c009,
0xe14a21d0,
0xe14a00d8,
0xe28a9008,
0xe1ca20f8,
0xe1ca01f0,
0xe14a21d8,
0xe3a0b010,
0xe1ca20f0,
0xe3730000,
0x000a0000,
0x1a000000,
0x00050025,
0xe5096004,
0xe5126000,
0x000d8180,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe08aa009,
0xe12fff1c,
0x00000000,
0xe089a00a,
0xe51ac010,
0xe51a0008,
0xe51ce000,
0x000d8180,
0xe51c1000,
0x000d8180,
0xe2866004,
0x0006000b,
0xe050b00e,
0xe0812180,
0x2a000000,
0x00050005,
0xe1c220d0,
0xe3730000,
0x000a0000,
0x02800001,
0x0a000000,
0x0005000b,
0xe156b0b2,
0xe3e01000,
0x000a0000,
0xe1ca20f8,
0xe086b10b,
0xe280c001,
0xe1ca00f0,
0xe24b6b80,
0xe50ac008,
0x0006000d,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x0006000f,
0xe51c3000,
0x000d8180,
0xe51cc000,
0x000d8180,
0x00060010,
0xe08b008b,
0xe15b0003,
0xe08c2180,
0x8a000000,
0x0005000d,
0xe14200d0,
0x000c8100,
0xe3710000,
0x000a0000,
0xe28bb001,
0x0a000000,
0x00050010,
0xe156c0b2,
0xe08bb00e,
0xe14220d0,
0x000c8100,
0xe50ab008,
0xe1ca00f8,
0xe086b10c,
0xe24b6b80,
0xe1ca20f0,
0xea000000,
0x0005000d,
0x00000000,
0xe089a00a,
0xe086b10b,
0xe14a01d8,
0xe51a200c,
0xe51a3004,
0xe3710000,
0x000a0000,
0x05500000,
0x000d8180,
0x03720000,
0x000a0000,
0x03730000,
0x000a0000,
0x03500000,
0x000a0000,
0x024b6b80,
0x1a000000,
0x00050005,
0xe5d6c000,
0xe496e004,
0xe3a00000,
0xe50a0008,
0x0006000b,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x0006000f,
0xe3a00000,
0x000a0000,
0xe3a0c000,
0x000a0000,
0xe5460004,
0xe24b6b80,
0xe5c6c000,
0xe496e004,
0xea000000,
0x0005000b,
0x00000000,
0xe004caae,
0xe004b6ae,
0xe5190004,
0xe089b00b,
0xe089a00a,
0xe28bb000,
0x000a0000,
0xe08a300c,
0xe2492008,
0xe04bb000,
0xe35c0000,
0xe042000b,
0x0a000000,
0x00050005,
0xe2433010,
0x0006000b,
0xe15b0002,
0x30cb00d8,
0x23e01000,
0x000a0000,
0xe15a0003,
0xe0ca00f8,
0x3a000000,
0x0005000b,
0x0006000c,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x0006000f,
0xe5183000,
0x000d8180,
0xe3500000,
0xd3a0c008,
0xc280c008,
0xe08a1000,
0xe58dc004,
0xda000000,
0x0005000c,
0xe1510003,
0x8a000000,
0x00050007,
0x00060010,
0xe0cb00d8,
0xe0ca00f8,
0xe15b0002,
0x3a000000,
0x00050010,
0xea000000,
0x0005000c,
0x00060011,
0xe1a011a0,
0xe508a000,
0x000d8180,
0xe1a00008,
0xe5089000,
0x000d8180,
0xe04bb009,
0xe58d6008,
0xe04aa009,
0xeb000000,
0x00030000,
0xe5189000,
0x000d8180,
0xe089a00a,
0xe089b00b,
0xe2492008,
0xea000000,
0x00050010,
0x00000000,
0xe59d0004,
0xe5196004,
0xe089a00a,
0xe080b18b,
0xea000000,
0x000500a2,
0x00000000,
0xe5196004,
0xe1a0b18b,
0xe089a00a,
0x000600a2,
0xe58db004,
0x0006000b,
0xe2160000,
0x000a0000,
0xe2261000,
0x000a0000,
0x1a000000,
0x000500a3,
0x00060017,
0xe516e004,
0xe25b3008,
0xe2492008,
0x0a000000,
0x00050003,
0x0006000c,
0xe0ca00d8,
0xe2899008,
0xe2533008,
0xe14901f0,
0x1a000000,
0x0005000c,
0x0006000d,
0xe004a2ae,
0xe042300a,
0xe004caae,
0xe5130008,
0x0006000f,
0xe15c000b,
0x8a000000,
0x00050006,
0xe1a09003,
0xe5101000,
0x000d8180,
0xe5d6c000,
0xe496e004,
0xe5115000,
0x000d8180,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00060010,
0xe3e01000,
0x000a0000,
0xe2899008,
0xe28bb008,
0xe509100c,
0xea000000,
0x0005000f,
0x000600a4,
0xe089a00a,
0x000600a3,
0xe3110000,
0x000a0000,
0x1a000000,
0x00050018,
0xe0499001,
0xe5196004,
0xea000000,
0x0005000b,
0x00000000,
0xe5196004,
0xe1a0b18b,
0xe58db004,
0xe2160000,
0x000a0000,
0xe2261000,
0x000a0000,
0x0516e004,
0x1a000000,
0x000500a4,
0x00000000,
0xe18900da,
0x00000000,
0xe2493008,
0xe004a2ae,
0x00000000,
0xe1c300f0,
0x00000000,
0xe043900a,
0xe004caae,
0xe5190008,
0x0006000f,
0xe15c000b,
0x8a000000,
0x00050006,
0xe5101000,
0x000d8180,
0xe5d6c000,
0xe496e004,
0xe5115000,
0x000d8180,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00060010,
0xe2431004,
0xe3e02000,
0x000a0000,
0xe781200b,
0xe28bb008,
0xea000000,
0x0005000f,
0x00000000,
0xe7f001f0,
0x00000000,
0xe1aa00d9,
0xe086b10b,
0x00000000,
0xe1ca20d8,
0xe3710000,
0x000a0000,
0xe59ac014,
0x1a000000,
0x00050005,
0xe3730000,
0x000a0000,
0xe59a3010,
0x037c0000,
0x000a0000,
0x1a000000,
0x00050042,
0xe3530000,
0xba000000,
0x00050004,
0xe1500002,
0x00000000,
0xe1ca21d0,
0xe3710000,
0x000a0000,
0x1a000000,
0x00050005,
0xe0900002,
0xe59a3008,
0x00000000,
0x6286bb80,
0x00000000,
0xe7f001f0,
0x00000000,
0xe3520000,
0xba000000,
0x00050004,
0xe1500003,
0x00000000,
0x0006000b,
0x00000000,
0xc24b6b80,
0x00000000,
0xe7f001f0,
0x00000000,
0xd24b6b80,
0x00000000,
0xe7f001f0,
0x00000000,
0xe1ca00f0,
0x00000000,
0xe5d6c000,
0xe496e004,
0xe1ca01f8,
0x0006000d,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x0006000e,
0x00000000,
0xe1520000,
0x00000000,
0xe1530000,
0x00000000,
0xea000000,
0x0005000b,
0x0006000f,
0x00000000,
0x33730000,
0x000a0000,
0x337c0000,
0x000a0000,
0x2a000000,
0x00050042,
0xe35c0000,
0xe1ca00f0,
0xe1ca01f8,
0xba000000,
0x00050008,
0x00000000,
0xe3530000,
0xba000000,
0x00050008,
0xeb000000,
0x0003002d,
0xe1ca00f0,
0xe1ca20d8,
0xe1ca01f8,
0x00000000,
0x00060010,
0xeb000000,
0x00030026,
0x00000000,
0x824b6b80,
0x00000000,
0xe7f001f0,
0x00000000,
0x924b6b80,
0x00000000,
0xe7f001f0,
0x00000000,
0xe5d6c000,
0xe496e004,
0xea000000,
0x0005000d,
0x00060012,
0x00000000,
0xeb000000,
0x0003002d,
0xe1ca00f0,
0xe1ca01f8,
0x00000000,
0xe1a02000,
0xe1a03001,
0xe1ca00d8,
0xea000000,
0x00050010,
0x00000000,
0xe7f001f0,
0x00000000,
0xe1aa00d9,
0x00000000,
0xe7f001f0,
0x00000000,
0xe086b10b,
0xe3710000,
0x000a0000,
0x124b6b80,
0x114a00f8,
0x00000000,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0xe7f001f0,
0x00000000,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0xe7f001f0,
0x00000000,
0xe086b10b,
0xe24b6b80,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0xe7f001f0,
0x00000000,
0xe5180000,
0x000d8180,
0xe5561000,
0x000d8180,
0xe5165000,
0x000d8180,
0xe15a0000,
0x8a000000,
0x00050020,
0xe5d6c000,
0xe496e004,
0x0006000c,
0xe15b0181,
0xe3e03000,
0x000a0000,
0xda000000,
0x00050003,
0x00000000,
0xe7f001f0,
0x00000000,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0x0006000d,
0xe18920fb,
0xe28bb008,
0xea000000,
0x0005000c,
0x00000000,
0xe7f001f0,
0x00000000,
0xe5180000,
0x000d8180,
0xe089300b,
0xe08aa00b,
0xe5832000,
0xe28b1000,
0x000a0000,
0xe5165000,
0x000d8180,
0xe15a0000,
0xe5831004,
0x2a000000,
0x00050020,
0xe556c000,
0x000d8180,
0xe1a0a009,
0xe1a0b003,
0xe35c0000,
0xe2839008,
0x0a000000,
0x00050003,
0xe3e02000,
0x000a0000,
0x0006000b,
0xe15a000b,
0x30ca00d8,
0x21a01002,
0x350a2004,
0x0006000c,
0xe25cc001,
0xe1e300f8,
0x1a000000,
0x0005000b,
0x0006000d,
0xe5d6c000,
0xe496e004,
0xe797c10c,
0xe004a2ae,
0xe1a0b82e,
0xe12fff1c,
0x00000000,
0xe5123000,
0x000d8180,
0x00000000,
0xe5173000,
0x000d8180,
0x00000000,
0xe08a100b,
0xe5180000,
0x000d8180,
0xe089b00b,
0xe5089000,
0x000d8180,
0xe1510000,
0xe508b000,
0x000d8180,
0x00000000,
0xe5121000,
0x000d8180,
0x00000000,
0xe3e02000,
0x000a0000,
0xe1a00008,
0x8a000000,
0x0005001f,
0xe5072000,
0x000d8180,
0xe12fff33,
0xe5189000,
0x000d8180,
0xe3e02000,
0x000a0000,
0xe5181000,
0x000d8180,
0xe1a0b180,
0xe5072000,
0x000d8180,
0xe5196004,
0xe041a00b,
0xea000000,
0x00050016,
0x00000000,
0x00010000
};

# 9 "buildvm_arm.dasc"
//|.globals GLOB_
enum {
  GLOB_vm_returnp,
  GLOB_cont_dispatch,
  GLOB_vm_returnc,
  GLOB_BC_RET_Z,
  GLOB_vm_return,
  GLOB_vm_leave_cp,
  GLOB_vm_leave_unw,
  GLOB_vm_unwind_c,
  GLOB_vm_unwind_c_eh,
  GLOB_vm_unwind_ff,
  GLOB_vm_unwind_ff_eh,
  GLOB_vm_growstack_c,
  GLOB_vm_growstack_l,
  GLOB_vm_resume,
  GLOB_vm_pcall,
  GLOB_vm_call,
  GLOB_vm_call_dispatch,
  GLOB_vmeta_call,
  GLOB_vm_call_dispatch_f,
  GLOB_vm_cpcall,
  GLOB_vm_call_tail,
  GLOB_cont_cat,
  GLOB_BC_CAT_Z,
  GLOB_cont_nop,
  GLOB_vmeta_tgets1,
  GLOB_vmeta_tgets,
  GLOB_vmeta_tgetb,
  GLOB_vmeta_tgetv,
  GLOB_vmeta_tsets1,
  GLOB_vmeta_tsets,
  GLOB_vmeta_tsetb,
  GLOB_vmeta_tsetv,
  GLOB_vmeta_comp,
  GLOB_vmeta_binop,
  GLOB_cont_ra,
  GLOB_cont_condt,
  GLOB_cont_condf,
  GLOB_vmeta_equal,
  GLOB_vmeta_equal_cd,
  GLOB_vmeta_arith_vn,
  GLOB_vmeta_arith_nv,
  GLOB_vmeta_unm,
  GLOB_vmeta_arith_vv,
  GLOB_vmeta_len,
  GLOB_vmeta_callt,
  GLOB_BC_CALLT2_Z,
  GLOB_vmeta_for,
  GLOB_ff_assert,
  GLOB_fff_fallback,
  GLOB_fff_res,
  GLOB_ff_type,
  GLOB_fff_restv,
  GLOB_ff_getmetatable,
  GLOB_ff_setmetatable,
  GLOB_ff_rawget,
  GLOB_ff_tonumber,
  GLOB_ff_tostring,
  GLOB_fff_gcstep,
  GLOB_ff_next,
  GLOB_ff_pairs,
  GLOB_ff_ipairs_aux,
  GLOB_ff_ipairs,
  GLOB_ff_pcall,
  GLOB_ff_xpcall,
  GLOB_ff_coroutine_resume,
  GLOB_ff_coroutine_wrap_aux,
  GLOB_ff_coroutine_yield,
  GLOB_ff_math_floor,
  GLOB_ff_math_ceil,
  GLOB_ff_math_abs,
  GLOB_fff_res1,
  GLOB_ff_math_sqrt,
  GLOB_ff_math_log,
  GLOB_ff_math_log10,
  GLOB_ff_math_exp,
  GLOB_ff_math_sin,
  GLOB_ff_math_cos,
  GLOB_ff_math_tan,
  GLOB_ff_math_asin,
  GLOB_ff_math_acos,
  GLOB_ff_math_atan,
  GLOB_ff_math_sinh,
  GLOB_ff_math_cosh,
  GLOB_ff_math_tanh,
  GLOB_ff_math_pow,
  GLOB_ff_math_atan2,
  GLOB_ff_math_fmod,
  GLOB_ff_math_deg,
  GLOB_ff_math_rad,
  GLOB_ff_math_ldexp,
  GLOB_ff_math_frexp,
  GLOB_ff_math_modf,
  GLOB_ff_math_min,
  GLOB_ff_math_max,
  GLOB_ff_string_len,
  GLOB_ff_string_byte,
  GLOB_ff_string_char,
  GLOB_fff_newstr,
  GLOB_ff_string_sub,
  GLOB_fff_emptystr,
  GLOB_ff_string_rep,
  GLOB_ff_string_reverse,
  GLOB_ff_string_lower,
  GLOB_ff_string_upper,
  GLOB_ff_table_getn,
  GLOB_vm_tobit_fb,
  GLOB_vm_tobit,
  GLOB_ff_bit_tobit,
  GLOB_ff_bit_band,
  GLOB_ff_bit_bor,
  GLOB_ff_bit_bxor,
  GLOB_ff_bit_bswap,
  GLOB_ff_bit_bnot,
  GLOB_ff_bit_lshift,
  GLOB_ff_bit_rshift,
  GLOB_ff_bit_arshift,
  GLOB_ff_bit_rol,
  GLOB_ff_bit_ror,
  GLOB_vm_record,
  GLOB_vm_rethook,
  GLOB_vm_inshook,
  GLOB_cont_hook,
  GLOB_vm_hotloop,
  GLOB_vm_callhook,
  GLOB_vm_hotcall,
  GLOB_vm_exit_handler,
  GLOB_vm_exit_interp,
  GLOB_vm_floor,
  GLOB_vm_ceil,
  GLOB_vm_trunc,
  GLOB_vm_mod,
  GLOB_vm_modi,
  GLOB_vm_powi,
  GLOB_vm_foldfpm,
  GLOB_vm_foldarith,
  GLOB_vm_ffi_call,
  GLOB_BC_ISEQN_Z,
  GLOB_BC_ISNEN_Z,
  GLOB_BC_TGETS_Z,
  GLOB_BC_TSETS_Z,
  GLOB_BC_CALL_Z,
  GLOB_BC_CALLT1_Z,
  GLOB_BC_RETM_Z,
  GLOB_BC_RETV2_Z,
  GLOB_BC_RETV1_Z,
  GLOB__MAX
};
# 10 "buildvm_arm.dasc"
//|.globalnames globnames
static const char *const globnames[] = {
  "vm_returnp",
  "cont_dispatch",
  "vm_returnc",
  "BC_RET_Z",
  "vm_return",
  "vm_leave_cp",
  "vm_leave_unw",
  "vm_unwind_c",
  "vm_unwind_c_eh",
  "vm_unwind_ff",
  "vm_unwind_ff_eh",
  "vm_growstack_c",
  "vm_growstack_l",
  "vm_resume",
  "vm_pcall",
  "vm_call",
  "vm_call_dispatch",
  "vmeta_call",
  "vm_call_dispatch_f",
  "vm_cpcall",
  "vm_call_tail",
  "cont_cat",
  "BC_CAT_Z",
  "cont_nop",
  "vmeta_tgets1",
  "vmeta_tgets",
  "vmeta_tgetb",
  "vmeta_tgetv",
  "vmeta_tsets1",
  "vmeta_tsets",
  "vmeta_tsetb",
  "vmeta_tsetv",
  "vmeta_comp",
  "vmeta_binop",
  "cont_ra",
  "cont_condt",
  "cont_condf",
  "vmeta_equal",
  "vmeta_equal_cd",
  "vmeta_arith_vn",
  "vmeta_arith_nv",
  "vmeta_unm",
  "vmeta_arith_vv",
  "vmeta_len",
  "vmeta_callt",
  "BC_CALLT2_Z",
  "vmeta_for",
  "ff_assert",
  "fff_fallback",
  "fff_res",
  "ff_type",
  "fff_restv",
  "ff_getmetatable",
  "ff_setmetatable",
  "ff_rawget",
  "ff_tonumber",
  "ff_tostring",
  "fff_gcstep",
  "ff_next",
  "ff_pairs",
  "ff_ipairs_aux",
  "ff_ipairs",
  "ff_pcall",
  "ff_xpcall",
  "ff_coroutine_resume",
  "ff_coroutine_wrap_aux",
  "ff_coroutine_yield",
  "ff_math_floor",
  "ff_math_ceil",
  "ff_math_abs",
  "fff_res1",
  "ff_math_sqrt",
  "ff_math_log",
  "ff_math_log10",
  "ff_math_exp",
  "ff_math_sin",
  "ff_math_cos",
  "ff_math_tan",
  "ff_math_asin",
  "ff_math_acos",
  "ff_math_atan",
  "ff_math_sinh",
  "ff_math_cosh",
  "ff_math_tanh",
  "ff_math_pow",
  "ff_math_atan2",
  "ff_math_fmod",
  "ff_math_deg",
  "ff_math_rad",
  "ff_math_ldexp",
  "ff_math_frexp",
  "ff_math_modf",
  "ff_math_min",
  "ff_math_max",
  "ff_string_len",
  "ff_string_byte",
  "ff_string_char",
  "fff_newstr",
  "ff_string_sub",
  "fff_emptystr",
  "ff_string_rep",
  "ff_string_reverse",
  "ff_string_lower",
  "ff_string_upper",
  "ff_table_getn",
  "vm_tobit_fb",
  "vm_tobit",
  "ff_bit_tobit",
  "ff_bit_band",
  "ff_bit_bor",
  "ff_bit_bxor",
  "ff_bit_bswap",
  "ff_bit_bnot",
  "ff_bit_lshift",
  "ff_bit_rshift",
  "ff_bit_arshift",
  "ff_bit_rol",
  "ff_bit_ror",
  "vm_record",
  "vm_rethook",
  "vm_inshook",
  "cont_hook",
  "vm_hotloop",
  "vm_callhook",
  "vm_hotcall",
  "vm_exit_handler",
  "vm_exit_interp",
  "vm_floor",
  "vm_ceil",
  "vm_trunc",
  "vm_mod",
  "vm_modi",
  "vm_powi",
  "vm_foldfpm",
  "vm_foldarith",
  "vm_ffi_call",
  "BC_ISEQN_Z",
  "BC_ISNEN_Z",
  "BC_TGETS_Z",
  "BC_TSETS_Z",
  "BC_CALL_Z",
  "BC_CALLT1_Z",
  "BC_RETM_Z",
  "BC_RETV2_Z",
  "BC_RETV1_Z",
  (const char *)0
};
# 11 "buildvm_arm.dasc"
//|.externnames extnames
static const char *const extnames[] = {
  "lj_state_growstack",
  "lj_meta_tget",
  "lj_meta_tset",
  "lj_meta_comp",
  "lj_meta_equal",
  "lj_meta_equal_cd",
  "lj_meta_arith",
  "lj_meta_len",
  "lj_meta_call",
  "lj_meta_for",
  "lj_tab_get",
  "lj_str_fromnumber",
  "lj_tab_next",
  "lj_tab_getinth",
  "lj_ffh_coroutine_wrap_err",
  "floor",
  "ceil",
  "sqrt",
  "log",
  "log10",
  "exp",
  "sin",
  "cos",
  "tan",
  "asin",
  "acos",
  "atan",
  "sinh",
  "cosh",
  "tanh",
  "pow",
  "atan2",
  "fmod",
  "__aeabi_dmul",
  "ldexp",
  "frexp",
  "modf",
  "__aeabi_i2d",
  "__aeabi_cdcmple",
  "lj_str_new",
  "lj_tab_len",
  "lj_gc_step",
  "lj_dispatch_ins",
  "lj_dispatch_call",
  "__aeabi_ddiv",
  "__aeabi_dadd",
  "__aeabi_dsub",
  "__aeabi_cdcmpeq",
  "lj_meta_cat",
  "lj_gc_barrieruv",
  "lj_func_closeuv",
  "lj_func_newL_gc",
  "lj_tab_new",
  "lj_tab_dup",
  "lj_gc_step_fixtop",
  "lj_tab_newkey",
  "lj_tab_reasize",
  (const char *)0
};
# 12 "buildvm_arm.dasc"
//|
//|// Note: The ragged indentation of the instructions is intentional.
//|//       The starting columns indicate data dependencies.
//|
//|//-----------------------------------------------------------------------
//|
//|// Fixed register assignments for the interpreter.
//|
//|// The following must be C callee-save.
//|.define MASKR8,	r4	// 255*8 constant for fast bytecode decoding.
//|.define KBASE,		r5	// Constants of current Lua function.
//|.define PC,		r6	// Next PC.
//|.define DISPATCH,	r7	// Opcode dispatch table.
//|.define LREG,		r8	// Register holding lua_State (also in SAVE_L).
//|
//|// C callee-save in EABI, but often refetched. Temporary in iOS 3.0+.
//|.define BASE,		r9	// Base of current Lua stack frame.
//|
//|// The following temporaries are not saved across C calls, except for RA/RC.
//|.define RA,		r10	// Callee-save.
//|.define RC,		r11	// Callee-save.
//|.define RB,		r12
//|.define OP,		r12	// Overlaps RB, must not be lr.
//|.define INS,		lr
//|
//|// Calling conventions. Also used as temporaries.
//|.define CARG1,		r0
//|.define CARG2,		r1
//|.define CARG3,		r2
//|.define CARG4,		r3
//|.define CARG12,	r0	// For 1st soft-fp double.
//|.define CARG34,	r2	// For 2nd soft-fp double.
//|
//|.define CRET1,		r0
//|.define CRET2,		r1
//|
//|// Stack layout while in interpreter. Must match with lj_frame.h.
//|.define CFRAME_SPACE,	#28
//|.define SAVE_ERRF,	[sp, #24]
//|.define SAVE_NRES,	[sp, #20]
//|.define SAVE_CFRAME,	[sp, #16]
//|.define SAVE_L,	[sp, #12]
//|.define SAVE_PC,	[sp, #8]
//|.define SAVE_MULTRES,	[sp, #4]
//|.define ARG5,		[sp]
//|
//|.define TMPDhi,	[sp, #4]
//|.define TMPDlo,	[sp]
//|.define TMPD,		[sp]
//|.define TMPDp,		sp
//|
//|.macro saveregs
//|  push {r4, r5, r6, r7, r8, r9, r10, r11, lr}
//|  sub sp, sp, CFRAME_SPACE
//|.endmacro
//|.macro restoreregs_ret
//|  add sp, sp, CFRAME_SPACE
//|  pop {r4, r5, r6, r7, r8, r9, r10, r11, pc}
//|.endmacro
//|
//|// Type definitions. Some of these are only used for documentation.
//|.type L,		lua_State,	LREG
#define Dt1(_V) (int)(ptrdiff_t)&(((lua_State *)0)_V)
# 74 "buildvm_arm.dasc"
//|.type GL,		global_State
#define Dt2(_V) (int)(ptrdiff_t)&(((global_State *)0)_V)
# 75 "buildvm_arm.dasc"
//|.type TVALUE,		TValue
#define Dt3(_V) (int)(ptrdiff_t)&(((TValue *)0)_V)
# 76 "buildvm_arm.dasc"
//|.type GCOBJ,		GCobj
#define Dt4(_V) (int)(ptrdiff_t)&(((GCobj *)0)_V)
# 77 "buildvm_arm.dasc"
//|.type STR,		GCstr
#define Dt5(_V) (int)(ptrdiff_t)&(((GCstr *)0)_V)
# 78 "buildvm_arm.dasc"
//|.type TAB,		GCtab
#define Dt6(_V) (int)(ptrdiff_t)&(((GCtab *)0)_V)
# 79 "buildvm_arm.dasc"
//|.type LFUNC,		GCfuncL
#define Dt7(_V) (int)(ptrdiff_t)&(((GCfuncL *)0)_V)
# 80 "buildvm_arm.dasc"
//|.type CFUNC,		GCfuncC
#define Dt8(_V) (int)(ptrdiff_t)&(((GCfuncC *)0)_V)
# 81 "buildvm_arm.dasc"
//|.type PROTO,		GCproto
#define Dt9(_V) (int)(ptrdiff_t)&(((GCproto *)0)_V)
# 82 "buildvm_arm.dasc"
//|.type UPVAL,		GCupval
#define DtA(_V) (int)(ptrdiff_t)&(((GCupval *)0)_V)
# 83 "buildvm_arm.dasc"
//|.type NODE,		Node
#define DtB(_V) (int)(ptrdiff_t)&(((Node *)0)_V)
# 84 "buildvm_arm.dasc"
//|.type NARGS8,		int
#define DtC(_V) (int)(ptrdiff_t)&(((int *)0)_V)
# 85 "buildvm_arm.dasc"
//|.type TRACE,		GCtrace
#define DtD(_V) (int)(ptrdiff_t)&(((GCtrace *)0)_V)
# 86 "buildvm_arm.dasc"
//|
//|//-----------------------------------------------------------------------
//|
//|// Trap for not-yet-implemented parts.
//|.macro NYI; ud; .endmacro
//|
//|//-----------------------------------------------------------------------
//|
//|// Access to frame relative to BASE.
//|.define FRAME_FUNC,	#-8
//|.define FRAME_PC,	#-4
//|
//|.macro decode_RA8, dst, ins; and dst, MASKR8, ins, lsr #5; .endmacro
//|.macro decode_RB8, dst, ins; and dst, MASKR8, ins, lsr #21; .endmacro
//|.macro decode_RC8, dst, ins; and dst, MASKR8, ins, lsr #13; .endmacro
//|.macro decode_RD, dst, ins; lsr dst, ins, #16; .endmacro
//|.macro decode_OP, dst, ins; and dst, ins, #255; .endmacro
//|
//|// Instruction fetch.
//|.macro ins_NEXT1
//|  ldrb OP, [PC]
//|.endmacro
//|.macro ins_NEXT2
//|   ldr INS, [PC], #4
//|.endmacro
//|// Instruction decode+dispatch.
//|.macro ins_NEXT3
//|  ldr OP, [DISPATCH, OP, lsl #2]
//|   decode_RA8 RA, INS
//|   decode_RD RC, INS
//|  bx OP
//|.endmacro
//|.macro ins_NEXT
//|  ins_NEXT1
//|  ins_NEXT2
//|  ins_NEXT3
//|.endmacro
//|
//|// Instruction footer.
//|.if 1
//|  // Replicated dispatch. Less unpredictable branches, but higher I-Cache use.
//|  .define ins_next, ins_NEXT
//|  .define ins_next_, ins_NEXT
//|  .define ins_next1, ins_NEXT1
//|  .define ins_next2, ins_NEXT2
//|  .define ins_next3, ins_NEXT3
//|.else
//|  // Common dispatch. Lower I-Cache use, only one (very) unpredictable branch.
//|  // Affects only certain kinds of benchmarks (and only with -j off).
//|  .macro ins_next
//|    b ->ins_next
//|  .endmacro
//|  .macro ins_next1
//|  .endmacro
//|  .macro ins_next2
//|  .endmacro
//|  .macro ins_next3
//|    b ->ins_next
//|  .endmacro
//|  .macro ins_next_
//|  ->ins_next:
//|    ins_NEXT
//|  .endmacro
//|.endif
//|
//|// Avoid register name substitution for field name.
#define field_pc	pc
//|
//|// Call decode and dispatch.
//|.macro ins_callt
//|  // BASE = new base, CARG3 = LFUNC/CFUNC, RC = nargs*8, FRAME_PC(BASE) = PC
//|  ldr PC, LFUNC:CARG3->field_pc
//|  ldrb OP, [PC]  // STALL: load PC. early PC.
//|   ldr INS, [PC], #4
//|  ldr OP, [DISPATCH, OP, lsl #2]  // STALL: load OP. early OP.
//|   decode_RA8 RA, INS
//|   add RA, RA, BASE
//|  bx OP
//|.endmacro
//|
//|.macro ins_call
//|  // BASE = new base, CARG3 = LFUNC/CFUNC, RC = nargs*8, PC = caller PC
//|  str PC, [BASE, FRAME_PC]
//|  ins_callt  // STALL: locked PC.
//|.endmacro
//|
//|//-----------------------------------------------------------------------
//|
//|// Macros to test operand types.
//|.macro checktp, reg, tp; cmn reg, #-tp; .endmacro
//|.macro checktpeq, reg, tp; cmneq reg, #-tp; .endmacro
//|.macro checktpne, reg, tp; cmnne reg, #-tp; .endmacro
//|.macro checkstr, reg, target; checktp reg, LJ_TSTR; bne target; .endmacro
//|.macro checktab, reg, target; checktp reg, LJ_TTAB; bne target; .endmacro
//|.macro checkfunc, reg, target; checktp reg, LJ_TFUNC; bne target; .endmacro
//|
//|// Assumes DISPATCH is relative to GL.
#define DISPATCH_GL(field)	(GG_DISP2G + (int)offsetof(global_State, field))
#define DISPATCH_J(field)	(GG_DISP2J + (int)offsetof(jit_State, field))
//|
#define PC2PROTO(field)  ((int)offsetof(GCproto, field)-(int)sizeof(GCproto))
//|
//|.macro hotloop
//|  NYI
//|.endmacro
//|
//|.macro hotcall
//|  NYI
//|.endmacro
//|
//|// Set current VM state.
//|.macro mv_vmstate, reg, st; mvn reg, #LJ_VMST_..st; .endmacro
//|.macro st_vmstate, reg; str reg, [DISPATCH, #DISPATCH_GL(vmstate)]; .endmacro
//|
//|// Move table write barrier back. Overwrites mark and tmp.
//|.macro barrierback, tab, mark, tmp
//|  ldr tmp, [DISPATCH, #DISPATCH_GL(gc.grayagain)]
//|   bic mark, mark, #LJ_GC_BLACK		// black2gray(tab)
//|  str tab, [DISPATCH, #DISPATCH_GL(gc.grayagain)]
//|   strb mark, tab->marked
//|  str tmp, tab->gclist
//|.endmacro
//|
//|.macro IOS, a, b
//||if (LJ_TARGET_OSX) {
//|  a, b
//||}
//|.endmacro
//|
//|//-----------------------------------------------------------------------

#if !LJ_DUALNUM
#error "Only dual-number mode supported for ARM target"
#endif

/* Generate subroutines used by opcodes and other parts of the VM. */
/* The .code_sub section should be last to help static branch prediction. */
static void build_subroutines(BuildCtx *ctx)
{
  //|.code_sub
  dasm_put(Dst, 0);
# 226 "buildvm_arm.dasc"
  //|
  //|//-----------------------------------------------------------------------
  //|//-- Return handling ----------------------------------------------------
  //|//-----------------------------------------------------------------------
  //|
  //|->vm_returnp:
  //|  // See vm_return. Also: RB = previous base.
  //|  tst PC, #FRAME_P
  //|  beq ->cont_dispatch
  //|
  //|  // Return from pcall or xpcall fast func.
  //|  ldr PC, [RB, FRAME_PC]		// Fetch PC of previous frame.
  //|   mvn CARG2, #~LJ_TTRUE
  //|  mov BASE, RB
  //|  // Prepending may overwrite the pcall frame, so do it at the end.
  //|   str CARG2, [RA, FRAME_PC]		// Prepend true to results.
  //|  sub RA, RA, #8
  //|
  //|->vm_returnc:
  //|  add RC, RC, #8			// RC = (nresults+1)*8.
  //|   ands CARG1, PC, #FRAME_TYPE
  //|  str RC, SAVE_MULTRES
  //|   beq ->BC_RET_Z			// Handle regular return to Lua.
  //|
  //|->vm_return:
  //|  // BASE = base, RA = resultptr, RC/MULTRES = (nresults+1)*8, PC = return
  //|  // CARG1 = PC & FRAME_TYPE
  //|  bic RB, PC, #FRAME_TYPEP
  //|   cmp CARG1, #FRAME_C
  //|  sub RB, BASE, RB			// RB = previous base.
  //|   bne ->vm_returnp
  //|
  //|  str RB, L->base
  //|   ldr KBASE, SAVE_NRES
  //|    mv_vmstate CARG4, C
  //|   sub BASE, BASE, #8
  //|  subs CARG3, RC, #8
  //|   lsl KBASE, KBASE, #3		// KBASE = (nresults_wanted+1)*8
  //|    st_vmstate CARG4
  //|  beq >2
  //|1:
  //|  subs CARG3, CARG3, #8
  //|   ldrd CARG12, [RA], #8
  //|   strd CARG12, [BASE], #8
  //|  bne <1
  //|2:
  //|  cmp KBASE, RC			// More/less results wanted?
  //|  bne >6
  //|3:
  //|  str BASE, L->top			// Store new top.
  //|
  //|->vm_leave_cp:
  //|  ldr RC, SAVE_CFRAME		// Restore previous C frame.
  dasm_put(Dst, 1, FRAME_P, ~LJ_TTRUE, FRAME_TYPE, FRAME_TYPEP, FRAME_C, Dt1(->base), LJ_VMST_C, DISPATCH_GL(vmstate), Dt1(->top));
# 279 "buildvm_arm.dasc"
  //|   mov CRET1, #0			// Ok return status for vm_pcall.
  //|  str RC, L->cframe
  //|
  //|->vm_leave_unw:
  //|  restoreregs_ret
  //|
  //|6:
  //|  blt >7				// Less results wanted?
  //|  // More results wanted. Check stack size and fill up results with nil.
  //|  ldr CARG3, L->maxstack
  //|   mvn CARG2, #~LJ_TNIL
  //|  cmp BASE, CARG3
  //|  bhs >8
  //|   str CARG2, [BASE, #4]
  //|  add RC, RC, #8
  //|  add BASE, BASE, #8
  //|  b <2
  //|
  //|7:  // Less results wanted.
  //|  sub CARG1, RC, KBASE
  //|  cmp KBASE, #0			// LUA_MULTRET+1 case?
  //|  subne BASE, BASE, CARG1		// Either keep top or shrink it.
  //|  b <3
  //|
  //|8:  // Corner case: need to grow stack for filling up results.
  //|  // This can happen if:
  //|  // - A C function grows the stack (a lot).
  //|  // - The GC shrinks the stack in between.
  //|  // - A return back from a lua_call() with (high) nresults adjustment.
  //|  str BASE, L->top			// Save current top held in BASE (yes).
  //|  mov CARG2, KBASE
  //|  mov CARG1, L
  //|  bl extern lj_state_growstack	// (lua_State *L, int n)
  //|  ldr BASE, L->top			// Need the (realloced) L->top in BASE.
  //|  b <2
  //|
  //|->vm_unwind_c:			// Unwind C stack, return from vm_pcall.
  //|  // (void *cframe, int errcode)
  //|  mov sp, CARG1
  //|  mov CRET1, CARG2
  //|->vm_unwind_c_eh:			// Landing pad for external unwinder.
  //|  ldr L, SAVE_L
  //|   mv_vmstate CARG4, C
  //|  ldr GL:CARG3, L->glref
  //|   str CARG4, GL:CARG3->vmstate
  //|  b ->vm_leave_unw
  //|
  //|->vm_unwind_ff:			// Unwind C stack, return from ff pcall.
  //|  // (void *cframe)
  //|  bic sp, CARG1, #~CFRAME_RAWMASK
  dasm_put(Dst, 54, Dt1(->cframe), Dt1(->maxstack), ~LJ_TNIL, Dt1(->top), Dt1(->top), LJ_VMST_C, Dt1(->glref), Dt2(->vmstate));
# 329 "buildvm_arm.dasc"
  //|->vm_unwind_ff_eh:			// Landing pad for external unwinder.
  //|  ldr L, SAVE_L
  //|   mov MASKR8, #255
  //|    mov RC, #16			// 2 results: false + error message.
  //|   lsl MASKR8, MASKR8, #3		// MASKR8 = 255*8.
  //|  ldr BASE, L->base
  //|   ldr DISPATCH, L->glref		// Setup pointer to dispatch table.
  //|    mvn CARG1, #~LJ_TFALSE
  //|  sub RA, BASE, #8			// Results start at BASE-8.
  //|  ldr PC, [BASE, FRAME_PC]		// Fetch PC of previous frame.
  //|   add DISPATCH, DISPATCH, #GG_G2DISP
  //|   mv_vmstate CARG2, INTERP
  //|    str CARG1, [BASE, #-4]		// Prepend false to error message.
  //|   st_vmstate CARG2
  //|  b ->vm_returnc
  //|
  //|//-----------------------------------------------------------------------
  //|//-- Grow stack for calls -----------------------------------------------
  //|//-----------------------------------------------------------------------
  //|
  //|->vm_growstack_c:			// Grow stack for C function.
  //|  // CARG1 = L
  //|  mov CARG2, #LUA_MINSTACK
  //|  b >2
  //|
  //|->vm_growstack_l:			// Grow stack for Lua function.
  //|  // BASE = new base, RA = BASE+framesize*8, RC = nargs*8, PC = first PC
  //|  add RC, BASE, RC
  //|   sub RA, RA, BASE
  //|    mov CARG1, L
  //|  str BASE, L->base
  //|   add PC, PC, #4			// Must point after first instruction.
  //|  str RC, L->top
  //|   lsr CARG3, RA, #3
  //|2:
  //|  // L->base = new base, L->top = top
  //|  str PC, SAVE_PC
  //|  bl extern lj_state_growstack	// (lua_State *L, int n)
  //|  ldr BASE, L->base
  //|   ldr RC, L->top
  //|  ldr LFUNC:CARG3, [BASE, FRAME_FUNC]
  //|   sub NARGS8:RC, RC, BASE
  //|  // BASE = new base, RB = LFUNC/CFUNC, RC = nargs*8, FRAME_PC(BASE) = PC
  //|  ins_callt				// Just retry the call.
  //|
  //|//-----------------------------------------------------------------------
  //|//-- Entry points into the assembler VM ---------------------------------
  //|//-----------------------------------------------------------------------
  //|
  //|->vm_resume:				// Setup C frame and resume thread.
  //|  // (lua_State *L, TValue *base, int nres1 = 0, ptrdiff_t ef = 0)
  //|  saveregs
  //|  mov L, CARG1
  //|    ldr DISPATCH, L:CARG1->glref	// Setup pointer to dispatch table.
  //|  mov BASE, CARG2
  dasm_put(Dst, 108, ~CFRAME_RAWMASK, Dt1(->base), Dt1(->glref), ~LJ_TFALSE, GG_G2DISP, LJ_VMST_INTERP, DISPATCH_GL(vmstate), LUA_MINSTACK, Dt1(->base), Dt1(->top), Dt1(->base), Dt1(->top), Dt7(->field_pc), Dt1(->glref));
# 384 "buildvm_arm.dasc"
  //|    add DISPATCH, DISPATCH, #GG_G2DISP
  //|   str L, SAVE_L
  //|  mov PC, #FRAME_CP
  //|   str CARG3, SAVE_NRES
  //|    add CARG2, sp, #CFRAME_RESUME
  //|  ldrb CARG1, L->status
  //|   str CARG3, SAVE_ERRF
  //|    str CARG2, L->cframe
  //|   str CARG3, SAVE_CFRAME
  //|  cmp CARG1, #0
  //|   str L, SAVE_PC			// Any value outside of bytecode is ok.
  //|  beq >3
  //|
  //|  // Resume after yield (like a return).
  //|  mov RA, BASE
  //|   ldr BASE, L->base
  //|   ldr CARG1, L->top
  //|    mov MASKR8, #255
  //|     strb CARG3, L->status
  //|   sub RC, CARG1, BASE
  //|  ldr PC, [BASE, FRAME_PC]
  //|    lsl MASKR8, MASKR8, #3		// MASKR8 = 255*8.
  //|     mv_vmstate CARG2, INTERP
  //|   add RC, RC, #8
  //|  ands CARG1, PC, #FRAME_TYPE
  //|     st_vmstate CARG2
  //|   str RC, SAVE_MULTRES
  //|  beq ->BC_RET_Z
  //|  b ->vm_return
  //|
  //|->vm_pcall:				// Setup protected C frame and enter VM.
  //|  // (lua_State *L, TValue *base, int nres1, ptrdiff_t ef)
  //|  saveregs
  //|  mov PC, #FRAME_CP
  //|  str CARG4, SAVE_ERRF
  //|  b >1
  //|
  //|->vm_call:				// Setup C frame and enter VM.
  //|  // (lua_State *L, TValue *base, int nres1)
  //|  saveregs
  //|  mov PC, #FRAME_C
  //|
  //|1:  // Entry point for vm_pcall above (PC = ftype).
  //|  ldr RC, L:CARG1->cframe
  //|   str CARG3, SAVE_NRES
  //|    mov L, CARG1
  //|   str CARG1, SAVE_L
  //|    mov BASE, CARG2
  //|  str sp, L->cframe			// Add our C frame to cframe chain.
  //|    ldr DISPATCH, L->glref		// Setup pointer to dispatch table.
  dasm_put(Dst, 172, GG_G2DISP, FRAME_CP, CFRAME_RESUME, Dt1(->status), Dt1(->cframe), Dt1(->base), Dt1(->top), Dt1(->status), LJ_VMST_INTERP, FRAME_TYPE, DISPATCH_GL(vmstate), FRAME_CP, FRAME_C, Dt1(->cframe), Dt1(->cframe));
# 434 "buildvm_arm.dasc"
  //|   str CARG1, SAVE_PC		// Any value outside of bytecode is ok.
  //|  str RC, SAVE_CFRAME
  //|    add DISPATCH, DISPATCH, #GG_G2DISP
  //|
  //|3:  // Entry point for vm_cpcall/vm_resume (BASE = base, PC = ftype).
  //|  ldr RB, L->base			// RB = old base (for vmeta_call).
  //|   ldr CARG1, L->top
  //|    mov MASKR8, #255
  //|  add PC, PC, BASE
  //|    lsl MASKR8, MASKR8, #3		// MASKR8 = 255*8.
  //|  sub PC, PC, RB			// PC = frame delta + frame type
  //|    mv_vmstate CARG2, INTERP
  //|   sub NARGS8:RC, CARG1, BASE
  //|    st_vmstate CARG2
  //|
  //|->vm_call_dispatch:
  //|  // RB = old base, BASE = new base, RC = nargs*8, PC = caller PC
  //|  ldrd CARG34, [BASE, FRAME_FUNC]
  //|  checkfunc CARG4, ->vmeta_call
  //|
  //|->vm_call_dispatch_f:
  //|  ins_call
  //|  // BASE = new base, CARG3 = func, RC = nargs*8, PC = caller PC
  //|
  //|->vm_cpcall:				// Setup protected C frame, call C.
  //|  // (lua_State *L, lua_CFunction func, void *ud, lua_CPFunction cp)
  //|  saveregs
  //|  mov L, CARG1
  //|   ldr RA, L:CARG1->stack
  //|  str CARG1, SAVE_L
  //|   ldr RB, L->top
  //|  str CARG1, SAVE_PC			// Any value outside of bytecode is ok.
  //|  ldr RC, L->cframe
  //|   sub RA, RA, RB			// Compute -savestack(L, L->top).
  //|  str sp, L->cframe			// Add our C frame to cframe chain.
  //|  mov RB, #0
  //|   str RA, SAVE_NRES			// Neg. delta means cframe w/o frame.
  //|  str RB, SAVE_ERRF			// No error function.
  //|  str RC, SAVE_CFRAME
  //|  blx CARG4			// (lua_State *L, lua_CFunction func, void *ud)
  //|   ldr DISPATCH, L->glref		// Setup pointer to dispatch table.
  //|  movs BASE, CRET1
  //|    mov PC, #FRAME_CP
  //|   add DISPATCH, DISPATCH, #GG_G2DISP
  //|  bne <3				// Else continue with the call.
  //|  b ->vm_leave_cp			// No base? Just remove C frame.
  //|
  //|//-----------------------------------------------------------------------
  //|//-- Metamethod handling ------------------------------------------------
  //|//-----------------------------------------------------------------------
  //|
  //|//-- Continuation dispatch ----------------------------------------------
  //|
  //|->cont_dispatch:
  //|  // BASE = meta base, RA = resultptr, RC = (nresults+1)*8
  //|  ldr LFUNC:CARG3, [RB, FRAME_FUNC]
  dasm_put(Dst, 237, Dt1(->glref), GG_G2DISP, Dt1(->base), Dt1(->top), LJ_VMST_INTERP, DISPATCH_GL(vmstate), -LJ_TFUNC, Dt7(->field_pc), Dt1(->stack), Dt1(->top), Dt1(->cframe), Dt1(->cframe), Dt1(->glref), FRAME_CP, GG_G2DISP);
# 490 "buildvm_arm.dasc"
  //|    ldr CARG1, [BASE, #-16]		// Get continuation.
  //|   mov CARG4, BASE
  //|   mov BASE, RB			// Restore caller BASE.
  //|    cmp CARG1, #0
  //|   ldr PC, [CARG4, #-12]		// Restore PC from [cont|PC].
  //|    beq >1
  //|  ldr CARG3, LFUNC:CARG3->field_pc
  //|    mvn INS, #~LJ_TNIL
  //|    add CARG2, RA, RC
  //|    str INS, [CARG2, #-4]		// Ensure one valid arg.
  //|  ldr KBASE, [CARG3, #PC2PROTO(k)]
  //|  // BASE = base, RA = resultptr, CARG4 = meta base
  //|   bx CARG1
  //|
  //|1:  // Tail call from C function.
  //|  ldr CARG3, [BASE, FRAME_FUNC]
  //|   sub CARG4, CARG4, #16
  //|   sub RC, CARG4, BASE
  //|  b ->vm_call_tail
  //|
  //|->cont_cat:				// RA = resultptr, CARG4 = meta base
  //|  ldr INS, [PC, #-4]
  //|   sub CARG2, CARG4, #16
  //|   ldrd CARG34, [RA]
  //|     str BASE, L->base
  //|  decode_RB8 RC, INS
  //|   decode_RA8 RA, INS
  //|  add CARG1, BASE, RC
  //|  subs CARG1, CARG2, CARG1
  //|   strdne CARG34, [CARG2]
  //|   movne CARG3, CARG1
  //|  bne ->BC_CAT_Z
  //|   strd CARG34, [BASE, RA]
  //|  b ->cont_nop
  //|
  //|//-- Table indexing metamethods -----------------------------------------
  //|
  //|->vmeta_tgets1:
  //|  add CARG2, BASE, RB
  //|  b >2
  //|
  //|->vmeta_tgets:
  //|  sub CARG2, DISPATCH, #-DISPATCH_GL(tmptv)
  //|   mvn CARG4, #~LJ_TTAB
  //|  str TAB:RB, [CARG2]
  //|   str CARG4, [CARG2, #4]
  //|2:
  //|   mvn CARG4, #~LJ_TSTR
  //|  str STR:RC, TMPDlo
  //|   str CARG4, TMPDhi
  //|  mov CARG3, TMPDp
  //|  b >1
  //|
  //|->vmeta_tgetb:			// RC = index
  //|  decode_RB8 RB, INS
  //|   str RC, TMPDlo
  //|   mvn CARG4, #~LJ_TISNUM
  //|  add CARG2, BASE, RB
  //|   str CARG4, TMPDhi
  //|  mov CARG3, TMPDp
  //|  b >1
  //|
  //|->vmeta_tgetv:
  //|  add CARG2, BASE, RB
  dasm_put(Dst, 306, Dt7(->field_pc), ~LJ_TNIL, PC2PROTO(k), Dt1(->base), -DISPATCH_GL(tmptv), ~LJ_TTAB, ~LJ_TSTR, ~LJ_TISNUM);
# 554 "buildvm_arm.dasc"
  //|   add CARG3, BASE, RC
  //|1:
  //|   str BASE, L->base
  //|  mov CARG1, L
  //|   str PC, SAVE_PC
  //|  bl extern lj_meta_tget		// (lua_State *L, TValue *o, TValue *k)
  //|  // Returns TValue * (finished) or NULL (metamethod).
  //|  IOS ldr BASE, L->base
  dasm_put(Dst, 377, Dt1(->base));
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 387, Dt1(->base));
  }
# 562 "buildvm_arm.dasc"
  //|  cmp CRET1, #0
  //|  beq >3
  //|  ldrd CARG34, [CRET1]
  //|   ins_next1
  //|   ins_next2
  //|  strd CARG34, [BASE, RA]
  //|   ins_next3
  //|
  //|3:  // Call __index metamethod.
  //|  // BASE = base, L->top = new base, stack = cont/func/t/k
  //|   rsb CARG1, BASE, #FRAME_CONT
  //|  ldr BASE, L->top
  //|    mov NARGS8:RC, #16		// 2 args for func(t, k).
  //|    str PC, [BASE, #-12]		// [cont|PC]
  //|   add PC, CARG1, BASE
  //|  ldr LFUNC:CARG3, [BASE, FRAME_FUNC]  // Guaranteed to be a function here.
  //|  b ->vm_call_dispatch_f
  //|
  //|//-----------------------------------------------------------------------
  //|
  //|->vmeta_tsets1:
  //|  add CARG2, BASE, RB
  //|  b >2
  //|
  //|->vmeta_tsets:
  //|  sub CARG2, DISPATCH, #-DISPATCH_GL(tmptv)
  //|   mvn CARG4, #~LJ_TTAB
  //|  str TAB:RB, [CARG2]
  //|   str CARG4, [CARG2, #4]
  //|2:
  //|   mvn CARG4, #~LJ_TSTR
  //|  str STR:RC, TMPDlo
  //|   str CARG4, TMPDhi
  //|  mov CARG3, TMPDp
  //|  b >1
  //|
  //|->vmeta_tsetb:			// RC = index
  //|  decode_RB8 RB, INS
  //|   str RC, TMPDlo
  //|   mvn CARG4, #~LJ_TISNUM
  //|  add CARG2, BASE, RB
  //|   str CARG4, TMPDhi
  //|  mov CARG3, TMPDp
  //|  b >1
  //|
  //|->vmeta_tsetv:
  //|  add CARG2, BASE, RB
  //|   add CARG3, BASE, RC
  //|1:
  //|   str BASE, L->base
  //|  mov CARG1, L
  //|   str PC, SAVE_PC
  //|  bl extern lj_meta_tset		// (lua_State *L, TValue *o, TValue *k)
  //|  // Returns TValue * (finished) or NULL (metamethod).
  //|  IOS ldr BASE, L->base
  dasm_put(Dst, 390, FRAME_CONT, Dt1(->top), -DISPATCH_GL(tmptv), ~LJ_TTAB, ~LJ_TSTR, ~LJ_TISNUM, Dt1(->base));
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 452, Dt1(->base));
  }
# 617 "buildvm_arm.dasc"
  //|  cmp CRET1, #0
  //|   ldrd CARG34, [BASE, RA]
  //|  beq >3
  //|   ins_next1
  //|  // NOBARRIER: lj_meta_tset ensures the table is not black.
  //|  strd CARG34, [CRET1]
  //|   ins_next2
  //|   ins_next3
  //|
  //|3:  // Call __newindex metamethod.
  //|  // BASE = base, L->top = new base, stack = cont/func/t/k/(v)
  //|   rsb CARG1, BASE, #FRAME_CONT
  //|  ldr BASE, L->top
  //|    mov NARGS8:RC, #24		// 3 args for func(t, k, v).
  //|   strd CARG34, [BASE, #16]		// Copy value to third argument.
  //|    str PC, [BASE, #-12]		// [cont|PC]
  //|   add PC, CARG1, BASE
  //|  ldr LFUNC:CARG3, [BASE, FRAME_FUNC]  // Guaranteed to be a function here.
  //|  b ->vm_call_dispatch_f
  //|
  //|//-- Comparison metamethods ---------------------------------------------
  //|
  //|->vmeta_comp:
  //|  mov CARG1, L
  //|   sub PC, PC, #4
  //|  mov CARG2, RA
  //|   str BASE, L->base
  //|  mov CARG3, RC
  //|   str PC, SAVE_PC
  //|  decode_OP CARG4, INS
  //|  bl extern lj_meta_comp  // (lua_State *L, TValue *o1, *o2, int op)
  //|  // Returns 0/1 or TValue * (metamethod).
  //|3:
  //|  IOS ldr BASE, L->base
  dasm_put(Dst, 455, FRAME_CONT, Dt1(->top), Dt1(->base));
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 491, Dt1(->base));
  }
# 651 "buildvm_arm.dasc"
  //|  cmp CRET1, #1
  //|  bhi ->vmeta_binop
  //|4:
  //|  ldrh RB, [PC, #2]
  //|   add PC, PC, #4
  //|  add RB, PC, RB, lsl #2
  //|  subhs PC, RB, #0x20000
  //|->cont_nop:
  //|  ins_next
  //|
  //|->cont_ra:				// RA = resultptr
  //|  ldr INS, [PC, #-4]
  //|   ldrd CARG12, [RA]
  //|  decode_RA8 CARG3, INS
  //|   strd CARG12, [BASE, CARG3]
  //|  b ->cont_nop
  //|
  //|->cont_condt:			// RA = resultptr
  //|  ldr CARG2, [RA, #4]
  //|   mvn CARG1, #~LJ_TTRUE
  //|  cmp CARG1, CARG2			// Branch if result is true.
  //|  b <4
  //|
  //|->cont_condf:			// RA = resultptr
  //|  ldr CARG2, [RA, #4]
  //|  checktp CARG2, LJ_TFALSE		// Branch if result is false.
  //|  b <4
  //|
  //|->vmeta_equal:
  //|  // CARG2, CARG3, CARG4 are already set by BC_ISEQV/BC_ISNEV.
  //|  sub PC, PC, #4
  //|   str BASE, L->base
  //|   mov CARG1, L
  //|  str PC, SAVE_PC
  //|  bl extern lj_meta_equal  // (lua_State *L, GCobj *o1, *o2, int ne)
  //|  // Returns 0/1 or TValue * (metamethod).
  //|  b <3
  //|
  //|->vmeta_equal_cd:
  dasm_put(Dst, 494, ~LJ_TTRUE, -LJ_TFALSE, Dt1(->base));
# 690 "buildvm_arm.dasc"
#if LJ_HASFFI
  //|  sub PC, PC, #4
  //|   str BASE, L->base
  //|   mov CARG1, L
  //|   mov CARG2, INS
  //|  str PC, SAVE_PC
  //|  bl extern lj_meta_equal_cd		// (lua_State *L, BCIns op)
  //|  // Returns 0/1 or TValue * (metamethod).
  //|  b <3
  dasm_put(Dst, 541, Dt1(->base));
# 699 "buildvm_arm.dasc"
#endif
  //|
  //|//-- Arithmetic metamethods ---------------------------------------------
  //|
  //|->vmeta_arith_vn:
  //|  decode_RB8 RB, INS
  //|   decode_RC8 RC, INS
  //|  add CARG3, BASE, RB
  //|   add CARG4, KBASE, RC
  //|  b >1
  //|
  //|->vmeta_arith_nv:
  //|  decode_RB8 RB, INS
  //|   decode_RC8 RC, INS
  //|  add CARG4, BASE, RB
  //|   add CARG3, KBASE, RC
  //|  b >1
  //|
  //|->vmeta_unm:
  //|  ldr INS, [PC, #-8]
  //|   sub PC, PC, #4
  //|  add CARG3, BASE, RC
  //|  add CARG4, BASE, RC
  //|  b >1
  //|
  //|->vmeta_arith_vv:
  //|  decode_RB8 RB, INS
  //|   decode_RC8 RC, INS
  //|  add CARG3, BASE, RB
  //|   add CARG4, BASE, RC
  //|1:
  //|  decode_OP OP, INS
  //|   add CARG2, BASE, RA
  //|    str BASE, L->base
  //|   mov CARG1, L
  //|    str PC, SAVE_PC
  //|  str OP, ARG5
  //|  bl extern lj_meta_arith  // (lua_State *L, TValue *ra,*rb,*rc, BCReg op)
  //|  // Returns NULL (finished) or TValue * (metamethod).
  //|  IOS ldr BASE, L->base
  dasm_put(Dst, 552, Dt1(->base));
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 589, Dt1(->base));
  }
# 739 "buildvm_arm.dasc"
  //|  cmp CRET1, #0
  //|  beq ->cont_nop
  //|
  //|  // Call metamethod for binary op.
  //|->vmeta_binop:
  //|  // BASE = old base, CRET1 = new base, stack = cont/func/o1/o2
  //|  sub CARG2, CRET1, BASE
  //|   str PC, [CRET1, #-12]		// [cont|PC]
  //|  add PC, CARG2, #FRAME_CONT
  //|   mov BASE, CRET1
  //|    mov NARGS8:RC, #16		// 2 args for func(o1, o2).
  //|  b ->vm_call_dispatch
  //|
  //|->vmeta_len:
  //|  add CARG2, BASE, RC
  //|   str BASE, L->base
  //|  mov CARG1, L
  //|   str PC, SAVE_PC
  //|  bl extern lj_meta_len		// (lua_State *L, TValue *o)
  //|  // Returns TValue * (metamethod base).
  //|  IOS ldr BASE, L->base
  dasm_put(Dst, 592, FRAME_CONT, Dt1(->base));
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 613, Dt1(->base));
  }
# 760 "buildvm_arm.dasc"
  //|  b ->vmeta_binop			// Binop call for compatibility.
  //|
  //|//-- Call metamethod ----------------------------------------------------
  //|
  //|->vmeta_call:			// Resolve and call __call metamethod.
  //|  // RB = old base, BASE = new base, RC = nargs*8
  //|  mov CARG1, L
  //|   str RB, L->base			// This is the callers base!
  //|  sub CARG2, BASE, #8
  //|   str PC, SAVE_PC
  //|  add CARG3, BASE, NARGS8:RC
  //|  IOS mov RA, BASE
  dasm_put(Dst, 616, Dt1(->base));
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 626);
  }
# 772 "buildvm_arm.dasc"
  //|  bl extern lj_meta_call	// (lua_State *L, TValue *func, TValue *top)
  //|  IOS mov BASE, RA
  dasm_put(Dst, 628);
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 631);
  }
# 774 "buildvm_arm.dasc"
  //|  ldr LFUNC:CARG3, [BASE, FRAME_FUNC]  // Guaranteed to be a function here.
  //|   add NARGS8:RC, NARGS8:RC, #8	// Got one more argument now.
  //|  ins_call
  //|
  //|->vmeta_callt:			// Resolve __call for BC_CALLT.
  //|  // BASE = old base, RA = new base, RC = nargs*8
  //|  mov CARG1, L
  //|   str BASE, L->base
  //|  sub CARG2, RA, #8
  //|   str PC, SAVE_PC
  //|  add CARG3, RA, NARGS8:RC
  //|  bl extern lj_meta_call	// (lua_State *L, TValue *func, TValue *top)
  //|  IOS ldr BASE, L->base
  dasm_put(Dst, 633, Dt7(->field_pc), Dt1(->base));
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 654, Dt1(->base));
  }
# 787 "buildvm_arm.dasc"
  //|  ldr LFUNC:CARG3, [RA, FRAME_FUNC]  // Guaranteed to be a function here.
  //|   ldr PC, [BASE, FRAME_PC]
  //|    add NARGS8:RC, NARGS8:RC, #8	// Got one more argument now.
  //|  b ->BC_CALLT2_Z
  //|
  //|//-- Argument coercion for 'for' statement ------------------------------
  //|
  //|->vmeta_for:
  //|  mov CARG1, L
  //|   str BASE, L->base
  //|  mov CARG2, RA
  //|   str PC, SAVE_PC
  //|  bl extern lj_meta_for	// (lua_State *L, TValue *base)
  //|  IOS ldr BASE, L->base
  dasm_put(Dst, 657, Dt1(->base));
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 671, Dt1(->base));
  }
# 801 "buildvm_arm.dasc"
#if LJ_HASJIT
  //|   ldrb OP, [PC, #-4]
  dasm_put(Dst, 674);
# 803 "buildvm_arm.dasc"
#endif
  //|  ldr INS, [PC, #-4]
  dasm_put(Dst, 676);
# 805 "buildvm_arm.dasc"
#if LJ_HASJIT
  //|   cmp OP, #BC_JFORI
  dasm_put(Dst, 678, BC_JFORI);
# 807 "buildvm_arm.dasc"
#endif
  //|  decode_RA8 RA, INS
  //|  decode_RD RC, INS
  dasm_put(Dst, 681);
# 810 "buildvm_arm.dasc"
#if LJ_HASJIT
  //|   beq =>BC_JFORI
  dasm_put(Dst, 684, BC_JFORI);
# 812 "buildvm_arm.dasc"
#endif
  //|  b =>BC_FORI
  //|
  //|//-----------------------------------------------------------------------
  //|//-- Fast functions -----------------------------------------------------
  //|//-----------------------------------------------------------------------
  //|
  //|.macro .ffunc, name
  //|->ff_ .. name:
  //|.endmacro
  //|
  //|.macro .ffunc_1, name
  //|->ff_ .. name:
  //|  ldrd CARG12, [BASE]
  //|   cmp NARGS8:RC, #8
  //|   blo ->fff_fallback
  //|.endmacro
  //|
  //|.macro .ffunc_2, name
  //|->ff_ .. name:
  //|  ldrd CARG12, [BASE]
  //|   ldrd CARG34, [BASE, #8]
  //|    cmp NARGS8:RC, #16
  //|    blo ->fff_fallback
  //|.endmacro
  //|
  //|.macro .ffunc_n, name
  //|  .ffunc_1 name
  //|  checktp CARG2, LJ_TISNUM
  //|  bhs ->fff_fallback
  //|.endmacro
  //|
  //|.macro .ffunc_nn, name
  //|  .ffunc_2 name
  //|  checktp CARG2, LJ_TISNUM
  //|  cmnlo CARG4, #-LJ_TISNUM
  //|  bhs ->fff_fallback
  //|.endmacro
  //|
  //|// Inlined GC threshold check. Caveat: uses CARG1 and CARG2.
  //|.macro ffgccheck
  //|  ldr CARG1, [DISPATCH, #DISPATCH_GL(gc.total)]
  //|  ldr CARG2, [DISPATCH, #DISPATCH_GL(gc.threshold)]
  //|  cmp CARG1, CARG2
  //|  blge ->fff_gcstep
  //|.endmacro
  //|
  //|//-- Base library: checks -----------------------------------------------
  //|
  //|.ffunc_1 assert
  //|  checktp CARG2, LJ_TTRUE
  //|  bhi ->fff_fallback
  //|   ldr PC, [BASE, FRAME_PC]
  //|  strd CARG12, [BASE, #-8]
  //|  mov RB, BASE
  //|  subs RA, NARGS8:RC, #8
  //|   add RC, NARGS8:RC, #8		// Compute (nresults+1)*8.
  //|  beq ->fff_res			// Done if exactly 1 argument.
  //|1:
  //|   ldrd CARG12, [RB, #8]
  //|  subs RA, RA, #8
  //|   strd CARG12, [RB], #8
  //|  bne <1
  //|  b ->fff_res
  //|
  //|.ffunc type
  //|  ldr CARG2, [BASE, #4]
  //|   cmp NARGS8:RC, #8
  //|   blo ->fff_fallback
  //|  checktp CARG2, LJ_TISNUM
  //|  mvnlo CARG2, #~LJ_TISNUM
  //|  rsb CARG4, CARG2, #(int)(offsetof(GCfuncC, upvalue)>>3)-1
  //|  lsl CARG4, CARG4, #3
  //|  ldrd CARG12, [CFUNC:CARG3, CARG4]
  //|  b ->fff_restv
  //|
  //|//-- Base library: getters and setters ---------------------------------
  //|
  //|.ffunc_1 getmetatable
  //|  checktp CARG2, LJ_TTAB
  //|  cmnne CARG2, #-LJ_TUDATA
  //|  bne >6
  //|1:  // Field metatable must be at same offset for GCtab and GCudata!
  //|  ldr TAB:RB, TAB:CARG1->metatable
  //|2:
  //|   mvn CARG2, #~LJ_TNIL
  dasm_put(Dst, 687, BC_FORI, -LJ_TTRUE, -LJ_TISNUM, ~LJ_TISNUM, (int)(offsetof(GCfuncC, upvalue)>>3)-1, -LJ_TTAB, -LJ_TUDATA, Dt6(->metatable));
# 898 "buildvm_arm.dasc"
  //|   ldr STR:RC, [DISPATCH, #DISPATCH_GL(gcroot[GCROOT_MMNAME+MM_metatable])]
  //|  cmp TAB:RB, #0
  //|  beq ->fff_restv
  //|  ldr CARG3, TAB:RB->hmask
  //|   ldr CARG4, STR:RC->hash
  //|    ldr NODE:INS, TAB:RB->node
  //|  and CARG3, CARG3, CARG4		// idx = str->hash & tab->hmask
  //|  add CARG3, CARG3, CARG3, lsl #1
  //|    add NODE:INS, NODE:INS, CARG3, lsl #3	// node = tab->node + idx*3*8
  //|3:  // Rearranged logic, because we expect _not_ to find the key.
  //|  ldrd CARG34, NODE:INS->key  // STALL: early NODE:INS.
  //|   ldrd CARG12, NODE:INS->val
  //|    ldr NODE:INS, NODE:INS->next
  //|  cmp CARG3, STR:RC
  //|  checktpeq CARG4, LJ_TSTR
  //|  beq >5
  //|  cmp NODE:INS, #0
  //|  bne <3
  //|4:
  //|  mov CARG1, RB			// Use metatable as default result.
  //|  mvn CARG2, #~LJ_TTAB
  //|  b ->fff_restv
  //|5:
  //|  checktp CARG2, LJ_TNIL
  //|  bne ->fff_restv
  //|  b <4
  //|
  //|6:
  //|  checktp CARG2, LJ_TISNUM
  //|  mvnhs CARG2, CARG2
  dasm_put(Dst, 744, ~LJ_TNIL, DISPATCH_GL(gcroot[GCROOT_MMNAME+MM_metatable]), Dt6(->hmask), Dt5(->hash), Dt6(->node), DtB(->key), DtB(->val), DtB(->next), -LJ_TSTR, ~LJ_TTAB, -LJ_TNIL, -LJ_TISNUM);
# 928 "buildvm_arm.dasc"
  //|  movlo CARG2, #~LJ_TISNUM
  //|  add CARG4, DISPATCH, CARG2, lsl #2
  //|  ldr TAB:RB, [CARG4, #DISPATCH_GL(gcroot[GCROOT_BASEMT])]
  //|  b <2
  //|
  //|.ffunc_2 setmetatable
  //|  // Fast path: no mt for table yet and not clearing the mt.
  //|  checktp CARG2, LJ_TTAB
  //|   ldreq TAB:RB, TAB:CARG1->metatable
  //|  checktpeq CARG4, LJ_TTAB
  //|    ldrbeq CARG4, TAB:CARG1->marked
  //|   cmpeq TAB:RB, #0
  //|  bne ->fff_fallback
  //|    tst CARG4, #LJ_GC_BLACK		// isblack(table)
  //|     str TAB:CARG3, TAB:CARG1->metatable
  //|    beq ->fff_restv
  //|  barrierback TAB:CARG1, CARG4, CARG3
  //|  b ->fff_restv
  //|
  //|.ffunc rawget
  //|  ldrd CARG34, [BASE]
  //|   cmp NARGS8:RC, #16
  //|   blo ->fff_fallback
  //|   mov CARG2, CARG3
  //|  checktab CARG4, ->fff_fallback
  dasm_put(Dst, 792, ~LJ_TISNUM, DISPATCH_GL(gcroot[GCROOT_BASEMT]), -LJ_TTAB, Dt6(->metatable), -LJ_TTAB, Dt6(->marked), LJ_GC_BLACK, Dt6(->metatable), DISPATCH_GL(gc.grayagain), LJ_GC_BLACK, DISPATCH_GL(gc.grayagain), Dt6(->marked), Dt6(->gclist), -LJ_TTAB);
# 953 "buildvm_arm.dasc"
  //|   mov CARG1, L
  //|   add CARG3, BASE, #8
  //|  IOS mov RA, BASE
  dasm_put(Dst, 844);
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 849);
  }
# 956 "buildvm_arm.dasc"
  //|  bl extern lj_tab_get  // (lua_State *L, GCtab *t, cTValue *key)
  //|  // Returns cTValue *.
  //|  IOS mov BASE, RA
  dasm_put(Dst, 851);
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 854);
  }
# 959 "buildvm_arm.dasc"
  //|  ldrd CARG12, [CRET1]
  //|  b ->fff_restv
  //|
  //|//-- Base library: conversions ------------------------------------------
  //|
  //|.ffunc_1 tonumber
  //|  // Only handles the number case inline (without a base argument).
  //|  checktp CARG2, LJ_TISNUM
  //|  bls ->fff_restv
  //|  b ->fff_fallback
  //|
  //|.ffunc_1 tostring
  //|  // Only handles the string or number case inline.
  //|  checktp CARG2, LJ_TSTR
  //|  // A __tostring method in the string base metatable is ignored.
  //|  beq ->fff_restv
  //|  // Handle numbers inline, unless a number base metatable is present.
  //|  ldr CARG4, [DISPATCH, #DISPATCH_GL(gcroot[GCROOT_BASEMT_NUM])]
  //|   str BASE, L->base
  //|  checktp CARG2, LJ_TISNUM
  //|  cmpls CARG4, #0
  //|   str PC, SAVE_PC			// Redundant (but a defined value).
  //|  bhi ->fff_fallback
  //|  ffgccheck
  //|  mov CARG1, L
  //|  mov CARG2, BASE
  //|  bl extern lj_str_fromnumber	// (lua_State *L, cTValue *o)
  //|  // Returns GCstr *.
  //|  ldr BASE, L->base
  //|  mvn CARG2, #~LJ_TSTR
  //|  b ->fff_restv
  //|
  //|//-- Base library: iterators -------------------------------------------
  //|
  //|.ffunc_1 next
  dasm_put(Dst, 856, -LJ_TISNUM, -LJ_TSTR, DISPATCH_GL(gcroot[GCROOT_BASEMT_NUM]), Dt1(->base), -LJ_TISNUM, DISPATCH_GL(gc.total), DISPATCH_GL(gc.threshold), Dt1(->base), ~LJ_TSTR);
# 994 "buildvm_arm.dasc"
  //|   mvn CARG4, #~LJ_TNIL
  //|  checktab CARG2, ->fff_fallback
  //|   strd CARG34, [BASE, NARGS8:RC]	// Set missing 2nd arg to nil.
  //|   ldr PC, [BASE, FRAME_PC]
  //|  mov CARG2, CARG1
  //|    str BASE, L->base		// Add frame since C call can throw.
  //|  mov CARG1, L
  //|    str BASE, L->top			// Dummy frame length is ok.
  //|  add CARG3, BASE, #8
  //|   str PC, SAVE_PC
  //|  bl extern lj_tab_next	// (lua_State *L, GCtab *t, TValue *key)
  //|  // Returns 0 at end of traversal.
  //|  IOS ldr BASE, L->base
  dasm_put(Dst, 908, ~LJ_TNIL, -LJ_TTAB, Dt1(->base), Dt1(->top));
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 931, Dt1(->base));
  }
# 1007 "buildvm_arm.dasc"
  //|  cmp CRET1, #0
  //|  mvneq CRET2, #~LJ_TNIL
  //|  beq ->fff_restv			// End of traversal: return nil.
  //|  ldrd CARG12, [BASE, #8]		// Copy key and value to results.
  //|   ldrd CARG34, [BASE, #16]
  //|    mov RC, #(2+1)*8
  //|  strd CARG12, [BASE, #-8]
  //|   strd CARG34, [BASE]
  //|  b ->fff_res
  //|
  //|.ffunc_1 pairs
  //|  checktab CARG2, ->fff_fallback
  dasm_put(Dst, 934, ~LJ_TNIL, (2+1)*8, -LJ_TTAB);
# 1019 "buildvm_arm.dasc"
#ifdef LUAJIT_ENABLE_LUA52COMPAT
  //|  ldr TAB:RB, TAB:CARG1->metatable
  dasm_put(Dst, 957, Dt6(->metatable));
# 1021 "buildvm_arm.dasc"
#endif
  //|   ldrd CFUNC:CARG34, CFUNC:CARG3->upvalue[0]
  //|    ldr PC, [BASE, FRAME_PC]
  dasm_put(Dst, 960, Dt8(->upvalue[0]));
# 1024 "buildvm_arm.dasc"
#ifdef LUAJIT_ENABLE_LUA52COMPAT
  //|  cmp TAB:RB, #0
  //|  bne ->fff_fallback
  dasm_put(Dst, 964);
# 1027 "buildvm_arm.dasc"
#endif
  //|  mvn CARG2, #~LJ_TNIL
  //|    mov RC, #(3+1)*8
  //|   strd CFUNC:CARG34, [BASE, #-8]
  //|  str CARG2, [BASE, #12]
  //|  b ->fff_res
  //|
  //|.ffunc_2 ipairs_aux
  //|  checktp CARG2, LJ_TTAB
  //|  checktpeq CARG4, LJ_TISNUM
  //|  bne ->fff_fallback
  //|  ldr RB, TAB:CARG1->asize
  //|   ldr RC, TAB:CARG1->array
  //|  add CARG3, CARG3, #1
  //|    ldr PC, [BASE, FRAME_PC]
  //|  cmp CARG3, RB
  //|   add RC, RC, CARG3, lsl #3
  //|  strd CARG34, [BASE, #-8]
  //|   ldrdlo CARG12, [RC]
  //|   mov RC, #(0+1)*8
  //|  bhs >2				// Not in array part?
  //|1:
  //|   checktp CARG2, LJ_TNIL
  //|   movne RC, #(2+1)*8
  //|   strdne CARG12, [BASE]
  //|  b ->fff_res
  //|2:  // Check for empty hash part first. Otherwise call C function.
  //|  ldr RB, TAB:CARG1->hmask
  //|   mov CARG2, CARG3
  //|  cmp RB, #0
  //|  beq ->fff_res
  //|  IOS mov RA, BASE
  dasm_put(Dst, 968, ~LJ_TNIL, (3+1)*8, -LJ_TTAB, -LJ_TISNUM, Dt6(->asize), Dt6(->array), (0+1)*8, -LJ_TNIL, (2+1)*8, Dt6(->hmask));
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 1018);
  }
# 1059 "buildvm_arm.dasc"
  //|  bl extern lj_tab_getinth		// (GCtab *t, int32_t key)
  //|  // Returns cTValue * or NULL.
  //|  IOS mov BASE, RA
  dasm_put(Dst, 1020);
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 1023);
  }
# 1062 "buildvm_arm.dasc"
  //|  cmp CRET1, #0
  //|  beq ->fff_res
  //|  ldrd CARG12, [CRET1]
  //|  b <1
  //|
  //|.ffunc_1 ipairs
  //|  checktab CARG2, ->fff_fallback
  dasm_put(Dst, 1025, -LJ_TTAB);
# 1069 "buildvm_arm.dasc"
#ifdef LUAJIT_ENABLE_LUA52COMPAT
  //|  ldr TAB:RB, TAB:CARG1->metatable
  dasm_put(Dst, 1041, Dt6(->metatable));
# 1071 "buildvm_arm.dasc"
#endif
  //|   ldrd CFUNC:CARG34, CFUNC:CARG3->upvalue[0]
  //|    ldr PC, [BASE, FRAME_PC]
  dasm_put(Dst, 1044, Dt8(->upvalue[0]));
# 1074 "buildvm_arm.dasc"
#ifdef LUAJIT_ENABLE_LUA52COMPAT
  //|  cmp TAB:RB, #0
  //|  bne ->fff_fallback
  dasm_put(Dst, 1048);
# 1077 "buildvm_arm.dasc"
#endif
  //|  mov CARG1, #0
  //|  mvn CARG2, #~LJ_TISNUM
  //|    mov RC, #(3+1)*8
  //|   strd CFUNC:CARG34, [BASE, #-8]
  //|  strd CARG12, [BASE, #8]
  //|  b ->fff_res
  //|
  //|//-- Base library: catch errors ----------------------------------------
  //|
  //|.ffunc pcall
  //|  ldrb RA, [DISPATCH, #DISPATCH_GL(hookmask)]
  //|   cmp NARGS8:RC, #8
  //|   blo ->fff_fallback
  //|  tst RA, #HOOK_ACTIVE		// Remember active hook before pcall.
  //|   mov RB, BASE
  //|   add BASE, BASE, #8
  //|  moveq PC, #8+FRAME_PCALL
  //|  movne PC, #8+FRAME_PCALLH
  //|   sub NARGS8:RC, NARGS8:RC, #8
  //|  b ->vm_call_dispatch
  //|
  //|.ffunc_2 xpcall
  //|  ldrb RA, [DISPATCH, #DISPATCH_GL(hookmask)]
  //|  checkfunc CARG4, ->fff_fallback	// Traceback must be a function.
  //|   mov RB, BASE
  //|  strd CARG12, [BASE, #8]		// Swap function and traceback.
  //|   strd CARG34, [BASE]
  //|  tst RA, #HOOK_ACTIVE		// Remember active hook before pcall.
  //|   add BASE, BASE, #16
  //|  moveq PC, #16+FRAME_PCALL
  //|  movne PC, #16+FRAME_PCALLH
  //|   sub NARGS8:RC, NARGS8:RC, #16
  //|  b ->vm_call_dispatch
  //|
  //|//-- Coroutine library --------------------------------------------------
  //|
  //|.macro coroutine_resume_wrap, resume
  //|.if resume
  //|.ffunc_1 coroutine_resume
  //|  checktp CARG2, LJ_TTHREAD
  //|  bne ->fff_fallback
  //|.else
  //|.ffunc coroutine_wrap_aux
  //|  ldr L:CARG1, CFUNC:CARG3->upvalue[0].gcr
  //|.endif
  //|   ldr PC, [BASE, FRAME_PC]
  //|     str BASE, L->base
  //|  ldr CARG2, L:CARG1->top
  //|   ldrb RA, L:CARG1->status
  //|    ldr RB, L:CARG1->base
  //|  add CARG3, CARG2, NARGS8:RC
  //|  add CARG4, CARG2, RA
  //|   str PC, SAVE_PC
  //|  cmp CARG4, RB
  //|  beq ->fff_fallback
  //|   ldr CARG4, L:CARG1->maxstack
  //|    ldr RB, L:CARG1->cframe
  //|   cmp RA, #LUA_YIELD
  //|   cmpls CARG3, CARG4
  //|    cmpls RB, #0
  //|    bhi ->fff_fallback
  //|1:
  //|.if resume
  //|  sub CARG3, CARG3, #8		// Keep resumed thread in stack for GC.
  //|  add BASE, BASE, #8
  //|  sub NARGS8:RC, NARGS8:RC, #8
  //|.endif
  //|  str CARG3, L:CARG1->top
  //|  str BASE, L->top
  //|2:  // Move args to coroutine.
  //|   ldrd CARG34, [BASE, RB]
  //|  cmp RB, NARGS8:RC
  //|   strdne CARG34, [CARG2, RB]
  //|  add RB, RB, #8
  //|  bne <2
  //|
  //|  mov CARG3, #0
  //|   mov L:RA, L:CARG1
  //|  mov CARG4, #0
  //|  bl ->vm_resume			// (lua_State *L, TValue *base, 0, 0)
  //|  // Returns thread status.
  //|4:
  //|  ldr CARG3, L:RA->base
  //|    mv_vmstate CARG2, INTERP
  //|  ldr CARG4, L:RA->top
  //|    st_vmstate CARG2
  //|   cmp CRET1, #LUA_YIELD
  //|  ldr BASE, L->base
  //|   bhi >8
  //|  subs RC, CARG4, CARG3
  //|   ldr CARG1, L->maxstack
  //|   add CARG2, BASE, RC
  //|  beq >6				// No results?
  //|  cmp CARG2, CARG1
  //|   mov RB, #0
  //|  bhi >9				// Need to grow stack?
  //|
  //|  sub CARG4, RC, #8
  //|   str CARG3, L:RA->top		// Clear coroutine stack.
  //|5:  // Move results from coroutine.
  //|   ldrd CARG12, [CARG3, RB]
  //|  cmp RB, CARG4
  //|   strd CARG12, [BASE, RB]
  //|  add RB, RB, #8
  //|  bne <5
  //|6:
  //|.if resume
  //|  mvn CARG3, #~LJ_TTRUE
  //|   add RC, RC, #16
  //|7:
  //|  str CARG3, [BASE, #-4]		// Prepend true/false to results.
  //|   sub RA, BASE, #8
  //|.else
  //|   mov RA, BASE
  //|   add RC, RC, #8
  //|.endif
  //|  ands CARG1, PC, #FRAME_TYPE
  //|   str PC, SAVE_PC
  //|   str RC, SAVE_MULTRES
  //|  beq ->BC_RET_Z
  //|  b ->vm_return
  //|
  //|8:  // Coroutine returned with error (at co->top-1).
  //|.if resume
  //|  ldrd CARG12, [CARG4, #-8]!
  //|   mvn CARG3, #~LJ_TFALSE
  //|    mov RC, #(2+1)*8
  //|  str CARG4, L:RA->top		// Remove error from coroutine stack.
  //|  strd CARG12, [BASE]		// Copy error message.
  //|  b <7
  //|.else
  //|  mov CARG1, L
  //|  mov CARG2, L:RA
  //|  bl extern lj_ffh_coroutine_wrap_err  // (lua_State *L, lua_State *co)
  //|  // Never returns.
  //|.endif
  //|
  //|9:  // Handle stack expansion on return from yield.
  //|  mov CARG1, L
  //|  lsr CARG2, RC, #3
  //|  bl extern lj_state_growstack	// (lua_State *L, int n)
  //|  mov CRET1, #0
  //|  b <4
  //|.endmacro
  //|
  //|  coroutine_resume_wrap 1		// coroutine.resume
  dasm_put(Dst, 1052, ~LJ_TISNUM, (3+1)*8, DISPATCH_GL(hookmask), HOOK_ACTIVE, 8+FRAME_PCALL, 8+FRAME_PCALLH, DISPATCH_GL(hookmask), -LJ_TFUNC, HOOK_ACTIVE, 16+FRAME_PCALL, 16+FRAME_PCALLH, -LJ_TTHREAD);
  dasm_put(Dst, 1111, Dt1(->base), Dt1(->top), Dt1(->status), Dt1(->base), Dt1(->maxstack), Dt1(->cframe), LUA_YIELD, Dt1(->top), Dt1(->top), Dt1(->base), LJ_VMST_INTERP, Dt1(->top), DISPATCH_GL(vmstate), LUA_YIELD);
# 1224 "buildvm_arm.dasc"
  //|  coroutine_resume_wrap 0		// coroutine.wrap
  dasm_put(Dst, 1170, Dt1(->base), Dt1(->maxstack), Dt1(->top), ~LJ_TTRUE, FRAME_TYPE, ~LJ_TFALSE, (2+1)*8, Dt1(->top));
  dasm_put(Dst, 1230, Dt8(->upvalue[0].gcr), Dt1(->base), Dt1(->top), Dt1(->status), Dt1(->base), Dt1(->maxstack), Dt1(->cframe), LUA_YIELD, Dt1(->top), Dt1(->top), Dt1(->base), LJ_VMST_INTERP, Dt1(->top), DISPATCH_GL(vmstate), LUA_YIELD);
# 1225 "buildvm_arm.dasc"
  //|
  //|.ffunc coroutine_yield
  //|  ldr CARG1, L->cframe
  //|   add CARG2, BASE, NARGS8:RC
  //|   str BASE, L->base
  //|  tst CARG1, #CFRAME_RESUME
  //|   str CARG2, L->top
  //|    mov CRET1, #LUA_YIELD
  dasm_put(Dst, 1286, Dt1(->base), Dt1(->maxstack), Dt1(->top), FRAME_TYPE, Dt1(->cframe), Dt1(->base), CFRAME_RESUME, Dt1(->top));
# 1233 "buildvm_arm.dasc"
  //|   mov CARG3, #0
  //|  beq ->fff_fallback
  //|   str CARG3, L->cframe
  //|    strb CRET1, L->status
  //|  b ->vm_leave_unw
  //|
  //|//-- Math library -------------------------------------------------------
  //|
  //|.macro math_round, func
  //|  .ffunc_1 math_ .. func
  //|  checktp CARG2, LJ_TISNUM
  //|  beq ->fff_restv
  //|  bhi ->fff_fallback
  //|  // Round FP value and normalize result.
  //|  lsl CARG3, CARG2, #1
  //|  adds RB, CARG3, #0x00200000
  //|  bpl >2				// |x| < 1?
  //|  mvn CARG4, #0x3e0
  //|    subs RB, CARG4, RB, asr #21
  //|  lsl CARG4, CARG2, #11
  //|   lsl CARG3, CARG1, #11
  //|  orr CARG4, CARG4, #0x80000000
  //|   rsb INS, RB, #32
  //|  orr CARG4, CARG4, CARG1, lsr #21
  //|    bls >3				// |x| >= 2^31?
  //|   orr CARG3, CARG3, CARG4, lsl INS
  //|  lsr CARG1, CARG4, RB
  //|.if "func" == "floor"
  //|   tst CARG3, CARG2, asr #31
  //|   addne CARG1, CARG1, #1
  //|.else
  //|   bics CARG3, CARG3, CARG2, asr #31
  //|   addsne CARG1, CARG1, #1
  //|   ldrdvs CARG12, >9
  //|   bvs ->fff_restv
  //|.endif
  //|    cmp CARG2, #0
  //|    rsblt CARG1, CARG1, #0
  //|1:
  //|   mvn CARG2, #~LJ_TISNUM
  //|  b ->fff_restv
  //|
  //|2:  // |x| < 1
  //|  orr CARG3, CARG3, CARG1		// ztest = abs(hi) | lo
  //|.if "func" == "floor"
  //|  tst CARG3, CARG2, asr #31		// return (ztest & sign) == 0 ? 0 : -1
  //|  moveq CARG1, #0
  //|  mvnne CARG1, #0
  //|.else
  //|  bics CARG3, CARG3, CARG2, asr #31	// return (ztest & ~sign) == 0 ? 0 : 1
  //|  moveq CARG1, #0
  //|  movne CARG1, #1
  //|.endif
  //|  mvn CARG2, #~LJ_TISNUM
  //|  b ->fff_restv
  //|
  //|3:  // |x| >= 2^31. Check for x == -(2^31).
  //|  cmpeq CARG4, #0x80000000
  //|.if "func" == "floor"
  //|  cmpeq CARG3, #0
  //|.endif
  //|  bne >4
  //|  cmp CARG2, #0
  //|  movmi CARG1, #0x80000000
  //|  bmi <1
  //|4:
  //|  // NYI: Use internal implementation.
  //|  IOS mov RA, BASE
  //|  bl extern func
  //|  IOS mov BASE, RA
  //|  b ->fff_restv
  //|.endmacro
  //|
  //|  math_round floor
  dasm_put(Dst, 1345, LUA_YIELD, Dt1(->cframe), Dt1(->status), -LJ_TISNUM, ~LJ_TISNUM, ~LJ_TISNUM);
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 1411);
  }
  dasm_put(Dst, 1413);
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 1416);
  }
# 1307 "buildvm_arm.dasc"
  //|  math_round ceil
  dasm_put(Dst, 1418, -LJ_TISNUM, ~LJ_TISNUM, ~LJ_TISNUM);
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 1478);
  }
  dasm_put(Dst, 1480);
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 1483);
  }
# 1308 "buildvm_arm.dasc"
  //|
  //|.align 8
  //|9:
  //|  .long 0x00000000, 0x41e00000	// 2^31.
  //|
  //|.ffunc_1 math_abs
  //|  checktp CARG2, LJ_TISNUM
  //|  bhi ->fff_fallback
  //|  bicne CARG2, CARG2, #0x80000000
  //|  bne ->fff_restv
  //|  cmp CARG1, #0
  //|  rsbslt CARG1, CARG1, #0
  //|  ldrdvs CARG12, <9
  //|  // Fallthrough.
  //|
  //|->fff_restv:
  //|  // CARG12 = TValue result.
  //|  ldr PC, [BASE, FRAME_PC]
  //|  strd CARG12, [BASE, #-8]
  //|->fff_res1:
  //|  // PC = return.
  //|  mov RC, #(1+1)*8
  //|->fff_res:
  //|  // RC = (nresults+1)*8, PC = return.
  //|  ands CARG1, PC, #FRAME_TYPE
  //|  ldreq INS, [PC, #-4]
  //|   str RC, SAVE_MULTRES
  //|  sub RA, BASE, #8
  //|  bne ->vm_return
  //|  decode_RB8 RB, INS
  //|5:
  //|  cmp RB, RC				// More results expected?
  //|  bhi >6
  //|  decode_RA8 CARG1, INS
  //|   ins_next1
  //|   ins_next2
  //|  // Adjust BASE. KBASE is assumed to be set for the calling frame.
  //|  sub BASE, RA, CARG1
  //|   ins_next3
  //|
  //|6:  // Fill up results with nil.
  //|  add CARG2, RA, RC
  //|  mvn CARG1, #~LJ_TNIL
  //|   add RC, RC, #8
  //|  str CARG1, [CARG2, #-4]
  //|  b <5
  //|
  //|.macro math_extern, func
  //|  .ffunc_n math_ .. func
  //|  IOS mov RA, BASE
  //|  bl extern func
  //|  IOS mov BASE, RA
  //|  b ->fff_restv
  //|.endmacro
  //|
  //|.macro math_extern2, func
  //|  .ffunc_nn math_ .. func
  //|  IOS mov RA, BASE
  //|  bl extern func
  //|  IOS mov BASE, RA
  //|  b ->fff_restv
  //|.endmacro
  //|
  //|  math_extern sqrt
  dasm_put(Dst, 1485, -LJ_TISNUM, (1+1)*8, FRAME_TYPE, ~LJ_TNIL);
  dasm_put(Dst, 1549, -LJ_TISNUM);
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 1554);
  }
  dasm_put(Dst, 1556);
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 1559);
  }
# 1372 "buildvm_arm.dasc"
  //|  math_extern log
  dasm_put(Dst, 1561, -LJ_TISNUM);
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 1573);
  }
  dasm_put(Dst, 1575);
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 1578);
  }
# 1373 "buildvm_arm.dasc"
  //|  math_extern log10
  dasm_put(Dst, 1580, -LJ_TISNUM);
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 1592);
  }
  dasm_put(Dst, 1594);
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 1597);
  }
# 1374 "buildvm_arm.dasc"
  //|  math_extern exp
  dasm_put(Dst, 1599, -LJ_TISNUM);
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 1611);
  }
  dasm_put(Dst, 1613);
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 1616);
  }
# 1375 "buildvm_arm.dasc"
  //|  math_extern sin
  dasm_put(Dst, 1618, -LJ_TISNUM);
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 1630);
  }
  dasm_put(Dst, 1632);
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 1635);
  }
# 1376 "buildvm_arm.dasc"
  //|  math_extern cos
  dasm_put(Dst, 1637, -LJ_TISNUM);
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 1649);
  }
  dasm_put(Dst, 1651);
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 1654);
  }
# 1377 "buildvm_arm.dasc"
  //|  math_extern tan
  dasm_put(Dst, 1656, -LJ_TISNUM);
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 1668);
  }
  dasm_put(Dst, 1670);
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 1673);
  }
# 1378 "buildvm_arm.dasc"
  //|  math_extern asin
  dasm_put(Dst, 1675, -LJ_TISNUM);
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 1687);
  }
  dasm_put(Dst, 1689);
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 1692);
  }
# 1379 "buildvm_arm.dasc"
  //|  math_extern acos
  dasm_put(Dst, 1694, -LJ_TISNUM);
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 1706);
  }
  dasm_put(Dst, 1708);
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 1711);
  }
# 1380 "buildvm_arm.dasc"
  //|  math_extern atan
  dasm_put(Dst, 1713, -LJ_TISNUM);
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 1725);
  }
  dasm_put(Dst, 1727);
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 1730);
  }
# 1381 "buildvm_arm.dasc"
  //|  math_extern sinh
  dasm_put(Dst, 1732, -LJ_TISNUM);
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 1744);
  }
  dasm_put(Dst, 1746);
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 1749);
  }
# 1382 "buildvm_arm.dasc"
  //|  math_extern cosh
  dasm_put(Dst, 1751, -LJ_TISNUM);
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 1763);
  }
  dasm_put(Dst, 1765);
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 1768);
  }
# 1383 "buildvm_arm.dasc"
  //|  math_extern tanh
  dasm_put(Dst, 1770, -LJ_TISNUM);
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 1782);
  }
  dasm_put(Dst, 1784);
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 1787);
  }
# 1384 "buildvm_arm.dasc"
  //|  math_extern2 pow
  dasm_put(Dst, 1789, -LJ_TISNUM, -LJ_TISNUM);
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 1804);
  }
  dasm_put(Dst, 1806);
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 1809);
  }
# 1385 "buildvm_arm.dasc"
  //|  math_extern2 atan2
  dasm_put(Dst, 1811, -LJ_TISNUM, -LJ_TISNUM);
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 1826);
  }
  dasm_put(Dst, 1828);
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 1831);
  }
# 1386 "buildvm_arm.dasc"
  //|  math_extern2 fmod
  dasm_put(Dst, 1833, -LJ_TISNUM, -LJ_TISNUM);
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 1848);
  }
  dasm_put(Dst, 1850);
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 1853);
  }
# 1387 "buildvm_arm.dasc"
  //|
  //|->ff_math_deg:
  //|.ffunc_n math_rad
  //|  ldrd CARG34, CFUNC:CARG3->upvalue[0]
  //|  bl extern __aeabi_dmul
  //|  b ->fff_restv
  //|
  //|.ffunc_2 math_ldexp
  //|  checktp CARG2, LJ_TISNUM
  //|  bhs ->fff_fallback
  //|  checktp CARG4, LJ_TISNUM
  //|  bne ->fff_fallback
  //|  IOS mov RA, BASE
  dasm_put(Dst, 1855, -LJ_TISNUM, Dt8(->upvalue[0]), -LJ_TISNUM, -LJ_TISNUM);
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 1888);
  }
# 1400 "buildvm_arm.dasc"
  //|  bl extern ldexp			// (double x, int exp)
  //|  IOS mov BASE, RA
  dasm_put(Dst, 1890);
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 1893);
  }
# 1402 "buildvm_arm.dasc"
  //|  b ->fff_restv
  //|
  //|.ffunc_n math_frexp
  //|  mov CARG3, sp
  //|  IOS mov RA, BASE
  dasm_put(Dst, 1895, -LJ_TISNUM);
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 1908);
  }
# 1407 "buildvm_arm.dasc"
  //|  bl extern frexp
  //|  IOS mov BASE, RA
  dasm_put(Dst, 1910);
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 1913);
  }
# 1409 "buildvm_arm.dasc"
  //|   ldr CARG3, [sp]
  //|   mvn CARG4, #~LJ_TISNUM
  //|    ldr PC, [BASE, FRAME_PC]
  //|  strd CARG12, [BASE, #-8]
  //|    mov RC, #(2+1)*8
  //|   strd CARG34, [BASE]
  //|  b ->fff_res
  //|
  //|.ffunc_n math_modf
  //|  sub CARG3, BASE, #8
  //|   ldr PC, [BASE, FRAME_PC]
  //|  IOS mov RA, BASE
  dasm_put(Dst, 1915, ~LJ_TISNUM, (2+1)*8, -LJ_TISNUM);
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 1937);
  }
# 1421 "buildvm_arm.dasc"
  //|  bl extern modf
  //|  IOS mov BASE, RA
  dasm_put(Dst, 1939);
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 1942);
  }
# 1423 "buildvm_arm.dasc"
  //|   mov RC, #(2+1)*8
  //|  strd CARG12, [BASE]
  //|  b ->fff_res
  //|
  //|.macro math_minmax, name, cond, fcond
  //|  .ffunc_1 name
  //|  checktp CARG2, LJ_TISNUM
  //|   mov RA, #8
  //|  bne >4
  //|1:  // Handle integers.
  //|  ldrd CARG34, [BASE, RA]
  //|   cmp RA, RC
  //|   bhs ->fff_restv
  //|  checktp CARG4, LJ_TISNUM
  //|  bne >3
  //|  cmp CARG1, CARG3
  //|   add RA, RA, #8
  //|  mov..cond CARG1, CARG3
  //|  b <1
  //|3:
  //|  bhi ->fff_fallback
  //|  // Convert intermediate result to number and continue below.
  //|  bl extern __aeabi_i2d
  //|  ldrd CARG34, [BASE, RA]
  //|  b >6
  //|
  //|4:
  //|  bhi ->fff_fallback
  //|5:  // Handle numbers.
  //|  ldrd CARG34, [BASE, RA]
  //|   cmp RA, RC
  //|   bhs ->fff_restv
  //|  checktp CARG4, LJ_TISNUM
  //|  bhs >7
  //|6:
  //|  bl extern __aeabi_cdcmple
  //|   add RA, RA, #8
  //|  mov..fcond CARG1, CARG3
  //|  mov..fcond CARG2, CARG4
  //|  b <5
  //|7:  // Convert integer to number and continue above.
  //|  bhi ->fff_fallback
  //|  strd CARG12, TMPD
  //|  mov CARG1, CARG3
  //|  bl extern __aeabi_i2d
  //|  ldrd CARG34, TMPD
  //|  b <6
  //|.endmacro
  //|
  //|  math_minmax math_min, gt, hi
  dasm_put(Dst, 1944, (2+1)*8, -LJ_TISNUM, -LJ_TISNUM, -LJ_TISNUM);
# 1473 "buildvm_arm.dasc"
  //|  math_minmax math_max, lt, lo
  dasm_put(Dst, 1995, -LJ_TISNUM, -LJ_TISNUM);
# 1474 "buildvm_arm.dasc"
  //|
  //|//-- String library -----------------------------------------------------
  //|
  //|.ffunc_1 string_len
  //|  checkstr CARG2, ->fff_fallback
  //|  ldr CARG1, STR:CARG1->len
  //|  mvn CARG2, #~LJ_TISNUM
  //|  b ->fff_restv
  //|
  //|.ffunc string_byte			// Only handle the 1-arg case here.
  //|  ldrd CARG12, [BASE]
  //|    ldr PC, [BASE, FRAME_PC]
  //|   cmp NARGS8:RC, #8
  //|   checktpeq CARG2, LJ_TSTR		// Need exactly 1 argument.
  //|   bne ->fff_fallback
  //|  ldr CARG3, STR:CARG1->len
  //|   ldrb CARG1, STR:CARG1[1]		// Access is always ok (NUL at end).
  //|   mvn CARG2, #~LJ_TISNUM
  dasm_put(Dst, 2049, -LJ_TISNUM, -LJ_TSTR, Dt5(->len), ~LJ_TISNUM, -LJ_TSTR, Dt5(->len), Dt5([1]));
# 1492 "buildvm_arm.dasc"
  //|  cmp CARG3, #0
  //|  moveq RC, #(0+1)*8
  //|  movne RC, #(1+1)*8
  //|   strd CARG12, [BASE, #-8]
  //|  b ->fff_res
  //|
  //|.ffunc string_char			// Only handle the 1-arg case here.
  //|  ffgccheck
  //|  ldrd CARG12, [BASE]
  //|    ldr PC, [BASE, FRAME_PC]
  //|   cmp NARGS8:RC, #8			// Need exactly 1 argument.
  //|   checktpeq CARG2, LJ_TISNUM
  //|   bicseq CARG4, CARG1, #255
  //|  mov CARG3, #1
  //|   bne ->fff_fallback
  //|  str CARG1, TMPD
  //|  mov CARG2, TMPDp			// Points to stack. Little-endian.
  //|->fff_newstr:
  //|  // CARG2 = str, CARG3 = len.
  //|   str BASE, L->base
  //|  mov CARG1, L
  //|   str PC, SAVE_PC
  //|  bl extern lj_str_new		// (lua_State *L, char *str, size_t l)
  //|  // Returns GCstr *.
  //|  ldr BASE, L->base
  //|   mvn CARG2, #~LJ_TSTR
  //|  b ->fff_restv
  //|
  //|.ffunc string_sub
  //|  ffgccheck
  //|  ldrd CARG12, [BASE]
  //|   ldrd CARG34, [BASE, #16]
  //|    cmp NARGS8:RC, #16
  //|     mvn RB, #0
  //|    beq >1
  //|    blo ->fff_fallback
  //|   checktp CARG4, LJ_TISNUM
  dasm_put(Dst, 2103, ~LJ_TISNUM, (0+1)*8, (1+1)*8, DISPATCH_GL(gc.total), DISPATCH_GL(gc.threshold), -LJ_TISNUM, Dt1(->base), Dt1(->base), ~LJ_TSTR, DISPATCH_GL(gc.total), DISPATCH_GL(gc.threshold));
# 1529 "buildvm_arm.dasc"
  //|    mov RB, CARG3
  //|   bne ->fff_fallback
  //|1:
  //|  ldr CARG34, [BASE, #8]
  //|  checktp CARG2, LJ_TSTR
  //|   ldreq CARG2, STR:CARG1->len
  //|  checktpeq CARG4, LJ_TISNUM
  //|  bne ->fff_fallback
  //|  // CARG1 = str, CARG2 = str->len, CARG3 = start, RB = end
  //|  add CARG4, CARG2, #1
  //|  cmp CARG3, #0			// if (start < 0) start += len+1
  //|  addlt CARG3, CARG3, CARG4
  //|  cmp CARG3, #1			// if (start < 1) start = 1
  //|  movlt CARG3, #1
  //|  cmp RB, #0				// if (end < 0) end += len+1
  //|  addlt RB, RB, CARG4
  //|  bic RB, RB, RB, asr #31		// if (end < 0) end = 0
  //|  cmp RB, CARG2			// if (end > len) end = len
  //|   add CARG1, STR:CARG1, #sizeof(GCstr)-1
  //|  movgt RB, CARG2
  //|   add CARG2, CARG1, CARG3
  //|  subs CARG3, RB, CARG3		// len = start - end
  //|   add CARG3, CARG3, #1		// len += 1
  //|  bge ->fff_newstr
  //|->fff_emptystr:
  //|  sub STR:CARG1, DISPATCH, #-DISPATCH_GL(strempty)
  //|  mvn CARG2, #~LJ_TSTR
  //|  b ->fff_restv
  //|
  //|.ffunc string_rep			// Only handle the 1-char case inline.
  //|  ffgccheck
  //|  ldrd CARG12, [BASE]
  //|   ldrd CARG34, [BASE, #8]
  //|    cmp NARGS8:RC, #16
  //|    blo ->fff_fallback
  //|  checktp CARG2, LJ_TSTR
  //|   checktpeq CARG4, LJ_TISNUM
  //|   bne ->fff_fallback
  //|  subs CARG4, CARG3, #1
  //|   ldr CARG2, STR:CARG1->len
  //|  blt ->fff_emptystr			// Count <= 0?
  dasm_put(Dst, 2162, -LJ_TISNUM, -LJ_TSTR, Dt5(->len), -LJ_TISNUM, sizeof(GCstr)-1, -DISPATCH_GL(strempty), ~LJ_TSTR, DISPATCH_GL(gc.total), DISPATCH_GL(gc.threshold), -LJ_TSTR, -LJ_TISNUM, Dt5(->len));
# 1570 "buildvm_arm.dasc"
  //|   cmp CARG2, #1
  //|   blo ->fff_emptystr		// Zero-length string?
  //|   bne ->fff_fallback		// Fallback for > 1-char strings.
  //|  ldr RB, [DISPATCH, #DISPATCH_GL(tmpbuf.sz)]
  //|   ldr CARG2, [DISPATCH, #DISPATCH_GL(tmpbuf.buf)]
  //|   ldr CARG1, STR:CARG1[1]
  //|  cmp RB, CARG3
  //|  blo ->fff_fallback
  //|1:  // Fill buffer with char.
  //|   strb CARG1, [CARG2, CARG4]
  //|  subs CARG4, CARG4, #1
  //|  bge <1
  //|  b ->fff_newstr
  //|
  //|.ffunc string_reverse
  //|  ffgccheck
  //|  ldrd CARG12, [BASE]
  //|   cmp NARGS8:RC, #8
  //|   blo ->fff_fallback
  //|  checkstr CARG2, ->fff_fallback
  //|  ldr CARG3, STR:CARG1->len
  //|   ldr RB, [DISPATCH, #DISPATCH_GL(tmpbuf.sz)]
  //|    ldr CARG2, [DISPATCH, #DISPATCH_GL(tmpbuf.buf)]
  //|  mov CARG4, CARG3
  //|  add CARG1, STR:CARG1, #sizeof(GCstr)
  //|   cmp RB, CARG3
  //|   blo ->fff_fallback
  //|1:  // Reverse string copy.
  //|  ldrb RB, [CARG1], #1
  dasm_put(Dst, 2224, DISPATCH_GL(tmpbuf.sz), DISPATCH_GL(tmpbuf.buf), Dt5([1]), DISPATCH_GL(gc.total), DISPATCH_GL(gc.threshold), -LJ_TSTR, Dt5(->len), DISPATCH_GL(tmpbuf.sz), DISPATCH_GL(tmpbuf.buf), sizeof(GCstr));
# 1599 "buildvm_arm.dasc"
  //|   subs CARG4, CARG4, #1
  //|   blt ->fff_newstr
  //|  strb RB, [CARG2, CARG4]
  //|  b <1
  //|
  //|.macro ffstring_case, name, lo
  //|  .ffunc name
  //|  ffgccheck
  //|  ldrd CARG12, [BASE]
  //|   cmp NARGS8:RC, #8
  //|   blo ->fff_fallback
  //|  checkstr CARG2, ->fff_fallback
  //|  ldr CARG3, STR:CARG1->len
  //|   ldr RB, [DISPATCH, #DISPATCH_GL(tmpbuf.sz)]
  //|    ldr CARG2, [DISPATCH, #DISPATCH_GL(tmpbuf.buf)]
  //|  mov CARG4, #0
  //|  add CARG1, STR:CARG1, #sizeof(GCstr)
  //|   cmp RB, CARG3
  //|   blo ->fff_fallback
  //|1:  // ASCII case conversion.
  //|  ldrb RB, [CARG1, CARG4]
  //|   cmp CARG4, CARG3
  //|   bhs ->fff_newstr
  //|  sub RC, RB, #lo
  //|  cmp RC, #26
  //|  eorlo RB, RB, #0x20
  //|  strb RB, [CARG2, CARG4]
  //|   add CARG4, CARG4, #1
  //|  b <1
  //|.endmacro
  //|
  //|ffstring_case string_lower, 65
  //|ffstring_case string_upper, 97
  dasm_put(Dst, 2277, DISPATCH_GL(gc.total), DISPATCH_GL(gc.threshold), -LJ_TSTR, Dt5(->len), DISPATCH_GL(tmpbuf.sz), DISPATCH_GL(tmpbuf.buf), sizeof(GCstr), DISPATCH_GL(gc.total), DISPATCH_GL(gc.threshold));
# 1632 "buildvm_arm.dasc"
  //|
  //|//-- Table library ------------------------------------------------------
  //|
  //|.ffunc_1 table_getn
  //|  checktab CARG2, ->fff_fallback
  //|  IOS mov RA, BASE
  dasm_put(Dst, 2337, -LJ_TSTR, Dt5(->len), DISPATCH_GL(tmpbuf.sz), DISPATCH_GL(tmpbuf.buf), sizeof(GCstr), -LJ_TTAB);
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 2375);
  }
# 1638 "buildvm_arm.dasc"
  //|  bl extern lj_tab_len		// (GCtab *t)
  //|  // Returns uint32_t (but less than 2^31).
  //|  IOS mov BASE, RA
  dasm_put(Dst, 2377);
  if (LJ_TARGET_OSX) {
  dasm_put(Dst, 2380);
  }
# 1641 "buildvm_arm.dasc"
  //|  mvn CARG2, #~LJ_TISNUM
  //|  b ->fff_restv
  //|
  //|//-- Bit library --------------------------------------------------------
  //|
  //|// FP number to bit conversion for soft-float. Clobbers r0-r3.
  //|->vm_tobit_fb:
  //|  bhi ->fff_fallback
  //|->vm_tobit:
  //|  lsl RB, CARG2, #1
  //|  adds RB, RB, #0x00200000
  //|  movpl CARG1, #0			// |x| < 1?
  //|  bxpl lr
  //|  mvn CARG4, #0x3e0
  //|  subs RB, CARG4, RB, asr #21
  //|  bmi >1				// |x| >= 2^32?
  //|  lsl CARG4, CARG2, #11
  //|  orr CARG4, CARG4, #0x80000000
  //|  orr CARG4, CARG4, CARG1, lsr #21
  //|   cmp CARG2, #0
  //|  lsr CARG1, CARG4, RB
  //|   rsblt CARG1, CARG1, #0
  //|  bx lr
  //|1:
  //|  add RB, RB, #21
  //|  lsr CARG4, CARG1, RB
  //|  rsb RB, RB, #20
  //|  lsl CARG1, CARG2, #12
  //|   cmp CARG2, #0
  //|  orr CARG1, CARG4, CARG1, lsl RB
  //|   rsblt CARG1, CARG1, #0
  //|  bx lr
  //|
  //|.macro .ffunc_bit, name
  //|  .ffunc_1 bit_..name
  //|  checktp CARG2, LJ_TISNUM
  //|  blne ->vm_tobit_fb
  //|.endmacro
  //|
  //|.ffunc_bit tobit
  //|  mvn CARG2, #~LJ_TISNUM
  //|  b ->fff_restv
  //|
  //|.macro .ffunc_bit_op, name, ins
  //|  .ffunc_bit name
  //|  mov CARG3, CARG1
  //|  mov RA, #8
  //|1:
  //|  ldrd CARG12, [BASE, RA]
  //|   cmp RA, NARGS8:RC
  //|    add RA, RA, #8
  //|   bge >2
  //|  checktp CARG2, LJ_TISNUM
  //|  blne ->vm_tobit_fb
  //|  ins CARG3, CARG3, CARG1
  //|  b <1
  //|.endmacro
  //|
  //|.ffunc_bit_op band, and
  //|.ffunc_bit_op bor, orr
  dasm_put(Dst, 2382, ~LJ_TISNUM, -LJ_TISNUM, ~LJ_TISNUM, -LJ_TISNUM, -LJ_TISNUM);
# 1701 "buildvm_arm.dasc"
  //|.ffunc_bit_op bxor, eor
  //|
  //|2:
  //|  mvn CARG4, #~LJ_TISNUM
  //|   ldr PC, [BASE, FRAME_PC]
  //|  strd CARG34, [BASE, #-8]
  //|  b ->fff_res1
  //|
  //|.ffunc_bit bswap
  dasm_put(Dst, 2453, -LJ_TISNUM, -LJ_TISNUM, -LJ_TISNUM, -LJ_TISNUM, ~LJ_TISNUM);
# 1710 "buildvm_arm.dasc"
  //|  eor CARG3, CARG1, CARG1, ror #16
  //|  bic CARG3, CARG3, #0x00ff0000
  //|  ror CARG1, CARG1, #8
  //|   mvn CARG2, #~LJ_TISNUM
  //|  eor CARG1, CARG1, CARG3, lsr #8
  //|  b ->fff_restv
  //|
  //|.ffunc_bit bnot
  //|  mvn CARG1, CARG1
  //|  mvn CARG2, #~LJ_TISNUM
  //|  b ->fff_restv
  //|
  //|.macro .ffunc_bit_sh, name, ins, shmod
  //|  .ffunc bit_..name
  //|  ldrd CARG12, [BASE, #8]
  //|   cmp NARGS8:RC, #16
  //|   blo ->fff_fallback
  //|  checktp CARG2, LJ_TISNUM
  //|  blne ->vm_tobit_fb
  //|.if shmod == 0
  //|  and RA, CARG1, #31
  //|.else
  //|  rsb RA, CARG1, #0
  //|.endif
  //|  ldrd CARG12, [BASE]
  //|  checktp CARG2, LJ_TISNUM
  //|  blne ->vm_tobit_fb
  //|  ins CARG1, CARG1, RA
  //|  mvn CARG2, #~LJ_TISNUM
  //|  b ->fff_restv
  //|.endmacro
  //|
  //|.ffunc_bit_sh lshift, lsl, 0
  //|.ffunc_bit_sh rshift, lsr, 0
  dasm_put(Dst, 2513, -LJ_TISNUM, ~LJ_TISNUM, -LJ_TISNUM, ~LJ_TISNUM, -LJ_TISNUM, -LJ_TISNUM, ~LJ_TISNUM, -LJ_TISNUM);
# 1744 "buildvm_arm.dasc"
  //|.ffunc_bit_sh arshift, asr, 0
  //|.ffunc_bit_sh rol, ror, 1
  //|.ffunc_bit_sh ror, ror, 0
  dasm_put(Dst, 2569, -LJ_TISNUM, ~LJ_TISNUM, -LJ_TISNUM, -LJ_TISNUM, ~LJ_TISNUM, -LJ_TISNUM, -LJ_TISNUM, ~LJ_TISNUM);
# 1747 "buildvm_arm.dasc"
  //|
  //|//-----------------------------------------------------------------------
  //|
  //|->fff_fallback:			// Call fast function fallback handler.
  //|  // BASE = new base, RC = nargs*8
  //|   ldr CARG3, [BASE, FRAME_FUNC]
  //|  ldr CARG2, L->maxstack
  //|  add CARG1, BASE, NARGS8:RC
  //|    ldr PC, [BASE, FRAME_PC]		// Fallback may overwrite PC.
  //|  str CARG1, L->top
  //|   ldr CARG3, CFUNC:CARG3->f
  //|    str BASE, L->base
  //|  add CARG1, CARG1, #8*LUA_MINSTACK
  //|    str PC, SAVE_PC			// Redundant (but a defined value).
  //|  cmp CARG1, CARG2
  //|   mov CARG1, L
  //|  bhi >5				// Need to grow stack.
  //|   blx CARG3				// (lua_State *L)
  //|  // Either throws an error, or recovers and returns -1, 0 or nresults+1.
  //|   ldr BASE, L->base
  //|  cmp CRET1, #0
  //|   lsl RC, CRET1, #3
  //|   sub RA, BASE, #8
  //|  bgt ->fff_res			// Returned nresults+1?
  //|1:  // Returned 0 or -1: retry fast path.
  //|   ldr CARG1, L->top
  //|    ldr LFUNC:CARG3, [BASE, FRAME_FUNC]
  //|   sub NARGS8:RC, CARG1, BASE
  //|  bne ->vm_call_tail			// Returned -1?
  //|  ins_callt				// Returned 0: retry fast path.
  //|
  //|// Reconstruct previous base for vmeta_call during tailcall.
  //|->vm_call_tail:
  //|  ands CARG1, PC, #FRAME_TYPE
  //|   bic CARG2, PC, #FRAME_TYPEP
  //|  ldreq INS, [PC, #-4]
  dasm_put(Dst, 2626, -LJ_TISNUM, -LJ_TISNUM, ~LJ_TISNUM, Dt1(->maxstack), Dt1(->top), Dt8(->f), Dt1(->base), 8*LUA_MINSTACK, Dt1(->base), Dt1(->top), Dt7(->field_pc), FRAME_TYPE, FRAME_TYPEP);
# 1783 "buildvm_arm.dasc"
  //|  andeq CARG2, MASKR8, INS, lsr #5	// Conditional decode_RA8.
  //|  sub RB, BASE, CARG2
  //|  b ->vm_call_dispatch		// Resolve again for tailcall.
  //|
  //|5:  // Grow stack for fallback handler.
  //|  mov CARG2, #LUA_MINSTACK
  //|  bl extern lj_state_growstack	// (lua_State *L, int n)
  //|  ldr BASE, L->base
  //|  cmp CARG1, CARG1			// Set zero-flag to force retry.
  //|  b <1
  //|
  //|->fff_gcstep:			// Call GC step function.
  //|  // BASE = new base, RC = nargs*8
  //|  mov RA, lr
  //|   str BASE, L->base
  //|  add CARG2, BASE, NARGS8:RC
  //|   str PC, SAVE_PC			// Redundant (but a defined value).
  //|  str CARG2, L->top
  //|  mov CARG1, L
  //|  bl extern lj_gc_step		// (lua_State *L)
  //|   ldr BASE, L->base
  //|  mov lr, RA				// Help return address predictor.
  //|   ldr CFUNC:CARG3, [BASE, FRAME_FUNC]
  //|  bx lr
  //|
  //|//-----------------------------------------------------------------------
  //|//-- Special dispatch targets -------------------------------------------
  //|//-----------------------------------------------------------------------
  //|
  //|->vm_record:				// Dispatch target for recording phase.
  dasm_put(Dst, 2689, LUA_MINSTACK, Dt1(->base), Dt1(->base), Dt1(->top), Dt1(->base));
# 1813 "buildvm_arm.dasc"
#if LJ_HASJIT
  //|  NYI
  dasm_put(Dst, 2723);
# 1815 "buildvm_arm.dasc"
#endif
  //|
  //|->vm_rethook:			// Dispatch target for return hooks.
  //|  ldrb CARG1, [DISPATCH, #DISPATCH_GL(hookmask)]
  //|  tst CARG1, #HOOK_ACTIVE		// Hook already active?
  //|  beq >1
  //|5:  // Re-dispatch to static ins.
  //|  decode_OP OP, INS
  //|  add OP, DISPATCH, OP, lsl #2
  //|  ldr pc, [OP, #GG_DISP2STATIC]
  //|
  //|->vm_inshook:			// Dispatch target for instr/line hooks.
  //|  ldrb CARG1, [DISPATCH, #DISPATCH_GL(hookmask)]
  //|   ldr CARG2, [DISPATCH, #DISPATCH_GL(hookcount)]
  //|  tst CARG1, #HOOK_ACTIVE		// Hook already active?
  //|  bne <5
  //|  tst CARG1, #LUA_MASKLINE|LUA_MASKCOUNT
  //|  beq <5
  //|   subs CARG2, CARG2, #1
  //|   str CARG2, [DISPATCH, #DISPATCH_GL(hookcount)]
  //|   beq >1
  //|  tst CARG1, #LUA_MASKLINE
  //|  beq <5
  //|1:
  //|  mov CARG1, L
  //|   str BASE, L->base
  //|  mov CARG2, PC
  //|  // SAVE_PC must hold the _previous_ PC. The callee updates it with PC.
  //|  bl extern lj_dispatch_ins		// (lua_State *L, const BCIns *pc)
  //|3:
  //|  ldr BASE, L->base
  //|4:  // Re-dispatch to static ins.
  //|  ldrb OP, [PC, #-4]
  dasm_put(Dst, 2725, DISPATCH_GL(hookmask), HOOK_ACTIVE, GG_DISP2STATIC, DISPATCH_GL(hookmask), DISPATCH_GL(hookcount), HOOK_ACTIVE, LUA_MASKLINE|LUA_MASKCOUNT, DISPATCH_GL(hookcount), LUA_MASKLINE, Dt1(->base), Dt1(->base));
# 1848 "buildvm_arm.dasc"
  //|   ldr INS, [PC, #-4]
  //|  add OP, DISPATCH, OP, lsl #2
  //|  ldr OP, [OP, #GG_DISP2STATIC]
  //|   decode_RA8 RA, INS
  //|   decode_RD RC, INS
  //|  bx OP
  //|
  //|->cont_hook:				// Continue from hook yield.
  //|  ldr CARG1, [CARG4, #-24]
  //|   add PC, PC, #4
  //|  str CARG1, SAVE_MULTRES		// Restore MULTRES for *M ins.
  //|  b <4
  //|
  //|->vm_hotloop:			// Hot loop counter underflow.
  dasm_put(Dst, 2771, GG_DISP2STATIC);
# 1862 "buildvm_arm.dasc"
#if LJ_HASJIT
  //|  NYI
  dasm_put(Dst, 2787);
# 1864 "buildvm_arm.dasc"
#endif
  //|
  //|->vm_callhook:			// Dispatch target for call hooks.
  //|  mov CARG2, PC
  dasm_put(Dst, 2789);
# 1868 "buildvm_arm.dasc"
#if LJ_HASJIT
  //|  b >1
  dasm_put(Dst, 2792);
# 1870 "buildvm_arm.dasc"
#endif
  //|
  //|->vm_hotcall:			// Hot call counter underflow.
  dasm_put(Dst, 2795);
# 1873 "buildvm_arm.dasc"
#if LJ_HASJIT
  //|  orr CARG2, PC, #1
  //|1:
  dasm_put(Dst, 2797);
# 1876 "buildvm_arm.dasc"
#endif
  //|  add CARG4, BASE, RC
  //|   str PC, SAVE_PC
  //|    mov CARG1, L
  //|   str BASE, L->base
  //|    sub RA, RA, BASE
  //|  str CARG4, L->top
  //|  bl extern lj_dispatch_call		// (lua_State *L, const BCIns *pc)
  //|  // Returns ASMFunction.
  //|  ldr BASE, L->base
  //|   ldr CARG4, L->top
  //|    mov CARG2, #0
  //|  add RA, BASE, RA
  //|   sub NARGS8:RC, CARG4, BASE
  //|    str CARG2, SAVE_PC		// Invalidate for subsequent line hook.
  //|  ldr LFUNC:CARG3, [BASE, FRAME_FUNC]
  //|  bx CRET1
  //|
  //|//-----------------------------------------------------------------------
  //|//-- Trace exit handler -------------------------------------------------
  //|//-----------------------------------------------------------------------
  //|
  //|->vm_exit_handler:
  dasm_put(Dst, 2800, Dt1(->base), Dt1(->top), Dt1(->base), Dt1(->top));
# 1899 "buildvm_arm.dasc"
#if LJ_HASJIT
  //|  NYI
  dasm_put(Dst, 2822);
# 1901 "buildvm_arm.dasc"
#endif
  //|->vm_exit_interp:
  dasm_put(Dst, 2824);
# 1903 "buildvm_arm.dasc"
#if LJ_HASJIT
  //|  NYI
  dasm_put(Dst, 2826);
# 1905 "buildvm_arm.dasc"
#endif
  //|
  //|//-----------------------------------------------------------------------
  //|//-- Math helper functions ----------------------------------------------
  //|//-----------------------------------------------------------------------
  //|
  //|// FP value rounding. Called from JIT code.
  //|//
  //|// double lj_vm_floor/ceil/trunc(double x);
  //|.macro vm_round, func
  //|->vm_ .. func:
  //|  NYI
  //|.endmacro
  //|
  //|  vm_round floor
  //|  vm_round ceil
  dasm_put(Dst, 2828);
# 1921 "buildvm_arm.dasc"
#if LJ_HASJIT
  //|  vm_round trunc
  dasm_put(Dst, 2833);
# 1923 "buildvm_arm.dasc"
#else
  //|->vm_trunc:
  dasm_put(Dst, 2836);
# 1925 "buildvm_arm.dasc"
#endif
  //|
  //|  // double lj_vm_mod(double dividend, double divisor);
  //|->vm_mod:
  //|  push {r0, r1, r2, r3, r4, lr}
  //|  bl extern __aeabi_ddiv
  //|  bl extern floor  // NYI: Use internal implementation of floor.
  //|  ldrd CARG34, [sp, #8]
  //|  bl extern __aeabi_dmul
  //|  ldrd CARG34, [sp]
  //|  eor CARG2, CARG2, #0x80000000
  //|  bl extern __aeabi_dadd
  //|  add sp, sp, #20
  //|  pop {pc}
  //|
  //|  // int lj_vm_modi(int dividend, int divisor);
  //|->vm_modi:
  //|  ands RB, CARG1, #0x80000000
  //|  rsbmi CARG1, CARG1, #0		// a = |dividend|
  //|  eor RB, RB, CARG2, asr #1		// Keep signdiff and sign(divisor).
  //|  cmp CARG2, #0
  //|  rsbmi CARG2, CARG2, #0		// b = |divisor|
  //|  subs CARG4, CARG2, #1
  //|  cmpne CARG1, CARG2
  //|  moveq CARG1, #0			// if (b == 1 || a == b) a = 0
  //|  tsthi CARG2, CARG4
  //|  andeq CARG1, CARG1, CARG4		// else if ((b & (b-1)) == 0) a &= b-1
  //|  bls >1
  //|  // Use repeated subtraction to get the remainder.
  //|  clz CARG3, CARG1
  //|  clz CARG4, CARG2
  //|  sub CARG4, CARG4, CARG3
  //|  rsbs CARG3, CARG4, #31		// entry = (31-(clz(b)-clz(a)))*8
  //|  addne pc, pc, CARG3, lsl #3	// Duff's device.
  //|  nop
  dasm_put(Dst, 2838);
# 1960 "buildvm_arm.dasc"
  {
    int i;
    for (i = 31; i >= 0; i--) {
      //|  cmp CARG1, CARG2, lsl #i
      //|  subhs CARG1, CARG1, CARG2, lsl #i
      dasm_put(Dst, 2874, i, i);
# 1965 "buildvm_arm.dasc"
    }
  }
  //|1:
  //|  cmp CARG1, #0
  //|  cmpne RB, #0
  //|  submi CARG1, CARG1, CARG2		// if (y != 0 && signdiff) y = y - b
  //|  eors CARG2, CARG1, RB, lsl #1
  //|  rsbmi CARG1, CARG1, #0		// if (sign(divisor) != sign(y)) y = -y
  //|  bx lr
  //|
  //|->vm_powi:
  dasm_put(Dst, 2879);
# 1976 "buildvm_arm.dasc"
#if LJ_HASJIT
  //|  NYI
  dasm_put(Dst, 2888);
# 1978 "buildvm_arm.dasc"
#endif
  //|
  //|->vm_foldfpm:
  dasm_put(Dst, 2890);
# 1981 "buildvm_arm.dasc"
#if LJ_HASJIT
  //|  NYI
  dasm_put(Dst, 2892);
# 1983 "buildvm_arm.dasc"
#endif
  //|
  //|// Callable from C: double lj_vm_foldarith(double x, double y, int op)
  //|// Compute x op y for basic arithmetic operators (+ - * / % ^ and unary -)
  //|// and basic math functions. ORDER ARITH
  //|->vm_foldarith:
  //|  ldr OP, [sp]
  //|  cmp OP, #1
  //|  blo extern __aeabi_dadd
  //|  beq extern __aeabi_dsub
  //|  cmp OP, #3
  //|  blo extern __aeabi_dmul
  //|  beq extern __aeabi_ddiv
  //|  cmp OP, #5
  //|  blo ->vm_mod
  //|  beq extern pow
  //|  cmp OP, #7
  //|  eorlo CARG2, CARG2, #0x80000000
  //|  biceq CARG2, CARG2, #0x80000000
  //|  bxls lr
  //|  NYI  // Other operations only needed by JIT compiler.
  //|
  //|//-----------------------------------------------------------------------
  //|//-- Miscellaneous functions --------------------------------------------
  //|//-----------------------------------------------------------------------
  //|
  //|//-----------------------------------------------------------------------
  //|//-- FFI helper functions -----------------------------------------------
  //|//-----------------------------------------------------------------------
  //|
  //|->vm_ffi_call:
  dasm_put(Dst, 2894);
# 2014 "buildvm_arm.dasc"
#if LJ_HASFFI
  //|  .type CCSTATE, CCallState, r4
#define DtE(_V) (int)(ptrdiff_t)&(((CCallState *)0)_V)
# 2016 "buildvm_arm.dasc"
  //|  push {CCSTATE, r5, r11, lr}
  //|  mov CCSTATE, CARG1
  //|  ldr CARG1, CCSTATE:CARG1->spadj
  //|   ldrb CARG2, CCSTATE->nsp
  //|    add CARG3, CCSTATE, #offsetof(CCallState, stack)
  //|  mov r11, sp
  //|  sub sp, sp, CARG1			// Readjust stack.
  //|   subs CARG2, CARG2, #1
  //|    ldr RB, CCSTATE->func
  //|   bmi >2
  //|1:  // Copy stack slots.
  //|  ldr CARG4, [CARG3, CARG2, lsl #2]
  //|  str CARG4, [sp, CARG2, lsl #2]
  //|  subs CARG2, CARG2, #1
  //|  bpl <1
  //|2:
  //|  ldr CARG1, CCSTATE->gpr[0]
  //|  ldr CARG2, CCSTATE->gpr[1]
  //|  ldr CARG3, CCSTATE->gpr[2]
  //|  ldr CARG4, CCSTATE->gpr[3]
  //|  blx RB
  //|  mov sp, r11
  //|  str CRET1, CCSTATE->gpr[0]
  //|  str CRET2, CCSTATE->gpr[1]
  //|  pop {CCSTATE, r5, r11, pc}
  dasm_put(Dst, 2918, DtE(->spadj), DtE(->nsp), offsetof(CCallState, stack), DtE(->func), DtE(->gpr[0]), DtE(->gpr[1]), DtE(->gpr[2]), DtE(->gpr[3]), DtE(->gpr[0]), DtE(->gpr[1]));
# 2041 "buildvm_arm.dasc"
#endif
  //|
  //|//-----------------------------------------------------------------------
}

/* Generate the code for a single instruction. */
static void build_ins(BuildCtx *ctx, BCOp op, int defop)
{
  int vk = 0;
  //|=>defop:
  dasm_put(Dst, 2956, defop);
# 2051 "buildvm_arm.dasc"

  switch (op) {

  /* -- Comparison ops ---------------------------------------------------- */

  /* Remember: all ops branch for a true comparison, fall through otherwise. */

  case BC_ISLT: case BC_ISGE: case BC_ISLE: case BC_ISGT:
    //|  // RA = src1*8, RC = src2, JMP with RC = target
    //|   lsl RC, RC, #3
    //|  ldrd CARG12, [RA, BASE]!
    //|    ldrh RB, [PC, #2]
    //|   ldrd CARG34, [RC, BASE]!
    //|    add PC, PC, #4
    //|    add RB, PC, RB, lsl #2
    //|  checktp CARG2, LJ_TISNUM
    //|  bne >3
    //|  checktp CARG4, LJ_TISNUM
    //|  bne >4
    //|  cmp CARG1, CARG3
    dasm_put(Dst, 2958, -LJ_TISNUM, -LJ_TISNUM);
# 2071 "buildvm_arm.dasc"
    if (op == BC_ISLT) {
      //|  sublt PC, RB, #0x20000
      dasm_put(Dst, 2974);
# 2073 "buildvm_arm.dasc"
    } else if (op == BC_ISGE) {
      //|  subge PC, RB, #0x20000
      dasm_put(Dst, 2976);
# 2075 "buildvm_arm.dasc"
    } else if (op == BC_ISLE) {
      //|  suble PC, RB, #0x20000
      dasm_put(Dst, 2978);
# 2077 "buildvm_arm.dasc"
    } else {
      //|  subgt PC, RB, #0x20000
      dasm_put(Dst, 2980);
# 2079 "buildvm_arm.dasc"
    }
    //|1:
    //|  ins_next
    //|
    //|3: // CARG12 is not an integer.
    //|  bhi ->vmeta_comp
    //|  // CARG12 is a number.
    //|  checktp CARG4, LJ_TISNUM
    //|  movlo RA, RB			// Save RB.
    //|  blo >5
    //|  // CARG12 is a number, CARG3 is an integer.
    //|  mov CARG1, CARG3
    //|  mov RC, RA
    //|  mov RA, RB			// Save RB.
    //|  bl extern __aeabi_i2d
    //|  mov CARG3, CARG1
    //|  mov CARG4, CARG2
    //|  ldrd CARG12, [RC]		// Restore first operand.
    //|  b >5
    //|4:  // CARG1 is an integer, CARG34 is not an integer.
    //|  bhi ->vmeta_comp
    //|  // CARG1 is an integer, CARG34 is a number
    //|  mov RA, RB			// Save RB.
    //|  bl extern __aeabi_i2d
    //|  ldrd CARG34, [RC]		// Restore second operand.
    //|5:  // CARG12 and CARG34 are numbers.
    //|  bl extern __aeabi_cdcmple
    //|  // To preserve NaN semantics GE/GT branch on unordered, but LT/LE don't.
    dasm_put(Dst, 2982, -LJ_TISNUM);
# 2107 "buildvm_arm.dasc"
    if (op == BC_ISLT) {
      //|  sublo PC, RA, #0x20000
      dasm_put(Dst, 3018);
# 2109 "buildvm_arm.dasc"
    } else if (op == BC_ISGE) {
      //|  subhs PC, RA, #0x20000
      dasm_put(Dst, 3020);
# 2111 "buildvm_arm.dasc"
    } else if (op == BC_ISLE) {
      //|  subls PC, RA, #0x20000
      dasm_put(Dst, 3022);
# 2113 "buildvm_arm.dasc"
    } else {
      //|  subhi PC, RA, #0x20000
      dasm_put(Dst, 3024);
# 2115 "buildvm_arm.dasc"
    }
    //|  b <1
    dasm_put(Dst, 3026);
# 2117 "buildvm_arm.dasc"
    break;

  case BC_ISEQV: case BC_ISNEV:
    vk = op == BC_ISEQV;
    //|  // RA = src1*8, RC = src2, JMP with RC = target
    //|   lsl RC, RC, #3
    //|  ldrd CARG12, [RA, BASE]!
    //|    ldrh RB, [PC, #2]
    //|   ldrd CARG34, [RC, BASE]!
    //|    add PC, PC, #4
    //|    add RB, PC, RB, lsl #2
    //|  checktp CARG2, LJ_TISNUM
    //|  cmnls CARG4, #-LJ_TISNUM
    dasm_put(Dst, 3029, -LJ_TISNUM, -LJ_TISNUM);
# 2130 "buildvm_arm.dasc"
    if (vk) {
      //|  bls ->BC_ISEQN_Z
      dasm_put(Dst, 3040);
# 2132 "buildvm_arm.dasc"
    } else {
      //|  bls ->BC_ISNEN_Z
      dasm_put(Dst, 3043);
# 2134 "buildvm_arm.dasc"
    }
    //|  // Either or both types are not numbers.
    if (LJ_HASFFI) {
      //|  checktp CARG2, LJ_TCDATA
      //|  checktpne CARG4, LJ_TCDATA
      //|  beq ->vmeta_equal_cd
      dasm_put(Dst, 3046, -LJ_TCDATA, -LJ_TCDATA);
# 2140 "buildvm_arm.dasc"
    }
    //|  cmp CARG2, CARG4			// Compare types.
    //|  bne >2				// Not the same type?
    //|  checktp CARG2, LJ_TISPRI
    //|  bhs >1				// Same type and primitive type?
    //|
    //|  // Same types and not a primitive type. Compare GCobj or pvalue.
    //|  cmp CARG1, CARG3
    dasm_put(Dst, 3053, -LJ_TISPRI);
# 2148 "buildvm_arm.dasc"
    if (vk) {
      //|  bne >3				// Different GCobjs or pvalues?
      //|1:  // Branch if same.
      //|  sub PC, RB, #0x20000
      //|2:  // Different.
      //|  ins_next
      //|3:
      //|  checktp CARG2, LJ_TISTABUD
      //|  bhi <2				// Different objects and not table/ud?
      dasm_put(Dst, 3062, -LJ_TISTABUD);
# 2157 "buildvm_arm.dasc"
    } else {
      //|  beq >1				// Same GCobjs or pvalues?
      //|  checktp CARG2, LJ_TISTABUD
      //|  bhi >2				// Different objects and not table/ud?
      dasm_put(Dst, 3079, -LJ_TISTABUD);
# 2161 "buildvm_arm.dasc"
    }
    //|  // Different tables or userdatas. Need to check __eq metamethod.
    //|  // Field metatable must be at same offset for GCtab and GCudata!
    //|  ldr TAB:RA, TAB:CARG1->metatable
    //|  cmp TAB:RA, #0
    dasm_put(Dst, 3086, Dt6(->metatable));
# 2166 "buildvm_arm.dasc"
    if (vk) {
      //|  beq <2			// No metatable?
      dasm_put(Dst, 3090);
# 2168 "buildvm_arm.dasc"
    } else {
      //|  beq >2			// No metatable?
      dasm_put(Dst, 3093);
# 2170 "buildvm_arm.dasc"
    }
    //|  ldrb RA, TAB:RA->nomm
    //|   mov CARG4, #1-vk		// ne = 0 or 1.
    //|   mov CARG2, CARG1
    //|  tst RA, #1<<MM_eq
    //|  beq ->vmeta_equal		// 'no __eq' flag not set?
    dasm_put(Dst, 3096, Dt6(->nomm), 1-vk, 1<<MM_eq);
# 2176 "buildvm_arm.dasc"
    if (!vk) {
      //|2:  // Branch if different.
      //|  sub PC, RB, #0x20000
      //|1:  // Same.
      //|  ins_next
      dasm_put(Dst, 3106);
# 2181 "buildvm_arm.dasc"
    }
    break;

  case BC_ISEQS: case BC_ISNES:
    vk = op == BC_ISEQS;
    //|  // RA = src*8, RC = str_const (~), JMP with RC = target
    //|   mvn RC, RC
    //|  ldrd CARG12, [BASE, RA]
    //|    ldrh RB, [PC, #2]
    //|   ldr STR:CARG3, [KBASE, RC, lsl #2]
    //|    add PC, PC, #4
    //|    add RB, PC, RB, lsl #2
    //|  checktp CARG2, LJ_TSTR
    dasm_put(Dst, 3116, -LJ_TSTR);
# 2194 "buildvm_arm.dasc"
    if (LJ_HASFFI) {
      //|  bne >7
      //|  cmp CARG1, CARG3
      dasm_put(Dst, 3125);
# 2197 "buildvm_arm.dasc"
    } else {
      //|  cmpeq CARG1, CARG3
      dasm_put(Dst, 3129);
# 2199 "buildvm_arm.dasc"
    }
    if (vk) {
      //|  subeq PC, RB, #0x20000
      //|1:
      dasm_put(Dst, 3131);
# 2203 "buildvm_arm.dasc"
    } else {
      //|1:
      //|  subne PC, RB, #0x20000
      dasm_put(Dst, 3134);
# 2206 "buildvm_arm.dasc"
    }
    //|  ins_next
    //|
    dasm_put(Dst, 3137);
# 2209 "buildvm_arm.dasc"
    if (LJ_HASFFI) {
      //|7:
      //|  checktp CARG2, LJ_TCDATA
      //|  bne <1
      //|  b ->vmeta_equal_cd
      dasm_put(Dst, 3144, -LJ_TCDATA);
# 2214 "buildvm_arm.dasc"
    }
    break;

  case BC_ISEQN: case BC_ISNEN:
    vk = op == BC_ISEQN;
    //|  // RA = src*8, RC = num_const (~), JMP with RC = target
    //|   lsl RC, RC, #3
    //|  ldrd CARG12, [RA, BASE]!
    //|    ldrh RB, [PC, #2]
    //|   ldrd CARG34, [RC, KBASE]!
    //|    add PC, PC, #4
    //|    add RB, PC, RB, lsl #2
    dasm_put(Dst, 3152);
# 2226 "buildvm_arm.dasc"
    if (vk) {
      //|->BC_ISEQN_Z:
      dasm_put(Dst, 3159);
# 2228 "buildvm_arm.dasc"
    } else {
      //|->BC_ISNEN_Z:
      dasm_put(Dst, 3161);
# 2230 "buildvm_arm.dasc"
    }
    //|  checktp CARG2, LJ_TISNUM
    //|  bne >3
    //|  checktp CARG4, LJ_TISNUM
    //|  bne >4
    //|  cmp CARG1, CARG3
    dasm_put(Dst, 3163, -LJ_TISNUM, -LJ_TISNUM);
# 2236 "buildvm_arm.dasc"
    if (vk) {
      //|  subeq PC, RB, #0x20000
      //|1:
      dasm_put(Dst, 3173);
# 2239 "buildvm_arm.dasc"
    } else {
      //|1:
      //|  subne PC, RB, #0x20000
      dasm_put(Dst, 3176);
# 2242 "buildvm_arm.dasc"
    }
    //|2:
    //|  ins_next
    //|
    //|3:  // CARG12 is not an integer.
    dasm_put(Dst, 3179);
# 2247 "buildvm_arm.dasc"
    if (LJ_HASFFI) {
      //|  bhi >7
      dasm_put(Dst, 3188);
# 2249 "buildvm_arm.dasc"
    } else {
      if (!vk) {
	//|  subhi PC, RB, #0x20000
	dasm_put(Dst, 3191);
# 2252 "buildvm_arm.dasc"
      }
      //|  bhi <2
      dasm_put(Dst, 3193);
# 2254 "buildvm_arm.dasc"
    }
    //|  // CARG12 is a number.
    //|  checktp CARG4, LJ_TISNUM
    //|  movlo RA, RB			// Save RB.
    //|  blo >5
    //|  // CARG12 is a number, CARG3 is an integer.
    //|  mov CARG1, CARG3
    //|  mov RC, RA
    //|4:  // CARG1 is an integer, CARG34 is a number.
    //|  mov RA, RB			// Save RB.
    //|  bl extern __aeabi_i2d
    //|  ldrd CARG34, [RC]		// Restore other operand.
    //|5:  // CARG12 and CARG34 are numbers.
    //|  bl extern __aeabi_cdcmpeq
    dasm_put(Dst, 3196, -LJ_TISNUM);
# 2268 "buildvm_arm.dasc"
    if (vk) {
      //|  subeq PC, RA, #0x20000
      dasm_put(Dst, 3212);
# 2270 "buildvm_arm.dasc"
    } else {
      //|  subne PC, RA, #0x20000
      dasm_put(Dst, 3214);
# 2272 "buildvm_arm.dasc"
    }
    //|  b <2
    //|
    dasm_put(Dst, 3216);
# 2275 "buildvm_arm.dasc"
    if (LJ_HASFFI) {
      //|7:
      //|  checktp CARG2, LJ_TCDATA
      //|  bne <1
      //|  b ->vmeta_equal_cd
      dasm_put(Dst, 3219, -LJ_TCDATA);
# 2280 "buildvm_arm.dasc"
    }
    break;

  case BC_ISEQP: case BC_ISNEP:
    vk = op == BC_ISEQP;
    //|  // RA = src*8, RC = primitive_type (~), JMP with RC = target
    //|  ldrd CARG12, [BASE, RA]
    //|   ldrh RB, [PC, #2]
    //|   add PC, PC, #4
    //|  mvn RC, RC
    //|   add RB, PC, RB, lsl #2
    dasm_put(Dst, 3227);
# 2291 "buildvm_arm.dasc"
    if (LJ_HASFFI) {
      //|  checktp CARG2, LJ_TCDATA
      //|  beq ->vmeta_equal_cd
      dasm_put(Dst, 3233, -LJ_TCDATA);
# 2294 "buildvm_arm.dasc"
    }
    //|  cmp CARG2, RC
    dasm_put(Dst, 3238);
# 2296 "buildvm_arm.dasc"
    if (vk) {
      //|  subeq PC, RB, #0x20000
      dasm_put(Dst, 3240);
# 2298 "buildvm_arm.dasc"
    } else {
      //|  subne PC, RB, #0x20000
      dasm_put(Dst, 3242);
# 2300 "buildvm_arm.dasc"
    }
    //|  ins_next
    dasm_put(Dst, 3244);
# 2302 "buildvm_arm.dasc"
    break;

  /* -- Unary test and copy ops ------------------------------------------- */

  case BC_ISTC: case BC_ISFC: case BC_IST: case BC_ISF:
    //|  // RA = dst*8 or unused, RC = src, JMP with RC = target
    //|  add RC, BASE, RC, lsl #3
    //|   ldrh RB, [PC, #2]
    //|  ldrd CARG12, [RC]
    //|   add PC, PC, #4
    //|   add RB, PC, RB, lsl #2
    //|  checktp CARG2, LJ_TTRUE
    dasm_put(Dst, 3251, -LJ_TTRUE);
# 2314 "buildvm_arm.dasc"
    if (op == BC_ISTC || op == BC_IST) {
      //|  subls PC, RB, #0x20000
      dasm_put(Dst, 3259);
# 2316 "buildvm_arm.dasc"
      if (op == BC_ISTC) {
	//|  strdls CARG12, [BASE, RA]
	dasm_put(Dst, 3261);
# 2318 "buildvm_arm.dasc"
      }
    } else {
      //|  subhi PC, RB, #0x20000
      dasm_put(Dst, 3263);
# 2321 "buildvm_arm.dasc"
      if (op == BC_ISFC) {
	//|  strdhi CARG12, [BASE, RA]
	dasm_put(Dst, 3265);
# 2323 "buildvm_arm.dasc"
      }
    }
    //|  ins_next
    dasm_put(Dst, 3267);
# 2326 "buildvm_arm.dasc"
    break;

  /* -- Unary ops --------------------------------------------------------- */

  case BC_MOV:
    //|  // RA = dst*8, RC = src
    //|  lsl RC, RC, #3
    //|   ins_next1
    //|  ldrd CARG12, [BASE, RC]
    //|   ins_next2
    //|  strd CARG12, [BASE, RA]
    //|   ins_next3
    dasm_put(Dst, 3274);
# 2338 "buildvm_arm.dasc"
    break;
  case BC_NOT:
    //|  // RA = dst*8, RC = src
    //|  add RC, BASE, RC, lsl #3
    //|   ins_next1
    //|  ldr CARG1, [RC, #4]
    //|   add RA, BASE, RA
    //|   ins_next2
    //|  checktp CARG1, LJ_TTRUE
    //|  mvnls CARG2, #~LJ_TFALSE
    //|  mvnhi CARG2, #~LJ_TTRUE
    //|  str CARG2, [RA, #4]
    //|   ins_next3
    dasm_put(Dst, 3284, -LJ_TTRUE, ~LJ_TFALSE, ~LJ_TTRUE);
# 2351 "buildvm_arm.dasc"
    break;
  case BC_UNM:
    //|  // RA = dst*8, RC = src
    //|  lsl RC, RC, #3
    //|  ldrd CARG12, [BASE, RC]
    //|   ins_next1
    //|   ins_next2
    //|  checktp CARG2, LJ_TISNUM
    //|  bhi ->vmeta_unm
    //|  eorne CARG2, CARG2, #0x80000000
    //|  bne >5
    //|  rsbseq CARG1, CARG1, #0
    //|  ldrdvs CARG12, >9
    //|5:
    //|  strd CARG12, [BASE, RA]
    //|   ins_next3
    //|
    //|.align 8
    //|9:
    //|  .long 0x00000000, 0x41e00000	// 2^31.
    dasm_put(Dst, 3301, -LJ_TISNUM);
# 2371 "buildvm_arm.dasc"
    break;
  case BC_LEN:
    //|  // RA = dst*8, RC = src
    //|  lsl RC, RC, #3
    //|  ldrd CARG12, [BASE, RC]
    //|  checkstr CARG2, >2
    //|  ldr CARG1, STR:CARG1->len
    //|1:
    //|  mvn CARG2, #~LJ_TISNUM
    //|   ins_next1
    //|   ins_next2
    //|  strd CARG12, [BASE, RA]
    //|   ins_next3
    //|2:
    //|  checktab CARG2, ->vmeta_len
    //|  IOS mov RC, BASE
    dasm_put(Dst, 3327, -LJ_TSTR, Dt5(->len), ~LJ_TISNUM, -LJ_TTAB);
    if (LJ_TARGET_OSX) {
    dasm_put(Dst, 3351);
    }
# 2387 "buildvm_arm.dasc"
    //|  bl extern lj_tab_len		// (GCtab *t)
    //|  // Returns uint32_t (but less than 2^31).
    //|  IOS mov BASE, RC
    dasm_put(Dst, 3353);
    if (LJ_TARGET_OSX) {
    dasm_put(Dst, 3356);
    }
# 2390 "buildvm_arm.dasc"
    //|  b <1
    dasm_put(Dst, 3358);
# 2391 "buildvm_arm.dasc"
    break;

  /* -- Binary ops -------------------------------------------------------- */

    //|.macro ins_arithcheck, cond, ncond, target
    //||if (vk == 1) {
    //|   cmn CARG4, #-LJ_TISNUM
    //|    cmn..cond CARG2, #-LJ_TISNUM
    //||} else {
    //|   cmn CARG2, #-LJ_TISNUM
    //|    cmn..cond CARG4, #-LJ_TISNUM
    //||}
    //|  b..ncond target
    //|.endmacro
    //|.macro ins_arithcheck_int, target
    //|  ins_arithcheck eq, ne, target
    //|.endmacro
    //|.macro ins_arithcheck_num, target
    //|  ins_arithcheck lo, hs, target
    //|.endmacro
    //|
    //|.macro ins_arithpre
    //|  decode_RB8 RB, INS
    //|   decode_RC8 RC, INS
    //|  // RA = dst*8, RB = src1*8, RC = src2*8 | num_const*8
    //||vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
    //||switch (vk) {
    //||case 0:
    //|   ldrd CARG12, [BASE, RB]
    //|    ldrd CARG34, [KBASE, RC]
    //||  break;
    //||case 1:
    //|   ldrd CARG34, [BASE, RB]
    //|    ldrd CARG12, [KBASE, RC]
    //||  break;
    //||default:
    //|   ldrd CARG12, [BASE, RB]
    //|    ldrd CARG34, [BASE, RC]
    //||  break;
    //||}
    //|.endmacro
    //|
    //|.macro ins_arithfallback, ins
    //||switch (vk) {
    //||case 0:
    //|   ins ->vmeta_arith_vn
    //||  break;
    //||case 1:
    //|   ins ->vmeta_arith_nv
    //||  break;
    //||default:
    //|   ins ->vmeta_arith_vv
    //||  break;
    //||}
    //|.endmacro
    //|
    //|.macro ins_arithdn, intins, fpcall
    //|  ins_arithpre
    //|.if "intins" ~= "vm_modi"
    //|   ins_next1
    //|.endif
    //|  ins_arithcheck_int >5
    //|.if "intins" == "smull"
    //|  smull CARG1, RC, CARG3, CARG1
    //|  cmp RC, CARG1, asr #31
    //|  ins_arithfallback bne
    //|.elif "intins" == "vm_modi"
    //|  movs CARG2, CARG3
    //|  ins_arithfallback beq
    //|  bl ->vm_modi
    //|  mvn CARG2, #~LJ_TISNUM
    //|.else
    //|  intins CARG1, CARG1, CARG3
    //|  ins_arithfallback bvs
    //|.endif
    //|4:
    //|.if "intins" == "vm_modi"
    //|   ins_next1
    //|.endif
    //|   ins_next2
    //|  strd CARG12, [BASE, RA]
    //|   ins_next3
    //|5:  // FP variant.
    //|  ins_arithfallback ins_arithcheck_num
    //|.if "intins" == "vm_modi"
    //|  IOS mov RC, BASE
    //|  bl fpcall
    //|  IOS mov BASE, RC  // NYI: remove once we use internal impl. of floor.
    //|.else
    //|  bl fpcall
    //|   ins_next1
    //|.endif
    //|  b <4
    //|.endmacro
    //|
    //|.macro ins_arithfp, fpcall
    //|  ins_arithpre
    //|  ins_arithfallback ins_arithcheck_num
    //|.if "fpcall" == "extern pow"
    //|  IOS mov RC, BASE
    //|  bl fpcall
    //|  IOS mov BASE, RC
    //|.else
    //|  bl fpcall
    //|.endif
    //|   ins_next1
    //|   ins_next2
    //|  strd CARG12, [BASE, RA]
    //|   ins_next3
    //|.endmacro

  case BC_ADDVN: case BC_ADDNV: case BC_ADDVV:
    //|  ins_arithdn adds, extern __aeabi_dadd
    dasm_put(Dst, 3361);
    vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
    switch (vk) {
    case 0:
    dasm_put(Dst, 3364);
      break;
    case 1:
    dasm_put(Dst, 3367);
      break;
    default:
    dasm_put(Dst, 3370);
      break;
    }
    dasm_put(Dst, 3373);
    if (vk == 1) {
    dasm_put(Dst, 3375, -LJ_TISNUM, -LJ_TISNUM);
    } else {
    dasm_put(Dst, 3380, -LJ_TISNUM, -LJ_TISNUM);
    }
    dasm_put(Dst, 3385);
    switch (vk) {
    case 0:
    dasm_put(Dst, 3389);
      break;
    case 1:
    dasm_put(Dst, 3392);
      break;
    default:
    dasm_put(Dst, 3395);
      break;
    }
    dasm_put(Dst, 3398);
    switch (vk) {
    case 0:
    if (vk == 1) {
    dasm_put(Dst, 3407, -LJ_TISNUM, -LJ_TISNUM);
    } else {
    dasm_put(Dst, 3412, -LJ_TISNUM, -LJ_TISNUM);
    }
    dasm_put(Dst, 3417);
      break;
    case 1:
    if (vk == 1) {
    dasm_put(Dst, 3420, -LJ_TISNUM, -LJ_TISNUM);
    } else {
    dasm_put(Dst, 3425, -LJ_TISNUM, -LJ_TISNUM);
    }
    dasm_put(Dst, 3430);
      break;
    default:
    if (vk == 1) {
    dasm_put(Dst, 3433, -LJ_TISNUM, -LJ_TISNUM);
    } else {
    dasm_put(Dst, 3438, -LJ_TISNUM, -LJ_TISNUM);
    }
    dasm_put(Dst, 3443);
      break;
    }
    dasm_put(Dst, 3446);
# 2504 "buildvm_arm.dasc"
    break;
  case BC_SUBVN: case BC_SUBNV: case BC_SUBVV:
    //|  ins_arithdn subs, extern __aeabi_dsub
    dasm_put(Dst, 3452);
    vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
    switch (vk) {
    case 0:
    dasm_put(Dst, 3455);
      break;
    case 1:
    dasm_put(Dst, 3458);
      break;
    default:
    dasm_put(Dst, 3461);
      break;
    }
    dasm_put(Dst, 3464);
    if (vk == 1) {
    dasm_put(Dst, 3466, -LJ_TISNUM, -LJ_TISNUM);
    } else {
    dasm_put(Dst, 3471, -LJ_TISNUM, -LJ_TISNUM);
    }
    dasm_put(Dst, 3476);
    switch (vk) {
    case 0:
    dasm_put(Dst, 3480);
      break;
    case 1:
    dasm_put(Dst, 3483);
      break;
    default:
    dasm_put(Dst, 3486);
      break;
    }
    dasm_put(Dst, 3489);
    switch (vk) {
    case 0:
    if (vk == 1) {
    dasm_put(Dst, 3498, -LJ_TISNUM, -LJ_TISNUM);
    } else {
    dasm_put(Dst, 3503, -LJ_TISNUM, -LJ_TISNUM);
    }
    dasm_put(Dst, 3508);
      break;
    case 1:
    if (vk == 1) {
    dasm_put(Dst, 3511, -LJ_TISNUM, -LJ_TISNUM);
    } else {
    dasm_put(Dst, 3516, -LJ_TISNUM, -LJ_TISNUM);
    }
    dasm_put(Dst, 3521);
      break;
    default:
    if (vk == 1) {
    dasm_put(Dst, 3524, -LJ_TISNUM, -LJ_TISNUM);
    } else {
    dasm_put(Dst, 3529, -LJ_TISNUM, -LJ_TISNUM);
    }
    dasm_put(Dst, 3534);
      break;
    }
    dasm_put(Dst, 3537);
# 2507 "buildvm_arm.dasc"
    break;
  case BC_MULVN: case BC_MULNV: case BC_MULVV:
    //|  ins_arithdn smull, extern __aeabi_dmul
    dasm_put(Dst, 3543);
    vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
    switch (vk) {
    case 0:
    dasm_put(Dst, 3546);
      break;
    case 1:
    dasm_put(Dst, 3549);
      break;
    default:
    dasm_put(Dst, 3552);
      break;
    }
    dasm_put(Dst, 3555);
    if (vk == 1) {
    dasm_put(Dst, 3557, -LJ_TISNUM, -LJ_TISNUM);
    } else {
    dasm_put(Dst, 3562, -LJ_TISNUM, -LJ_TISNUM);
    }
    dasm_put(Dst, 3567);
    switch (vk) {
    case 0:
    dasm_put(Dst, 3572);
      break;
    case 1:
    dasm_put(Dst, 3575);
      break;
    default:
    dasm_put(Dst, 3578);
      break;
    }
    dasm_put(Dst, 3581);
    switch (vk) {
    case 0:
    if (vk == 1) {
    dasm_put(Dst, 3590, -LJ_TISNUM, -LJ_TISNUM);
    } else {
    dasm_put(Dst, 3595, -LJ_TISNUM, -LJ_TISNUM);
    }
    dasm_put(Dst, 3600);
      break;
    case 1:
    if (vk == 1) {
    dasm_put(Dst, 3603, -LJ_TISNUM, -LJ_TISNUM);
    } else {
    dasm_put(Dst, 3608, -LJ_TISNUM, -LJ_TISNUM);
    }
    dasm_put(Dst, 3613);
      break;
    default:
    if (vk == 1) {
    dasm_put(Dst, 3616, -LJ_TISNUM, -LJ_TISNUM);
    } else {
    dasm_put(Dst, 3621, -LJ_TISNUM, -LJ_TISNUM);
    }
    dasm_put(Dst, 3626);
      break;
    }
    dasm_put(Dst, 3629);
# 2510 "buildvm_arm.dasc"
    break;
  case BC_DIVVN: case BC_DIVNV: case BC_DIVVV:
    //|  ins_arithfp extern __aeabi_ddiv
    dasm_put(Dst, 3635);
    vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
    switch (vk) {
    case 0:
    dasm_put(Dst, 3638);
      break;
    case 1:
    dasm_put(Dst, 3641);
      break;
    default:
    dasm_put(Dst, 3644);
      break;
    }
    switch (vk) {
    case 0:
    if (vk == 1) {
    dasm_put(Dst, 3647, -LJ_TISNUM, -LJ_TISNUM);
    } else {
    dasm_put(Dst, 3652, -LJ_TISNUM, -LJ_TISNUM);
    }
    dasm_put(Dst, 3657);
      break;
    case 1:
    if (vk == 1) {
    dasm_put(Dst, 3660, -LJ_TISNUM, -LJ_TISNUM);
    } else {
    dasm_put(Dst, 3665, -LJ_TISNUM, -LJ_TISNUM);
    }
    dasm_put(Dst, 3670);
      break;
    default:
    if (vk == 1) {
    dasm_put(Dst, 3673, -LJ_TISNUM, -LJ_TISNUM);
    } else {
    dasm_put(Dst, 3678, -LJ_TISNUM, -LJ_TISNUM);
    }
    dasm_put(Dst, 3683);
      break;
    }
    dasm_put(Dst, 3686);
# 2513 "buildvm_arm.dasc"
    break;
  case BC_MODVN: case BC_MODNV: case BC_MODVV:
    //|  ins_arithdn vm_modi, ->vm_mod
    dasm_put(Dst, 3696);
    vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
    switch (vk) {
    case 0:
    dasm_put(Dst, 3699);
      break;
    case 1:
    dasm_put(Dst, 3702);
      break;
    default:
    dasm_put(Dst, 3705);
      break;
    }
    if (vk == 1) {
    dasm_put(Dst, 3708, -LJ_TISNUM, -LJ_TISNUM);
    } else {
    dasm_put(Dst, 3713, -LJ_TISNUM, -LJ_TISNUM);
    }
    dasm_put(Dst, 3718);
    switch (vk) {
    case 0:
    dasm_put(Dst, 3722);
      break;
    case 1:
    dasm_put(Dst, 3725);
      break;
    default:
    dasm_put(Dst, 3728);
      break;
    }
    dasm_put(Dst, 3731, ~LJ_TISNUM);
    switch (vk) {
    case 0:
    if (vk == 1) {
    dasm_put(Dst, 3745, -LJ_TISNUM, -LJ_TISNUM);
    } else {
    dasm_put(Dst, 3750, -LJ_TISNUM, -LJ_TISNUM);
    }
    dasm_put(Dst, 3755);
      break;
    case 1:
    if (vk == 1) {
    dasm_put(Dst, 3758, -LJ_TISNUM, -LJ_TISNUM);
    } else {
    dasm_put(Dst, 3763, -LJ_TISNUM, -LJ_TISNUM);
    }
    dasm_put(Dst, 3768);
      break;
    default:
    if (vk == 1) {
    dasm_put(Dst, 3771, -LJ_TISNUM, -LJ_TISNUM);
    } else {
    dasm_put(Dst, 3776, -LJ_TISNUM, -LJ_TISNUM);
    }
    dasm_put(Dst, 3781);
      break;
    }
    if (LJ_TARGET_OSX) {
    dasm_put(Dst, 3784);
    }
    dasm_put(Dst, 3786);
    if (LJ_TARGET_OSX) {
    dasm_put(Dst, 3789);
    }
    dasm_put(Dst, 3791);
# 2516 "buildvm_arm.dasc"
    break;
  case BC_POW:
    //|  // NYI: (partial) integer arithmetic.
    //|  ins_arithfp extern pow
    dasm_put(Dst, 3794);
    vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
    switch (vk) {
    case 0:
    dasm_put(Dst, 3797);
      break;
    case 1:
    dasm_put(Dst, 3800);
      break;
    default:
    dasm_put(Dst, 3803);
      break;
    }
    switch (vk) {
    case 0:
    if (vk == 1) {
    dasm_put(Dst, 3806, -LJ_TISNUM, -LJ_TISNUM);
    } else {
    dasm_put(Dst, 3811, -LJ_TISNUM, -LJ_TISNUM);
    }
    dasm_put(Dst, 3816);
      break;
    case 1:
    if (vk == 1) {
    dasm_put(Dst, 3819, -LJ_TISNUM, -LJ_TISNUM);
    } else {
    dasm_put(Dst, 3824, -LJ_TISNUM, -LJ_TISNUM);
    }
    dasm_put(Dst, 3829);
      break;
    default:
    if (vk == 1) {
    dasm_put(Dst, 3832, -LJ_TISNUM, -LJ_TISNUM);
    } else {
    dasm_put(Dst, 3837, -LJ_TISNUM, -LJ_TISNUM);
    }
    dasm_put(Dst, 3842);
      break;
    }
    if (LJ_TARGET_OSX) {
    dasm_put(Dst, 3845);
    }
    dasm_put(Dst, 3847);
    if (LJ_TARGET_OSX) {
    dasm_put(Dst, 3850);
    }
    dasm_put(Dst, 3852);
# 2520 "buildvm_arm.dasc"
    break;

  case BC_CAT:
    //|  decode_RB8 RC, INS
    //|   decode_RC8 RB, INS
    //|  // RA = dst*8, RC = src_start*8, RB = src_end*8  (note: RB/RC swapped!)
    //|  sub CARG3, RB, RC
    //|   str BASE, L->base
    //|  add CARG2, BASE, RB
    //|->BC_CAT_Z:
    //|  // RA = dst*8, RC = src_start*8, CARG2 = top-1
    //|  mov CARG1, L
    //|   str PC, SAVE_PC
    //|  lsr CARG3, CARG3, #3
    //|  bl extern lj_meta_cat		// (lua_State *L, TValue *top, int left)
    //|  // Returns NULL (finished) or TValue * (metamethod).
    //|  ldr BASE, L->base
    //|  cmp CRET1, #0
    //|  bne ->vmeta_binop
    //|  ldrd CARG34, [BASE, RC]
    //|   ins_next1
    //|   ins_next2
    //|  strd CARG34, [BASE, RA]		// Copy result to RA.
    //|   ins_next3
    dasm_put(Dst, 3860, Dt1(->base), Dt1(->base));
# 2544 "buildvm_arm.dasc"
    break;

  /* -- Constant ops ------------------------------------------------------ */

  case BC_KSTR:
    //|  // RA = dst*8, RC = str_const (~)
    //|  mvn RC, RC
    //|   ins_next1
    //|  ldr CARG1, [KBASE, RC, lsl #2]
    //|  mvn CARG2, #~LJ_TSTR
    //|   ins_next2
    //|  strd CARG12, [BASE, RA]
    //|   ins_next3
    dasm_put(Dst, 3886, ~LJ_TSTR);
# 2557 "buildvm_arm.dasc"
    break;
  case BC_KCDATA:
#if LJ_HASFFI
    //|  // RA = dst*8, RC = cdata_const (~)
    //|  mvn RC, RC
    //|   ins_next1
    //|  ldr CARG1, [KBASE, RC, lsl #2]
    //|  mvn CARG2, #~LJ_TCDATA
    //|   ins_next2
    //|  strd CARG12, [BASE, RA]
    //|   ins_next3
    dasm_put(Dst, 3898, ~LJ_TCDATA);
# 2568 "buildvm_arm.dasc"
#endif
    break;
  case BC_KSHORT:
    //|  // RA = dst*8, (RC = int16_literal)
    //|  mov CARG1, INS, asr #16			// Refetch sign-extended reg.
    //|  mvn CARG2, #~LJ_TISNUM
    //|   ins_next1
    //|   ins_next2
    //|  strd CARG12, [BASE, RA]
    //|   ins_next3
    dasm_put(Dst, 3910, ~LJ_TISNUM);
# 2578 "buildvm_arm.dasc"
    break;
  case BC_KNUM:
    //|  // RA = dst*8, RC = num_const
    //|  lsl RC, RC, #3
    //|   ins_next1
    //|  ldrd CARG12, [KBASE, RC]
    //|   ins_next2
    //|  strd CARG12, [BASE, RA]
    //|   ins_next3
    dasm_put(Dst, 3921);
# 2587 "buildvm_arm.dasc"
    break;
  case BC_KPRI:
    //|  // RA = dst*8, RC = primitive_type (~)
    //|  add RA, BASE, RA
    //|  mvn RC, RC
    //|   ins_next1
    //|   ins_next2
    //|  str RC, [RA, #4]
    //|   ins_next3
    dasm_put(Dst, 3931);
# 2596 "buildvm_arm.dasc"
    break;
  case BC_KNIL:
    //|  // RA = base*8, RC = end
    //|  add RA, BASE, RA
    //|   add RC, BASE, RC, lsl #3
    //|  mvn CARG1, #~LJ_TNIL
    //|  str CARG1, [RA, #4]
    //|   add RA, RA, #8
    //|1:
    //|  str CARG1, [RA, #4]
    //|  cmp RA, RC
    //|   add RA, RA, #8
    //|  blt <1
    //|  ins_next_
    dasm_put(Dst, 3941, ~LJ_TNIL);
# 2610 "buildvm_arm.dasc"
    break;

  /* -- Upvalue and function ops ------------------------------------------ */

  case BC_UGET:
    //|  // RA = dst*8, RC = uvnum
    //|  ldr LFUNC:CARG2, [BASE, FRAME_FUNC]
    //|   lsl RC, RC, #2
    //|   add RC, RC, #offsetof(GCfuncL, uvptr)
    //|  ldr UPVAL:CARG2, [LFUNC:CARG2, RC]
    //|  ldr CARG2, UPVAL:CARG2->v
    //|  ldrd CARG34, [CARG2]
    //|   ins_next1
    //|   ins_next2
    //|  strd CARG34, [BASE, RA]
    //|   ins_next3
    dasm_put(Dst, 3960, offsetof(GCfuncL, uvptr), DtA(->v));
# 2626 "buildvm_arm.dasc"
    break;
  case BC_USETV:
    //|  // RA = uvnum*8, RC = src
    //|  ldr LFUNC:CARG2, [BASE, FRAME_FUNC]
    //|   lsr RA, RA, #1
    //|   add RA, RA, #offsetof(GCfuncL, uvptr)
    //|    lsl RC, RC, #3
    //|  ldr UPVAL:CARG2, [LFUNC:CARG2, RA]
    //|    ldrd CARG34, [BASE, RC]
    //|  ldrb RB, UPVAL:CARG2->marked
    //|  ldrb RC, UPVAL:CARG2->closed
    //|    ldr CARG2, UPVAL:CARG2->v
    //|  tst RB, #LJ_GC_BLACK		// isblack(uv)
    //|   add RB, CARG4, #-LJ_TISGCV
    //|  cmpne RC, #0
    //|   strd CARG34, [CARG2]
    //|  bne >2				// Upvalue is closed and black?
    //|1:
    //|   ins_next
    //|
    //|2:  // Check if new value is collectable.
    //|  cmn RB, #-(LJ_TISNUM - LJ_TISGCV)
    //|   ldrbhi RC, GCOBJ:CARG3->gch.marked
    //|  bls <1				// tvisgcv(v)
    //|    sub CARG1, DISPATCH, #-GG_DISP2G
    //|   tst RC, #LJ_GC_WHITES
    //|  // Crossed a write barrier. Move the barrier forward.
    dasm_put(Dst, 3976, offsetof(GCfuncL, uvptr), DtA(->marked), DtA(->closed), DtA(->v), LJ_GC_BLACK, -LJ_TISGCV, -(LJ_TISNUM - LJ_TISGCV), Dt4(->gch.marked), -GG_DISP2G, LJ_GC_WHITES);
# 2653 "buildvm_arm.dasc"
    if (LJ_TARGET_OSX) {
      //|  beq <1
      //|  mov RC, BASE
      //|  bl extern lj_gc_barrieruv	// (global_State *g, TValue *tv)
      //|  mov BASE, RC
      dasm_put(Dst, 4016);
# 2658 "buildvm_arm.dasc"
    } else {
      //|  blne extern lj_gc_barrieruv	// (global_State *g, TValue *tv)
      dasm_put(Dst, 4023);
# 2660 "buildvm_arm.dasc"
    }
    //|  b <1
    dasm_put(Dst, 4026);
# 2662 "buildvm_arm.dasc"
    break;
  case BC_USETS:
    //|  // RA = uvnum*8, RC = str_const (~)
    //|  ldr LFUNC:CARG2, [BASE, FRAME_FUNC]
    //|   lsr RA, RA, #1
    //|   add RA, RA, #offsetof(GCfuncL, uvptr)
    //|    mvn RC, RC
    //|  ldr UPVAL:CARG2, [LFUNC:CARG2, RA]
    //|    ldr STR:CARG3, [KBASE, RC, lsl #2]
    //|    mvn CARG4, #~LJ_TSTR
    //|  ldrb RB, UPVAL:CARG2->marked
    //|   ldr CARG2, UPVAL:CARG2->v
    //|     ldrb RC, UPVAL:CARG2->closed
    //|  tst RB, #LJ_GC_BLACK		// isblack(uv)
    //|    ldrb RB, STR:CARG3->marked
    //|   strd CARG34, [CARG2]
    //|  bne >2
    //|1:
    //|   ins_next
    //|
    //|2:  // Check if string is white and ensure upvalue is closed.
    //|  tst RB, #LJ_GC_WHITES		// iswhite(str)
    //|  cmpne RC, #0
    //|   sub CARG1, DISPATCH, #-GG_DISP2G
    //|  // Crossed a write barrier. Move the barrier forward.
    dasm_put(Dst, 4029, offsetof(GCfuncL, uvptr), ~LJ_TSTR, DtA(->marked), DtA(->v), DtA(->closed), LJ_GC_BLACK, Dt5(->marked), LJ_GC_WHITES, -GG_DISP2G);
# 2687 "buildvm_arm.dasc"
    if (LJ_TARGET_OSX) {
      //|  beq <1
      //|  mov RC, BASE
      //|  bl extern lj_gc_barrieruv	// (global_State *g, TValue *tv)
      //|  mov BASE, RC
      dasm_put(Dst, 4065);
# 2692 "buildvm_arm.dasc"
    } else {
      //|  blne extern lj_gc_barrieruv	// (global_State *g, TValue *tv)
      dasm_put(Dst, 4072);
# 2694 "buildvm_arm.dasc"
    }
    //|  b <1
    dasm_put(Dst, 4075);
# 2696 "buildvm_arm.dasc"
    break;
  case BC_USETN:
    //|  // RA = uvnum*8, RC = num_const
    //|  ldr LFUNC:CARG2, [BASE, FRAME_FUNC]
    //|   lsr RA, RA, #1
    //|   add RA, RA, #offsetof(GCfuncL, uvptr)
    //|    lsl RC, RC, #3
    //|  ldr UPVAL:CARG2, [LFUNC:CARG2, RA]
    //|    ldrd CARG34, [KBASE, RC]
    //|  ldr CARG2, UPVAL:CARG2->v
    //|   ins_next1
    //|   ins_next2
    //|  strd CARG34, [CARG2]
    //|   ins_next3
    dasm_put(Dst, 4078, offsetof(GCfuncL, uvptr), DtA(->v));
# 2710 "buildvm_arm.dasc"
    break;
  case BC_USETP:
    //|  // RA = uvnum*8, RC = primitive_type (~)
    //|  ldr LFUNC:CARG2, [BASE, FRAME_FUNC]
    //|   lsr RA, RA, #1
    //|   add RA, RA, #offsetof(GCfuncL, uvptr)
    //|  ldr UPVAL:CARG2, [LFUNC:CARG2, RA]
    //|   mvn RC, RC
    //|  ldr CARG2, UPVAL:CARG2->v
    //|   ins_next1
    //|   ins_next2
    //|  str RC, [CARG2, #4]
    //|   ins_next3
    dasm_put(Dst, 4095, offsetof(GCfuncL, uvptr), DtA(->v));
# 2723 "buildvm_arm.dasc"
    break;

  case BC_UCLO:
    //|  // RA = level*8, RC = target
    //|  ldr CARG3, L->openupval
    //|   add RC, PC, RC, lsl #2
    //|   str BASE, L->base
    //|  cmp CARG3, #0
    //|   sub PC, RC, #0x20000
    //|  beq >1
    //|   mov CARG1, L
    //|   add CARG2, BASE, RA
    //|  bl extern lj_func_closeuv	// (lua_State *L, TValue *level)
    //|  ldr BASE, L->base
    //|1:
    //|  ins_next
    dasm_put(Dst, 4111, Dt1(->openupval), Dt1(->base), Dt1(->base));
# 2739 "buildvm_arm.dasc"
    break;

  case BC_FNEW:
    //|  // RA = dst*8, RC = proto_const (~) (holding function prototype)
    //|  mvn RC, RC
    //|   str BASE, L->base
    //|  ldr CARG2, [KBASE, RC, lsl #2]
    //|   str PC, SAVE_PC
    //|  ldr CARG3, [BASE, FRAME_FUNC]
    //|   mov CARG1, L
    //|  // (lua_State *L, GCproto *pt, GCfuncL *parent)
    //|  bl extern lj_func_newL_gc
    //|  // Returns GCfuncL *.
    //|  ldr BASE, L->base
    //|  mvn CARG2, #~LJ_TFUNC
    //|   ins_next1
    //|   ins_next2
    //|  strd CARG12, [BASE, RA]
    //|   ins_next3
    dasm_put(Dst, 4134, Dt1(->base), Dt1(->base), ~LJ_TFUNC);
# 2758 "buildvm_arm.dasc"
    break;

  /* -- Table ops --------------------------------------------------------- */

  case BC_TNEW:
  case BC_TDUP:
    //|  // RA = dst*8, RC = (hbits|asize) | tab_const (~)
    if (op == BC_TDUP) {
      //|  mvn RC, RC
      dasm_put(Dst, 4155);
# 2767 "buildvm_arm.dasc"
    }
    //|  ldr CARG3, [DISPATCH, #DISPATCH_GL(gc.total)]
    //|   ldr CARG4, [DISPATCH, #DISPATCH_GL(gc.threshold)]
    //|    str BASE, L->base
    //|    str PC, SAVE_PC
    //|  cmp CARG3, CARG4
    //|   mov CARG1, L
    //|  bhs >5
    //|1:
    dasm_put(Dst, 4157, DISPATCH_GL(gc.total), DISPATCH_GL(gc.threshold), Dt1(->base));
# 2776 "buildvm_arm.dasc"
    if (op == BC_TNEW) {
      //|  lsl CARG2, RC, #21
      //|   lsr CARG3, RC, #11
      //|  asr RC, CARG2, #21
      //|  lsr CARG2, CARG2, #21
      //|  cmn RC, #1
      //|  addeq CARG2, CARG2, #2
      //|  bl extern lj_tab_new  // (lua_State *L, int32_t asize, uint32_t hbits)
      //|  // Returns GCtab *.
      dasm_put(Dst, 4170);
# 2785 "buildvm_arm.dasc"
    } else {
      //|  ldr CARG2, [KBASE, RC, lsl #2]
      //|  bl extern lj_tab_dup  // (lua_State *L, Table *kt)
      //|  // Returns GCtab *.
      dasm_put(Dst, 4179);
# 2789 "buildvm_arm.dasc"
    }
    //|  ldr BASE, L->base
    //|  mvn CARG2, #~LJ_TTAB
    //|   ins_next1
    //|   ins_next2
    //|  strd CARG12, [BASE, RA]
    //|   ins_next3
    //|5:
    //|  bl extern lj_gc_step_fixtop  // (lua_State *L)
    //|  mov CARG1, L
    //|  b <1
    dasm_put(Dst, 4183, Dt1(->base), ~LJ_TTAB);
# 2800 "buildvm_arm.dasc"
    break;

  case BC_GGET:
    //|  // RA = dst*8, RC = str_const (~)
  case BC_GSET:
    //|  // RA = dst*8, RC = str_const (~)
    //|  ldr LFUNC:CARG2, [BASE, FRAME_FUNC]
    //|   mvn RC, RC
    //|  ldr TAB:CARG1, LFUNC:CARG2->env
    //|   ldr STR:RC, [KBASE, RC, lsl #2]
    dasm_put(Dst, 4201, Dt7(->env));
# 2810 "buildvm_arm.dasc"
    if (op == BC_GGET) {
      //|  b ->BC_TGETS_Z
      dasm_put(Dst, 4207);
# 2812 "buildvm_arm.dasc"
    } else {
      //|  b ->BC_TSETS_Z
      dasm_put(Dst, 4210);
# 2814 "buildvm_arm.dasc"
    }
    break;

  case BC_TGETV:
    //|  decode_RB8 RB, INS
    //|   decode_RC8 RC, INS
    //|  // RA = dst*8, RB = table*8, RC = key*8
    //|  ldrd TAB:CARG12, [BASE, RB]
    //|   ldrd CARG34, [BASE, RC]
    //|  checktab CARG2, ->vmeta_tgetv  // STALL: load CARG12.
    //|   checktp CARG4, LJ_TISNUM	// Integer key?
    //|  ldreq CARG4, TAB:CARG1->array
    //|    ldreq CARG2, TAB:CARG1->asize
    //|   bne >9
    //|
    //|  add CARG4, CARG4, CARG3, lsl #3
    //|    cmp CARG3, CARG2		// In array part?
    //|  ldrdlo CARG34, [CARG4]
    //|    bhs ->vmeta_tgetv
    //|   ins_next1  // Overwrites RB!
    //|  checktp CARG4, LJ_TNIL
    //|  beq >5
    //|1:
    //|   ins_next2
    //|  strd CARG34, [BASE, RA]
    //|   ins_next3
    //|
    //|5:  // Check for __index if table value is nil.
    //|  ldr TAB:CARG2, TAB:CARG1->metatable
    //|  cmp TAB:CARG2, #0
    //|  beq <1				// No metatable: done.
    //|  ldrb CARG2, TAB:CARG2->nomm
    //|  tst CARG2, #1<<MM_index
    //|  bne <1				// 'no __index' flag set: done.
    //|  decode_RB8 RB, INS		// Restore RB.
    //|  b ->vmeta_tgetv
    //|
    //|9:
    //|  checktp CARG4, LJ_TSTR		// String key?
    //|   moveq STR:RC, CARG3
    //|  beq ->BC_TGETS_Z
    //|  b ->vmeta_tgetv
    dasm_put(Dst, 4213, -LJ_TTAB, -LJ_TISNUM, Dt6(->array), Dt6(->asize), -LJ_TNIL, Dt6(->metatable), Dt6(->nomm), 1<<MM_index, -LJ_TSTR);
# 2856 "buildvm_arm.dasc"
    break;
  case BC_TGETS:
    //|  decode_RB8 RB, INS
    //|   and RC, RC, #255
    //|  // RA = dst*8, RB = table*8, RC = str_const (~)
    //|  ldrd CARG12, [BASE, RB]
    //|   mvn RC, RC
    //|   ldr STR:RC, [KBASE, RC, lsl #2]  // STALL: early RC.
    //|  checktab CARG2, ->vmeta_tgets1
    //|->BC_TGETS_Z:
    //|  // (TAB:RB =) TAB:CARG1 = GCtab *, STR:RC = GCstr *, RA = dst*8
    //|  ldr CARG3, TAB:CARG1->hmask
    //|   ldr CARG4, STR:RC->hash
    //|    ldr NODE:INS, TAB:CARG1->node
    //|     mov TAB:RB, TAB:CARG1
    //|  and CARG3, CARG3, CARG4			// idx = str->hash & tab->hmask
    //|  add CARG3, CARG3, CARG3, lsl #1
    //|    add NODE:INS, NODE:INS, CARG3, lsl #3	// node = tab->node + idx*3*8
    //|1:
    //|  ldrd CARG12, NODE:INS->key  // STALL: early NODE:INS.
    //|   ldrd CARG34, NODE:INS->val
    //|    ldr NODE:INS, NODE:INS->next
    //|  cmp CARG1, STR:RC
    //|  checktpeq CARG2, LJ_TSTR
    //|  bne >4
    //|   checktp CARG4, LJ_TNIL
    //|   beq >5
    //|3:
    //|   ins_next1
    //|   ins_next2
    //|  strd CARG34, [BASE, RA]
    //|   ins_next3
    //|
    //|4:  // Follow hash chain.
    //|  cmp NODE:INS, #0
    //|  bne <1
    //|  // End of hash chain: key not found, nil result.
    //|
    //|5:  // Check for __index if table value is nil.
    //|  ldr TAB:CARG1, TAB:RB->metatable
    //|   mov CARG3, #0  // Optional clear of undef. value (during load stall).
    //|   mvn CARG4, #~LJ_TNIL
    //|  cmp TAB:CARG1, #0
    //|  beq <3				// No metatable: done.
    //|  ldrb CARG2, TAB:CARG1->nomm
    //|  tst CARG2, #1<<MM_index
    dasm_put(Dst, 4270, -LJ_TTAB, Dt6(->hmask), Dt5(->hash), Dt6(->node), DtB(->key), DtB(->val), DtB(->next), -LJ_TSTR, -LJ_TNIL, Dt6(->metatable), ~LJ_TNIL, Dt6(->nomm));
# 2902 "buildvm_arm.dasc"
    //|  bne <3				// 'no __index' flag set: done.
    //|  b ->vmeta_tgets
    dasm_put(Dst, 4330, 1<<MM_index);
# 2904 "buildvm_arm.dasc"
    break;
  case BC_TGETB:
    //|  decode_RB8 RB, INS
    //|   and RC, RC, #255
    //|  // RA = dst*8, RB = table*8, RC = index
    //|  ldrd CARG12, [BASE, RB]
    //|  checktab CARG2, ->vmeta_tgetb  // STALL: load CARG12.
    //|   ldr CARG3, TAB:CARG1->asize
    //|  ldr CARG4, TAB:CARG1->array
    //|  lsl CARG2, RC, #3
    //|   cmp RC, CARG3
    //|  ldrdlo CARG34, [CARG4, CARG2]
    //|   bhs ->vmeta_tgetb
    //|   ins_next1  // Overwrites RB!
    //|  checktp CARG4, LJ_TNIL
    //|  beq >5
    //|1:
    //|   ins_next2
    //|  strd CARG34, [BASE, RA]
    //|   ins_next3
    //|
    //|5:  // Check for __index if table value is nil.
    //|  ldr TAB:CARG2, TAB:CARG1->metatable
    //|  cmp TAB:CARG2, #0
    //|  beq <1				// No metatable: done.
    //|  ldrb CARG2, TAB:CARG2->nomm
    //|  tst CARG2, #1<<MM_index
    //|  bne <1				// 'no __index' flag set: done.
    //|  b ->vmeta_tgetb
    dasm_put(Dst, 4337, -LJ_TTAB, Dt6(->asize), Dt6(->array), -LJ_TNIL, Dt6(->metatable), Dt6(->nomm), 1<<MM_index);
# 2933 "buildvm_arm.dasc"
    break;

  case BC_TSETV:
    //|  decode_RB8 RB, INS
    //|   decode_RC8 RC, INS
    //|  // RA = src*8, RB = table*8, RC = key*8
    //|  ldrd TAB:CARG12, [BASE, RB]
    //|   ldrd CARG34, [BASE, RC]
    //|  checktab CARG2, ->vmeta_tsetv  // STALL: load CARG12.
    //|   checktp CARG4, LJ_TISNUM	// Integer key?
    //|  ldreq CARG2, TAB:CARG1->array
    //|    ldreq CARG4, TAB:CARG1->asize
    //|   bne >9
    //|
    //|  add CARG2, CARG2, CARG3, lsl #3
    //|    cmp CARG3, CARG4		// In array part?
    //|  ldrlo INS, [CARG2, #4]
    //|    bhs ->vmeta_tsetv
    //|   ins_next1  // Overwrites RB!
    //|  checktp INS, LJ_TNIL
    //|  ldrb INS, TAB:CARG1->marked
    //|   ldrd CARG34, [BASE, RA]
    //|  beq >5
    //|1:
    //|  tst INS, #LJ_GC_BLACK		// isblack(table)
    //|   strd CARG34, [CARG2]
    //|  bne >7
    //|2:
    //|   ins_next2
    //|   ins_next3
    //|
    //|5:  // Check for __newindex if previous value is nil.
    //|  ldr TAB:RA, TAB:CARG1->metatable
    //|  cmp TAB:RA, #0
    //|  beq <1				// No metatable: done.
    //|  ldrb RA, TAB:RA->nomm
    //|  tst RA, #1<<MM_newindex
    //|  bne <1				// 'no __newindex' flag set: done.
    //|  ldr INS, [PC, #-4]		// Restore RA and RB.
    //|  decode_RB8 RB, INS
    //|  decode_RA8 RA, INS
    //|  b ->vmeta_tsetv
    //|
    //|7:  // Possible table write barrier for the value. Skip valiswhite check.
    //|  barrierback TAB:CARG1, INS, CARG3
    dasm_put(Dst, 4380, -LJ_TTAB, -LJ_TISNUM, Dt6(->array), Dt6(->asize), -LJ_TNIL, Dt6(->marked), LJ_GC_BLACK, Dt6(->metatable), Dt6(->nomm), 1<<MM_newindex);
# 2978 "buildvm_arm.dasc"
    //|  b <2
    //|
    //|9:
    //|  checktp CARG4, LJ_TSTR		// String key?
    //|   moveq STR:RC, CARG3
    //|  beq ->BC_TSETS_Z
    //|  b ->vmeta_tsetv
    dasm_put(Dst, 4440, DISPATCH_GL(gc.grayagain), LJ_GC_BLACK, DISPATCH_GL(gc.grayagain), Dt6(->marked), Dt6(->gclist), -LJ_TSTR);
# 2985 "buildvm_arm.dasc"
    break;
  case BC_TSETS:
    //|  decode_RB8 RB, INS
    //|   and RC, RC, #255
    //|  // RA = src*8, RB = table*8, RC = str_const (~)
    //|  ldrd CARG12, [BASE, RB]
    //|   mvn RC, RC
    //|   ldr STR:RC, [KBASE, RC, lsl #2]  // STALL: early RC.
    //|  checktab CARG2, ->vmeta_tsets1
    //|->BC_TSETS_Z:
    //|  // (TAB:RB =) TAB:CARG1 = GCtab *, STR:RC = GCstr *, RA = dst*8
    //|  ldr CARG3, TAB:CARG1->hmask
    //|   ldr CARG4, STR:RC->hash
    //|    ldr NODE:INS, TAB:CARG1->node
    //|     mov TAB:RB, TAB:CARG1
    //|  and CARG3, CARG3, CARG4			// idx = str->hash & tab->hmask
    //|  add CARG3, CARG3, CARG3, lsl #1
    //|   mov CARG4, #0
    //|    add NODE:INS, NODE:INS, CARG3, lsl #3	// node = tab->node + idx*3*8
    //|   strb CARG4, TAB:RB->nomm		// Clear metamethod cache.
    //|1:
    //|  ldrd CARG12, NODE:INS->key
    //|   ldr CARG4, NODE:INS->val.it
    //|    ldr NODE:CARG3, NODE:INS->next
    //|  cmp CARG1, STR:RC
    //|  checktpeq CARG2, LJ_TSTR
    //|  bne >5
    //|  ldrb CARG2, TAB:RB->marked
    //|   checktp CARG4, LJ_TNIL		// Key found, but nil value?
    //|    ldrd CARG34, [BASE, RA]
    //|   beq >4
    //|2:
    //|  tst CARG2, #LJ_GC_BLACK		// isblack(table)
    //|    strd CARG34, NODE:INS->val
    //|  bne >7
    //|3:
    //|   ins_next
    //|
    //|4:  // Check for __newindex if previous value is nil.
    //|  ldr TAB:CARG1, TAB:RB->metatable
    dasm_put(Dst, 4461, -LJ_TTAB, Dt6(->hmask), Dt5(->hash), Dt6(->node), Dt6(->nomm), DtB(->key), DtB(->val.it), DtB(->next), -LJ_TSTR, Dt6(->marked), -LJ_TNIL, LJ_GC_BLACK, DtB(->val));
# 3025 "buildvm_arm.dasc"
    //|  cmp TAB:CARG1, #0
    //|  beq <2				// No metatable: done.
    //|  ldrb CARG1, TAB:CARG1->nomm
    //|  tst CARG1, #1<<MM_newindex
    //|  bne <2				// 'no __newindex' flag set: done.
    //|  b ->vmeta_tsets
    //|
    //|5:  // Follow hash chain.
    //|  movs NODE:INS, NODE:CARG3
    //|  bne <1
    //|  // End of hash chain: key not found, add a new one.
    //|
    //|  // But check for __newindex first.
    //|  ldr TAB:CARG1, TAB:RB->metatable
    //|   mov CARG3, TMPDp
    //|   str PC, SAVE_PC
    //|  cmp TAB:CARG1, #0		// No metatable: continue.
    //|   str BASE, L->base
    //|  ldrbne CARG2, TAB:CARG1->nomm
    //|   mov CARG1, L
    //|  beq >6
    //|  tst CARG2, #1<<MM_newindex
    //|  beq ->vmeta_tsets		// 'no __newindex' flag NOT set: check.
    //|6:
    //|  mvn CARG4, #~LJ_TSTR
    //|   str STR:RC, TMPDlo
    //|   mov CARG2, TAB:RB
    //|  str CARG4, TMPDhi
    //|  bl extern lj_tab_newkey		// (lua_State *L, GCtab *t, TValue *k)
    //|  // Returns TValue *.
    //|  ldr BASE, L->base
    //|  ldrd CARG34, [BASE, RA]
    //|  strd CARG34, [CRET1]
    //|  b <3				// No 2nd write barrier needed.
    //|
    //|7:  // Possible table write barrier for the value. Skip valiswhite check.
    //|  barrierback TAB:RB, CARG2, CARG3
    dasm_put(Dst, 4519, Dt6(->metatable), Dt6(->nomm), 1<<MM_newindex, Dt6(->metatable), Dt1(->base), Dt6(->nomm), 1<<MM_newindex, ~LJ_TSTR, Dt1(->base), DISPATCH_GL(gc.grayagain), LJ_GC_BLACK);
# 3062 "buildvm_arm.dasc"
    //|  b <3
    dasm_put(Dst, 4572, DISPATCH_GL(gc.grayagain), Dt6(->marked), Dt6(->gclist));
# 3063 "buildvm_arm.dasc"
    break;
  case BC_TSETB:
    //|  decode_RB8 RB, INS
    //|   and RC, RC, #255
    //|  // RA = src*8, RB = table*8, RC = index
    //|  ldrd CARG12, [BASE, RB]
    //|  checktab CARG2, ->vmeta_tsetb  // STALL: load CARG12.
    //|   ldr CARG3, TAB:CARG1->asize
    //|  ldr RB, TAB:CARG1->array
    //|  lsl CARG2, RC, #3
    //|   cmp RC, CARG3
    //|  ldrdlo CARG34, [CARG2, RB]!
    //|   bhs ->vmeta_tsetb
    //|   ins_next1  // Overwrites RB!
    //|  checktp CARG4, LJ_TNIL
    //|  ldrb INS, TAB:CARG1->marked
    //|   ldrd CARG34, [BASE, RA]
    //|  beq >5
    //|1:
    //|  tst INS, #LJ_GC_BLACK		// isblack(table)
    //|    strd CARG34, [CARG2]
    //|  bne >7
    //|2:
    //|   ins_next2
    //|   ins_next3
    //|
    //|5:  // Check for __newindex if previous value is nil.
    //|  ldr TAB:RA, TAB:CARG1->metatable
    //|  cmp TAB:RA, #0
    //|  beq <1				// No metatable: done.
    //|  ldrb RA, TAB:RA->nomm
    //|  tst RA, #1<<MM_newindex
    //|  bne <1				// 'no __newindex' flag set: done.
    //|  ldr INS, [PC, #-4]		// Restore INS.
    //|  b ->vmeta_tsetb
    //|
    //|7:  // Possible table write barrier for the value. Skip valiswhite check.
    //|  barrierback TAB:CARG1, INS, CARG3
    dasm_put(Dst, 4581, -LJ_TTAB, Dt6(->asize), Dt6(->array), -LJ_TNIL, Dt6(->marked), LJ_GC_BLACK, Dt6(->metatable), Dt6(->nomm), 1<<MM_newindex, DISPATCH_GL(gc.grayagain), LJ_GC_BLACK);
# 3101 "buildvm_arm.dasc"
    //|  b <2
    dasm_put(Dst, 4638, DISPATCH_GL(gc.grayagain), Dt6(->marked), Dt6(->gclist));
# 3102 "buildvm_arm.dasc"
    break;

  case BC_TSETM:
    //|  // RA = base*8 (table at base-1), RC = num_const (start index)
    //|  add RA, BASE, RA
    //|1:
    //|   ldr RB, SAVE_MULTRES
    //|  ldr TAB:CARG2, [RA, #-8]		// Guaranteed to be a table.
    //|  ldr CARG1, [KBASE, RC, lsl #3]	// Integer constant is in lo-word.
    //|   subs RB, RB, #8
    //|  ldr CARG4, TAB:CARG2->asize
    //|   beq >4				// Nothing to copy?
    //|  add CARG3, CARG1, RB, lsr #3
    //|  cmp CARG3, CARG4
    //|   ldr CARG4, TAB:CARG2->array
    //|    add RB, RA, RB
    //|  bhi >5
    //|   add INS, CARG4, CARG1, lsl #3
    //|    ldrb CARG1, TAB:CARG2->marked
    //|3:  // Copy result slots to table.
    //|   ldrd CARG34, [RA], #8
    //|   strd CARG34, [INS], #8
    //|  cmp RA, RB
    //|  blo <3
    //|    tst CARG1, #LJ_GC_BLACK	// isblack(table)
    //|    bne >7
    //|4:
    //|  ins_next
    //|
    //|5:  // Need to resize array part.
    //|   str BASE, L->base
    //|  mov CARG1, L
    //|   str PC, SAVE_PC
    //|  bl extern lj_tab_reasize         // (lua_State *L, GCtab *t, int nasize)
    //|  // Must not reallocate the stack.
    //|  IOS ldr BASE, L->base
    dasm_put(Dst, 4647, Dt6(->asize), Dt6(->array), Dt6(->marked), LJ_GC_BLACK, Dt1(->base));
    if (LJ_TARGET_OSX) {
    dasm_put(Dst, 4692, Dt1(->base));
    }
# 3138 "buildvm_arm.dasc"
    //|  b <1
    //|
    //|7:  // Possible table write barrier for any value. Skip valiswhite check.
    //|  barrierback TAB:RB, CARG1, CARG2
    //|  b <4
    dasm_put(Dst, 4695, DISPATCH_GL(gc.grayagain), LJ_GC_BLACK, DISPATCH_GL(gc.grayagain), Dt6(->marked), Dt6(->gclist));
# 3143 "buildvm_arm.dasc"
    break;

  /* -- Calls and vararg handling ----------------------------------------- */

  case BC_CALLM:
    //|  // RA = base*8, (RB = nresults+1,) RC = extra_nargs
    //|  ldr CARG1, SAVE_MULTRES
    //|  decode_RC8 NARGS8:RC, INS
    //|  add NARGS8:RC, NARGS8:RC, CARG1
    //|  b ->BC_CALL_Z
    dasm_put(Dst, 4711);
# 3153 "buildvm_arm.dasc"
    break;
  case BC_CALL:
    //|  decode_RC8 NARGS8:RC, INS
    //|  // RA = base*8, (RB = nresults+1,) RC = (nargs+1)*8
    //|->BC_CALL_Z:
    //|  mov RB, BASE			// Save old BASE for vmeta_call.
    //|  ldrd CARG34, [BASE, RA]!
    //|   sub NARGS8:RC, NARGS8:RC, #8
    //|   add BASE, BASE, #8
    //|  checkfunc CARG4, ->vmeta_call
    //|  ins_call
    dasm_put(Dst, 4717, -LJ_TFUNC, Dt7(->field_pc));
# 3164 "buildvm_arm.dasc"
    break;

  case BC_CALLMT:
    //|  // RA = base*8, (RB = 0,) RC = extra_nargs
    //|  ldr CARG1, SAVE_MULTRES
    //|  add NARGS8:RC, CARG1, RC, lsl #3
    //|  b ->BC_CALLT1_Z
    dasm_put(Dst, 4737);
# 3171 "buildvm_arm.dasc"
    break;
  case BC_CALLT:
    //|  lsl NARGS8:RC, RC, #3
    //|  // RA = base*8, (RB = 0,) RC = (nargs+1)*8
    //|->BC_CALLT1_Z:
    //|  ldrd LFUNC:CARG34, [RA, BASE]!
    //|   sub NARGS8:RC, NARGS8:RC, #8
    //|   add RA, RA, #8
    //|  checkfunc CARG4, ->vmeta_callt
    //|  ldr PC, [BASE, FRAME_PC]
    //|->BC_CALLT2_Z:
    //|   mov RB, #0
    //|   ldrb CARG4, LFUNC:CARG3->ffid
    //|  tst PC, #FRAME_TYPE
    //|  bne >7
    //|1:
    //|  str LFUNC:CARG3, [BASE, FRAME_FUNC]  // Copy function down, but keep PC.
    //|  cmp NARGS8:RC, #0
    //|  beq >3
    //|2:
    //|  ldrd CARG12, [RA, RB]
    //|   add INS, RB, #8
    //|   cmp INS, NARGS8:RC
    //|  strd CARG12, [BASE, RB]
    //|    mov RB, INS
    //|   bne <2
    //|3:
    //|  cmp CARG4, #1			// (> FF_C) Calling a fast function?
    //|  bhi >5
    //|4:
    //|  ins_callt
    //|
    //|5:  // Tailcall to a fast function with a Lua frame below.
    //|  ldr INS, [PC, #-4]
    //|  decode_RA8 RA, INS
    //|  sub CARG1, BASE, RA
    //|  ldr LFUNC:CARG1, [CARG1, #-16]
    //|  ldr CARG1, LFUNC:CARG1->field_pc
    //|  ldr KBASE, [CARG1, #PC2PROTO(k)]
    //|  b <4
    //|
    //|7:  // Tailcall from a vararg function.
    //|  eor PC, PC, #FRAME_VARG
    //|  tst PC, #FRAME_TYPEP		// Vararg frame below?
    //|  movne CARG4, #0			// Clear ffid if no Lua function below.
    dasm_put(Dst, 4742, -LJ_TFUNC, Dt7(->ffid), FRAME_TYPE, Dt7(->field_pc), Dt7(->field_pc), PC2PROTO(k), FRAME_VARG, FRAME_TYPEP);
# 3216 "buildvm_arm.dasc"
    //|  bne <1
    //|  sub BASE, BASE, PC
    //|  ldr PC, [BASE, FRAME_PC]
    //|  tst PC, #FRAME_TYPE
    //|  movne CARG4, #0			// Clear ffid if no Lua function below.
    //|  b <1
    dasm_put(Dst, 4803, FRAME_TYPE);
# 3222 "buildvm_arm.dasc"
    break;

  case BC_ITERC:
    //|  // RA = base*8, (RB = nresults+1, RC = nargs+1 (2+1))
    //|  add RA, BASE, RA
    //|   mov RB, BASE			// Save old BASE for vmeta_call.
    //|  ldrd CARG34, [RA, #-16]
    //|   ldrd CARG12, [RA, #-8]
    //|    add BASE, RA, #8
    //|  strd CARG34, [RA, #8]		// Copy state.
    //|   strd CARG12, [RA, #16]		// Copy control var.
    //|  // STALL: locked CARG34.
    //|  ldrd LFUNC:CARG34, [RA, #-24]
    //|    mov NARGS8:RC, #16		// Iterators get 2 arguments.
    //|  // STALL: load CARG34.
    //|  strd LFUNC:CARG34, [RA]		// Copy callable.
    //|  checkfunc CARG4, ->vmeta_call
    //|  ins_call
    dasm_put(Dst, 4814, -LJ_TFUNC, Dt7(->field_pc));
# 3240 "buildvm_arm.dasc"
    break;

  case BC_ITERN:
    //|  // RA = base*8, (RB = nresults+1, RC = nargs+1 (2+1))
#if LJ_HASJIT
    //|  // NYI: add hotloop, record BC_ITERN.
#endif
    //|  add RA, BASE, RA
    //|  ldr TAB:RB, [RA, #-16]
    //|  ldr CARG1, [RA, #-8]		// Get index from control var.
    //|  ldr INS, TAB:RB->asize
    //|   ldr CARG2, TAB:RB->array
    //|    add PC, PC, #4
    //|1:  // Traverse array part.
    //|  subs RC, CARG1, INS
    //|   add CARG3, CARG2, CARG1, lsl #3
    //|  bhs >5				// Index points after array part?
    //|   ldrd CARG34, [CARG3]
    //|   checktp CARG4, LJ_TNIL
    //|   addeq CARG1, CARG1, #1		// Skip holes in array part.
    //|   beq <1
    //|  ldrh RC, [PC, #-2]
    //|   mvn CARG2, #~LJ_TISNUM
    //|    strd CARG34, [RA, #8]
    //|  add RC, PC, RC, lsl #2
    //|    add RB, CARG1, #1
    //|   strd CARG12, [RA]
    //|  sub PC, RC, #0x20000
    //|    str RB, [RA, #-8]		// Update control var.
    //|3:
    //|  ins_next
    //|
    //|5:  // Traverse hash part.
    //|  ldr CARG4, TAB:RB->hmask
    //|   ldr NODE:RB, TAB:RB->node
    //|6:
    //|   add CARG1, RC, RC, lsl #1
    //|  cmp RC, CARG4			// End of iteration? Branch to ITERL+1.
    //|   add NODE:CARG3, NODE:RB, CARG1, lsl #3  // node = tab->node + idx*3*8
    //|  bhi <3
    //|   ldrd CARG12, NODE:CARG3->val
    //|   checktp CARG2, LJ_TNIL
    //|   add RC, RC, #1
    //|   beq <6				// Skip holes in hash part.
    //|  ldrh RB, [PC, #-2]
    //|   add RC, RC, INS
    //|    ldrd CARG34, NODE:CARG3->key
    //|   str RC, [RA, #-8]		// Update control var.
    //|   strd CARG12, [RA, #8]
    //|  add RC, PC, RB, lsl #2
    //|  sub PC, RC, #0x20000
    //|    strd CARG34, [RA]
    //|  b <3
    dasm_put(Dst, 4838, Dt6(->asize), Dt6(->array), -LJ_TNIL, ~LJ_TISNUM, Dt6(->hmask), Dt6(->node), DtB(->val), -LJ_TNIL, DtB(->key));
# 3293 "buildvm_arm.dasc"
    break;

  case BC_ISNEXT:
    //|  // RA = base*8, RC = target (points to ITERN)
    //|  add RA, BASE, RA
    //|     add RC, PC, RC, lsl #2
    //|  ldrd CFUNC:CARG12, [RA, #-24]
    //|   ldr CARG3, [RA, #-12]
    //|    ldr CARG4, [RA, #-4]
    //|  checktp CARG2, LJ_TFUNC
    //|  ldrbeq CARG1, CFUNC:CARG1->ffid
    //|   checktpeq CARG3, LJ_TTAB
    //|    checktpeq CARG4, LJ_TNIL
    //|  cmpeq CARG1, #FF_next_N
    //|     subeq PC, RC, #0x20000
    //|  bne >5
    //|   ins_next1
    //|   ins_next2
    //|  mov CARG1, #0
    //|  str CARG1, [RA, #-8]		// Initialize control var.
    //|1:
    //|   ins_next3
    //|5:  // Despecialize bytecode if any of the checks fail.
    //|  mov CARG1, #BC_JMP
    //|   mov OP, #BC_ITERC
    //|  strb CARG1, [PC, #-4]
    //|   sub PC, RC, #0x20000
    //|   strb OP, [PC]			// Subsumes ins_next1.
    //|   ins_next2
    //|  b <1
    dasm_put(Dst, 4903, -LJ_TFUNC, Dt8(->ffid), -LJ_TTAB, -LJ_TNIL, FF_next_N, BC_JMP, BC_ITERC);
# 3323 "buildvm_arm.dasc"
    break;

  case BC_VARG:
    //|  decode_RB8 RB, INS
    //|   decode_RC8 RC, INS
    //|  // RA = base*8, RB = (nresults+1)*8, RC = numparams*8
    //|  ldr CARG1, [BASE, FRAME_PC]
    //|  add RC, BASE, RC
    //|   add RA, BASE, RA
    //|  add RC, RC, #FRAME_VARG
    //|   add CARG4, RA, RB
    //|  sub CARG3, BASE, #8		// CARG3 = vtop
    //|  sub RC, RC, CARG1		// RC = vbase
    //|  // Note: RC may now be even _above_ BASE if nargs was < numparams.
    //|  cmp RB, #0
    //|   sub CARG1, CARG3, RC
    //|  beq >5				// Copy all varargs?
    //|   sub CARG4, CARG4, #16
    //|1:  // Copy vararg slots to destination slots.
    //|  cmp RC, CARG3
    //|  ldrdlo CARG12, [RC], #8
    //|  mvnhs CARG2, #~LJ_TNIL
    //|   cmp RA, CARG4
    //|  strd CARG12, [RA], #8
    //|   blo <1
    //|2:
    //|  ins_next
    //|
    //|5:  // Copy all varargs.
    //|  ldr CARG4, L->maxstack
    //|   cmp CARG1, #0
    //|   movle RB, #8			// MULTRES = (0+1)*8
    //|   addgt RB, CARG1, #8
    //|  add CARG2, RA, CARG1
    //|   str RB, SAVE_MULTRES
    //|   ble <2
    //|  cmp CARG2, CARG4
    //|  bhi >7
    //|6:
    //|   ldrd CARG12, [RC], #8
    //|   strd CARG12, [RA], #8
    //|  cmp RC, CARG3
    //|  blo <6
    //|  b <2
    //|
    //|7:  // Grow stack for varargs.
    //|  lsr CARG2, CARG1, #3
    //|   str RA, L->top
    //|  mov CARG1, L
    //|   str BASE, L->base
    //|  sub RC, RC, BASE			// Need delta, because BASE may change.
    //|   str PC, SAVE_PC
    //|  sub RA, RA, BASE
    //|  bl extern lj_state_growstack	// (lua_State *L, int n)
    //|  ldr BASE, L->base
    //|  add RA, BASE, RA
    //|  add RC, BASE, RC
    //|  sub CARG3, BASE, #8
    //|  b <6
    dasm_put(Dst, 4942, FRAME_VARG, ~LJ_TNIL, Dt1(->maxstack), Dt1(->top), Dt1(->base), Dt1(->base));
# 3382 "buildvm_arm.dasc"
    break;

  /* -- Returns ----------------------------------------------------------- */

  case BC_RETM:
    //|  // RA = results*8, RC = extra results
    //|  ldr CARG1, SAVE_MULTRES
    //|   ldr PC, [BASE, FRAME_PC]
    //|    add RA, BASE, RA
    //|  add RC, CARG1, RC, lsl #3
    //|  b ->BC_RETM_Z
    dasm_put(Dst, 5014);
# 3393 "buildvm_arm.dasc"
    break;

  case BC_RET:
    //|  // RA = results*8, RC = nresults+1
    //|  ldr PC, [BASE, FRAME_PC]
    //|   lsl RC, RC, #3
    //|    add RA, BASE, RA
    //|->BC_RETM_Z:
    //|   str RC, SAVE_MULTRES
    //|1:
    //|  ands CARG1, PC, #FRAME_TYPE
    //|   eor CARG2, PC, #FRAME_VARG
    //|  bne ->BC_RETV2_Z
    //|
    //|->BC_RET_Z:
    //|  // BASE = base, RA = resultptr, RC = (nresults+1)*8, PC = return
    //|  ldr INS, [PC, #-4]
    //|  subs CARG4, RC, #8
    //|   sub CARG3, BASE, #8
    //|  beq >3
    //|2:
    //|  ldrd CARG12, [RA], #8
    //|   add BASE, BASE, #8
    //|   subs CARG4, CARG4, #8
    //|  strd CARG12, [BASE, #-16]
    //|   bne <2
    //|3:
    //|  decode_RA8 RA, INS
    //|  sub CARG4, CARG3, RA
    //|   decode_RB8 RB, INS
    //|  ldr LFUNC:CARG1, [CARG4, FRAME_FUNC]
    //|5:
    //|  cmp RB, RC			// More results expected?
    //|  bhi >6
    //|  mov BASE, CARG4
    //|  ldr CARG2, LFUNC:CARG1->field_pc
    //|   ins_next1
    //|   ins_next2
    //|  ldr KBASE, [CARG2, #PC2PROTO(k)]
    //|   ins_next3
    //|
    //|6:  // Fill up results with nil.
    //|  mvn CARG2, #~LJ_TNIL
    //|  add BASE, BASE, #8
    //|   add RC, RC, #8
    //|  str CARG2, [BASE, #-12]
    //|  b <5
    //|
    //|->BC_RETV1_Z:  // Non-standard return case.
    //|  add RA, BASE, RA
    //|->BC_RETV2_Z:
    //|  tst CARG2, #FRAME_TYPEP
    //|  bne ->vm_return
    //|  // Return from vararg function: relocate BASE down.
    //|  sub BASE, BASE, CARG2
    //|  ldr PC, [BASE, FRAME_PC]
    //|  b <1
    dasm_put(Dst, 5021, FRAME_TYPE, FRAME_VARG, Dt7(->field_pc), PC2PROTO(k), ~LJ_TNIL, FRAME_TYPEP);
# 3450 "buildvm_arm.dasc"
    break;

  case BC_RET0: case BC_RET1:
    //|  // RA = results*8, RC = nresults+1
    //|  ldr PC, [BASE, FRAME_PC]
    //|   lsl RC, RC, #3
    //|   str RC, SAVE_MULTRES
    //|  ands CARG1, PC, #FRAME_TYPE
    //|   eor CARG2, PC, #FRAME_VARG
    //|   ldreq INS, [PC, #-4]
    //|  bne ->BC_RETV1_Z
    dasm_put(Dst, 5086, FRAME_TYPE, FRAME_VARG);
# 3461 "buildvm_arm.dasc"
    if (op == BC_RET1) {
      //|  ldrd CARG12, [BASE, RA]
      dasm_put(Dst, 5097);
# 3463 "buildvm_arm.dasc"
    }
    //|  sub CARG4, BASE, #8
    //|   decode_RA8 RA, INS
    dasm_put(Dst, 5099);
# 3466 "buildvm_arm.dasc"
    if (op == BC_RET1) {
      //|  strd CARG12, [CARG4]
      dasm_put(Dst, 5102);
# 3468 "buildvm_arm.dasc"
    }
    //|  sub BASE, CARG4, RA
    //|   decode_RB8 RB, INS
    //|  ldr LFUNC:CARG1, [BASE, FRAME_FUNC]
    //|5:
    //|  cmp RB, RC
    //|  bhi >6
    //|  ldr CARG2, LFUNC:CARG1->field_pc
    //|   ins_next1
    //|   ins_next2
    //|  ldr KBASE, [CARG2, #PC2PROTO(k)]
    //|   ins_next3
    //|
    //|6:  // Fill up results with nil.
    //|  sub CARG2, CARG4, #4
    //|  mvn CARG3, #~LJ_TNIL
    //|  str CARG3, [CARG2, RC]
    //|  add RC, RC, #8
    //|  b <5
    dasm_put(Dst, 5104, Dt7(->field_pc), PC2PROTO(k), ~LJ_TNIL);
# 3487 "buildvm_arm.dasc"
    break;

  /* -- Loops and branches ------------------------------------------------ */

  //|.define FOR_IDX,  [RA];      .define FOR_TIDX,  [RA, #4]
  //|.define FOR_STOP, [RA, #8];  .define FOR_TSTOP, [RA, #12]
  //|.define FOR_STEP, [RA, #16]; .define FOR_TSTEP, [RA, #20]
  //|.define FOR_EXT,  [RA, #24]; .define FOR_TEXT,  [RA, #28]

  case BC_FORL:
#if LJ_HASJIT
    //|  hotloop
    dasm_put(Dst, 5130);
# 3499 "buildvm_arm.dasc"
#endif
    //|  // Fall through. Assumes BC_IFORL follows.
    break;

  case BC_JFORI:
  case BC_JFORL:
#if !LJ_HASJIT
    break;
#endif
  case BC_FORI:
  case BC_IFORL:
    //|  // RA = base*8, RC = target (after end of loop or start of loop)
    vk = (op == BC_IFORL || op == BC_JFORL);
    //|  ldrd CARG12, [RA, BASE]!
    //|   add RC, PC, RC, lsl #2
    dasm_put(Dst, 5132);
# 3514 "buildvm_arm.dasc"
    if (!vk) {
      //|  ldrd CARG34, FOR_STOP
      //|   checktp CARG2, LJ_TISNUM
      //|  ldr RB, FOR_TSTEP
      //|   bne >5
      //|  checktp CARG4, LJ_TISNUM
      //|   ldr CARG4, FOR_STEP
      //|  checktpeq RB, LJ_TISNUM
      //|  bne ->vmeta_for
      //|  cmp CARG4, #0
      //|  blt >4
      //|  cmp CARG1, CARG3
      dasm_put(Dst, 5135, -LJ_TISNUM, -LJ_TISNUM, -LJ_TISNUM);
# 3526 "buildvm_arm.dasc"
    } else {
      //|  ldrd CARG34, FOR_STEP
      //|   checktp CARG2, LJ_TISNUM
      //|   bne >5
      //|  adds CARG1, CARG1, CARG3
      //|   ldr CARG4, FOR_STOP
      dasm_put(Dst, 5153, -LJ_TISNUM);
# 3532 "buildvm_arm.dasc"
      if (op == BC_IFORL) {
	//|  addvs RC, PC, #0x20000		// Overflow: prevent branch.
	dasm_put(Dst, 5161);
# 3534 "buildvm_arm.dasc"
      } else {
	//|  NYI
	dasm_put(Dst, 5163);
# 3536 "buildvm_arm.dasc"
      }
      //|  cmp CARG3, #0
      //|  blt >4
      //|  cmp CARG1, CARG4
      dasm_put(Dst, 5165);
# 3540 "buildvm_arm.dasc"
    }
    //|1:
    dasm_put(Dst, 5170);
# 3542 "buildvm_arm.dasc"
    if (op == BC_FORI) {
      //|  subgt PC, RC, #0x20000
      dasm_put(Dst, 5172);
# 3544 "buildvm_arm.dasc"
    } else if (op == BC_JFORI) {
      //|  NYI
      dasm_put(Dst, 5174);
# 3546 "buildvm_arm.dasc"
    } else if (op == BC_IFORL) {
      //|  suble PC, RC, #0x20000
      dasm_put(Dst, 5176);
# 3548 "buildvm_arm.dasc"
    } else {
      //|  NYI
      dasm_put(Dst, 5178);
# 3550 "buildvm_arm.dasc"
    }
    if (vk) {
      //|  strd CARG12, FOR_IDX
      dasm_put(Dst, 5180);
# 3553 "buildvm_arm.dasc"
    }
    //|   ins_next1
    //|   ins_next2
    //|  strd CARG12, FOR_EXT
    //|3:
    //|   ins_next3
    //|
    //|4:  // Invert check for negative step.
    dasm_put(Dst, 5182);
# 3561 "buildvm_arm.dasc"
    if (!vk) {
      //|  cmp CARG3, CARG1
      dasm_put(Dst, 5192);
# 3563 "buildvm_arm.dasc"
    } else {
      //|  cmp CARG4, CARG1
      dasm_put(Dst, 5194);
# 3565 "buildvm_arm.dasc"
    }
    //|  b <1
    //|
    //|5:  // FP loop.
    dasm_put(Dst, 5196);
# 3569 "buildvm_arm.dasc"
    if (!vk) {
      //|  cmnlo CARG4, #-LJ_TISNUM
      //|  cmnlo RB, #-LJ_TISNUM
      //|  bhs ->vmeta_for
      //|  cmp RB, #0
      //|   strd CARG12, FOR_IDX
      //|   strd CARG12, FOR_EXT
      //|  blt >8
      dasm_put(Dst, 5200, -LJ_TISNUM, -LJ_TISNUM);
# 3577 "buildvm_arm.dasc"
    } else {
      //|  cmp CARG4, #0
      //|  blt >8
      //|  bl extern __aeabi_dadd
      //|   strd CARG12, FOR_IDX
      //|  ldrd CARG34, FOR_STOP
      //|   strd CARG12, FOR_EXT
      dasm_put(Dst, 5212);
# 3584 "buildvm_arm.dasc"
    }
    //|6:
    //|  bl extern __aeabi_cdcmple
    dasm_put(Dst, 5221);
# 3587 "buildvm_arm.dasc"
    if (op == BC_FORI) {
      //|  subhi PC, RC, #0x20000
      dasm_put(Dst, 5225);
# 3589 "buildvm_arm.dasc"
    } else if (op == BC_JFORI) {
      //|  NYI
      dasm_put(Dst, 5227);
# 3591 "buildvm_arm.dasc"
    } else if (op == BC_IFORL) {
      //|  subls PC, RC, #0x20000
      dasm_put(Dst, 5229);
# 3593 "buildvm_arm.dasc"
    } else {
      //|  NYI
      dasm_put(Dst, 5231);
# 3595 "buildvm_arm.dasc"
    }
    //|  ins_next1
    //|  ins_next2
    //|  b <3
    //|
    //|8:  // Invert check for negative step.
    dasm_put(Dst, 5233);
# 3601 "buildvm_arm.dasc"
    if (vk) {
      //|  bl extern __aeabi_dadd
      //|  strd CARG12, FOR_IDX
      //|  strd CARG12, FOR_EXT
      dasm_put(Dst, 5239);
# 3605 "buildvm_arm.dasc"
    }
    //|  mov CARG3, CARG1
    //|  mov CARG4, CARG2
    //|  ldrd CARG12, FOR_STOP
    //|  b <6
    dasm_put(Dst, 5244);
# 3610 "buildvm_arm.dasc"
    break;

  case BC_ITERL:
#if LJ_HASJIT
    //|  hotloop
    dasm_put(Dst, 5250);
# 3615 "buildvm_arm.dasc"
#endif
    //|  // Fall through. Assumes BC_IITERL follows.
    break;

  case BC_JITERL:
#if !LJ_HASJIT
    break;
#endif
  case BC_IITERL:
    //|  // RA = base*8, RC = target
    //|  ldrd CARG12, [RA, BASE]!
    dasm_put(Dst, 5252);
# 3626 "buildvm_arm.dasc"
    if (op == BC_JITERL) {
      //|  NYI
      dasm_put(Dst, 5254);
# 3628 "buildvm_arm.dasc"
    } else {
      //|   add RC, PC, RC, lsl #2
      //|  // STALL: load CARG12.
      //|  cmn CARG2, #-LJ_TNIL		// Stop if iterator returned nil.
      //|  subne PC, RC, #0x20000		// Otherwise save control var + branch.
      //|  strdne CARG12, [RA, #-8]
      dasm_put(Dst, 5256, -LJ_TNIL);
# 3634 "buildvm_arm.dasc"
    }
    //|  ins_next
    dasm_put(Dst, 5262);
# 3636 "buildvm_arm.dasc"
    break;

  case BC_LOOP:
    //|  // RA = base*8, RC = target (loop extent)
    //|  // Note: RA/RC is only used by trace recorder to determine scope/extent
    //|  // This opcode does NOT jump, it's only purpose is to detect a hot loop.
#if LJ_HASJIT
    //|  hotloop
    dasm_put(Dst, 5269);
# 3644 "buildvm_arm.dasc"
#endif
    //|  // Fall through. Assumes BC_ILOOP follows.
    break;

  case BC_ILOOP:
    //|  // RA = base*8, RC = target (loop extent)
    //|  ins_next
    dasm_put(Dst, 5271);
# 3651 "buildvm_arm.dasc"
    break;

  case BC_JLOOP:
#if LJ_HASJIT
    //|  NYI
    dasm_put(Dst, 5278);
# 3656 "buildvm_arm.dasc"
#endif
    break;

  case BC_JMP:
    //|  // RA = base*8 (only used by trace recorder), RC = target
    //|  add RC, PC, RC, lsl #2
    //|  sub PC, RC, #0x20000
    //|  ins_next
    dasm_put(Dst, 5280);
# 3664 "buildvm_arm.dasc"
    break;

  /* -- Function headers -------------------------------------------------- */

  case BC_FUNCF:
#if LJ_HASJIT
    //|  hotcall
    dasm_put(Dst, 5289);
# 3671 "buildvm_arm.dasc"
#endif
  case BC_FUNCV:  /* NYI: compiled vararg functions. */
    //|  // Fall through. Assumes BC_IFUNCF/BC_IFUNCV follow.
    break;

  case BC_JFUNCF:
#if !LJ_HASJIT
    break;
#endif
  case BC_IFUNCF:
    //|  // BASE = new base, RA = BASE+framesize*8, CARG3 = LFUNC, RC = nargs*8
    //|  ldr CARG1, L->maxstack
    //|   ldrb CARG2, [PC, #-4+PC2PROTO(numparams)]
    //|    ldr KBASE, [PC, #-4+PC2PROTO(k)]
    //|  cmp RA, CARG1
    //|  bhi ->vm_growstack_l
    //|  ins_next1
    //|  ins_next2
    //|2:
    //|  cmp NARGS8:RC, CARG2, lsl #3	// Check for missing parameters.
    //|   mvn CARG4, #~LJ_TNIL
    //|  ble >3
    dasm_put(Dst, 5291, Dt1(->maxstack), -4+PC2PROTO(numparams), -4+PC2PROTO(k), ~LJ_TNIL);
# 3693 "buildvm_arm.dasc"
    if (op == BC_JFUNCF) {
      //|  NYI
      dasm_put(Dst, 5309);
# 3695 "buildvm_arm.dasc"
    } else {
      //|  ins_next3
      dasm_put(Dst, 5311);
# 3697 "buildvm_arm.dasc"
    }
    //|
    //|3:  // Clear missing parameters.
    //|  strd CARG34, [BASE, NARGS8:RC]
    //|  add NARGS8:RC, NARGS8:RC, #8
    //|  b <2
    dasm_put(Dst, 5316);
# 3703 "buildvm_arm.dasc"
    break;

  case BC_JFUNCV:
#if !LJ_HASJIT
    break;
#endif
    //|  NYI  // NYI: compiled vararg functions
    dasm_put(Dst, 5322);
# 3710 "buildvm_arm.dasc"
    break;  /* NYI: compiled vararg functions. */

  case BC_IFUNCV:
    //|  // BASE = new base, RA = BASE+framesize*8, CARG3 = LFUNC, RC = nargs*8
    //|  ldr CARG1, L->maxstack
    //|   add CARG4, BASE, RC
    //|  add RA, RA, RC
    //|   str LFUNC:CARG3, [CARG4]	// Store copy of LFUNC.
    //|   add CARG2, RC, #8+FRAME_VARG
    //|    ldr KBASE, [PC, #-4+PC2PROTO(k)]
    //|  cmp RA, CARG1
    //|   str CARG2, [CARG4, #4]		// Store delta + FRAME_VARG.
    //|  bhs ->vm_growstack_l
    //|  ldrb RB, [PC, #-4+PC2PROTO(numparams)]
    //|   mov RA, BASE
    //|   mov RC, CARG4
    //|  cmp RB, #0
    //|   add BASE, CARG4, #8
    //|  beq >3
    //|  mvn CARG3, #~LJ_TNIL
    //|1:
    //|  cmp RA, RC			// Less args than parameters?
    //|   ldrdlo CARG12, [RA], #8
    //|   movhs CARG2, CARG3
    //|    strlo CARG3, [RA, #-4]		// Clear old fixarg slot (help the GC).
    //|2:
    //|  subs RB, RB, #1
    //|   strd CARG12, [CARG4, #8]!
    //|  bne <1
    //|3:
    //|  ins_next
    dasm_put(Dst, 5324, Dt1(->maxstack), 8+FRAME_VARG, -4+PC2PROTO(k), -4+PC2PROTO(numparams), ~LJ_TNIL);
# 3741 "buildvm_arm.dasc"
    break;

  case BC_FUNCC:
  case BC_FUNCCW:
    //|  // BASE = new base, RA = BASE+framesize*8, CARG3 = CFUNC, RC = nargs*8
    if (op == BC_FUNCC) {
      //|  ldr CARG4, CFUNC:CARG3->f
      dasm_put(Dst, 5365, Dt8(->f));
# 3748 "buildvm_arm.dasc"
    } else {
      //|  ldr CARG4, [DISPATCH, #DISPATCH_GL(wrapf)]
      dasm_put(Dst, 5368, DISPATCH_GL(wrapf));
# 3750 "buildvm_arm.dasc"
    }
    //|   add CARG2, RA, NARGS8:RC
    //|   ldr CARG1, L->maxstack
    //|  add RC, BASE, NARGS8:RC
    //|    str BASE, L->base
    //|   cmp CARG2, CARG1
    //|  str RC, L->top
    dasm_put(Dst, 5371, Dt1(->maxstack), Dt1(->base), Dt1(->top));
# 3757 "buildvm_arm.dasc"
    if (op == BC_FUNCCW) {
      //|  ldr CARG2, CFUNC:CARG3->f
      dasm_put(Dst, 5381, Dt8(->f));
# 3759 "buildvm_arm.dasc"
    }
    //|    mv_vmstate CARG3, C
    //|  mov CARG1, L
    //|   bhi ->vm_growstack_c		// Need to grow stack.
    //|    st_vmstate CARG3
    //|  blx CARG4			// (lua_State *L [, lua_CFunction f])
    //|  // Returns nresults.
    //|  ldr BASE, L->base
    //|    mv_vmstate CARG3, INTERP
    //|   ldr CRET2, L->top
    //|   lsl RC, CRET1, #3
    //|    st_vmstate CARG3
    //|  ldr PC, [BASE, FRAME_PC]
    //|   sub RA, CRET2, RC		// RA = L->top - nresults*8
    //|  b ->vm_returnc
    dasm_put(Dst, 5384, LJ_VMST_C, DISPATCH_GL(vmstate), Dt1(->base), LJ_VMST_INTERP, Dt1(->top), DISPATCH_GL(vmstate));
# 3774 "buildvm_arm.dasc"
    break;

  /* ---------------------------------------------------------------------- */

  default:
    fprintf(stderr, "Error: undefined opcode BC_%s\n", bc_names[op]);
    exit(2);
    break;
  }
}

static int build_backend(BuildCtx *ctx)
{
  int op;

  dasm_growpc(Dst, BC__MAX);

  build_subroutines(ctx);

  //|.code_op
  dasm_put(Dst, 5406);
# 3794 "buildvm_arm.dasc"
  for (op = 0; op < BC__MAX; op++)
    build_ins(ctx, (BCOp)op, op);

  return BC__MAX;
}

/* Emit pseudo frame-info for all assembler functions. */
static void emit_asm_debug(BuildCtx *ctx)
{
  int i;
  switch (ctx->mode) {
  case BUILD_elfasm:
    fprintf(ctx->fp, "\t.section .debug_frame,\"\",%%progbits\n");
    fprintf(ctx->fp,
	".Lframe0:\n"
	"\t.long .LECIE0-.LSCIE0\n"
	".LSCIE0:\n"
	"\t.long 0xffffffff\n"
	"\t.byte 0x1\n"
	"\t.string \"\"\n"
	"\t.uleb128 0x1\n"
	"\t.sleb128 -4\n"
	"\t.byte 0xe\n"				/* Return address is in lr. */
	"\t.byte 0xc\n\t.uleb128 0xd\n\t.uleb128 0\n"	/* def_cfa sp */
	"\t.align 2\n"
	".LECIE0:\n\n");
    fprintf(ctx->fp,
	".LSFDE0:\n"
	"\t.long .LEFDE0-.LASFDE0\n"
	".LASFDE0:\n"
	"\t.long .Lframe0\n"
	"\t.long .Lbegin\n"
	"\t.long %d\n"
	"\t.byte 0xe\n\t.uleb128 %d\n"		/* def_cfa_offset */
	"\t.byte 0x8e\n\t.uleb128 1\n",		/* Restore lr. */
	(int)ctx->codesz, CFRAME_SIZE);
    for (i = 11; i >= 4; i--)  /* Restore r4-r11. */
      fprintf(ctx->fp, "\t.byte %d\n\t.uleb128 %d\n", 0x80+i, 2+(11-i));
    fprintf(ctx->fp,
	"\t.align 2\n"
	".LEFDE0:\n\n");
    /* NYI: emit ARM.exidx. */
    break;
  default:
    break;
  }
}

